(function(ae,A){typeof exports=="object"&&typeof module<"u"?A(exports,require("three"),require("mapbox-gl")):typeof define=="function"&&define.amd?define(["exports","three","mapbox-gl"],A):(ae=typeof globalThis<"u"?globalThis:ae||self,A(ae["mapbox-3d-tiles"]={},ae.THREE,ae.mapboxgl))})(this,function(ae,A,Gs){"use strict";var ot;function no(a){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const t in a)if(t!=="default"){const s=Object.getOwnPropertyDescriptor(a,t);Object.defineProperty(e,t,s.get?s:{enumerable:!0,get:()=>a[t]})}}return e.default=a,Object.freeze(e)}const Y=no(A);class ai extends A.Object3D{constructor(e=document.createElement("div")){super(),this.isCSS2DObject=!0,this.element=e,this.element.style.position="absolute",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.center=new A.Vector2(.5,.5),this.addEventListener("removed",function(){this.traverse(function(t){t.element instanceof t.element.ownerDocument.defaultView.Element&&t.element.parentNode!==null&&t.element.remove()})})}copy(e,t){return super.copy(e,t),this.element=e.element.cloneNode(!0),this.center=e.center,this}}const lt=new A.Vector3,oi=new A.Matrix4,ci=new A.Matrix4,Ai=new A.Vector3,li=new A.Vector3;class io{constructor(e={}){const t=this;let s,n,i,r;const o={objects:new WeakMap},c=e.element!==void 0?e.element:document.createElement("div");c.style.overflow="hidden",this.domElement=c,this.getSize=function(){return{width:s,height:n}},this.render=function(p,g){p.matrixWorldAutoUpdate===!0&&p.updateMatrixWorld(),g.parent===null&&g.matrixWorldAutoUpdate===!0&&g.updateMatrixWorld(),oi.copy(g.matrixWorldInverse),ci.multiplyMatrices(g.projectionMatrix,oi),h(p,p,g),f(p)},this.setSize=function(p,g){s=p,n=g,i=s/2,r=n/2,c.style.width=p+"px",c.style.height=g+"px"};function l(p){p.isCSS2DObject&&(p.element.style.display="none");for(let g=0,m=p.children.length;g<m;g++)l(p.children[g])}function h(p,g,m){if(p.visible===!1){l(p);return}if(p.isCSS2DObject){lt.setFromMatrixPosition(p.matrixWorld),lt.applyMatrix4(ci);const I=lt.z>=-1&&lt.z<=1&&p.layers.test(m.layers)===!0,b=p.element;b.style.display=I===!0?"":"none",I===!0&&(p.onBeforeRender(t,g,m),b.style.transform="translate("+-100*p.center.x+"%,"+-100*p.center.y+"%)translate("+(lt.x*i+i)+"px,"+(-lt.y*r+r)+"px)",b.parentNode!==c&&c.appendChild(b),p.onAfterRender(t,g,m));const C={distanceToCameraSquared:u(m,p)};o.objects.set(p,C)}for(let I=0,b=p.children.length;I<b;I++)h(p.children[I],g,m)}function u(p,g){return Ai.setFromMatrixPosition(p.matrixWorld),li.setFromMatrixPosition(g.matrixWorld),Ai.distanceToSquared(li)}function d(p){const g=[];return p.traverseVisible(function(m){m.isCSS2DObject&&g.push(m)}),g}function f(p){const g=d(p).sort(function(I,b){if(I.renderOrder!==b.renderOrder)return b.renderOrder-I.renderOrder;const C=o.objects.get(I).distanceToCameraSquared,y=o.objects.get(b).distanceToCameraSquared;return C-y}),m=g.length;for(let I=0,b=g.length;I<b;I++)g[I].element.style.zIndex=m-I}}}class ro{constructor(e,t){if(this._map=e,this._renderer&&this._labelRenderer)return;let s=new A.WebGLRenderer({alpha:!0,antialias:!0,canvas:e.getCanvas(),context:t});s.shadowMap.enabled=!0,s.autoClear=!1;let n=new io;n.setSize(e._containerWidth,e._containerHeight),n.domElement.style.position="absolute",n.domElement.style.top="0px",n.domElement.style.pointerEvents="none",e._container.appendChild(n.domElement),e.on("resize",()=>{n.setSize(e._containerWidth,e._containerHeight)}),this._renderer=s,this._labelRenderer=n}getRenderer(){return this._renderer}render(e,t){this._renderer.resetState(),this._renderer.render(e,t),this._labelRenderer.render(e,t)}}class ao extends A.DataTextureLoader{constructor(e){super(e),this.type=A.HalfFloatType}parse(e){const r=function(x,w){switch(x){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(w||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(w||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(w||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(w||""))}},h=`
`,u=function(x,w,S){w=w||1024;let E=x.pos,N=-1,k=0,O="",P=String.fromCharCode.apply(null,new Uint16Array(x.subarray(E,E+128)));for(;0>(N=P.indexOf(h))&&k<w&&E<x.byteLength;)O+=P,k+=P.length,E+=128,P+=String.fromCharCode.apply(null,new Uint16Array(x.subarray(E,E+128)));return-1<N?(x.pos+=k+N+1,O+P.slice(0,N)):!1},d=function(x){const w=/^#\?(\S+)/,S=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,Q=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,E=/^\s*FORMAT=(\S+)\s*$/,N=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,k={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let O,P;for((x.pos>=x.byteLength||!(O=u(x)))&&r(1,"no header found"),(P=O.match(w))||r(3,"bad initial token"),k.valid|=1,k.programtype=P[1],k.string+=O+`
`;O=u(x),O!==!1;){if(k.string+=O+`
`,O.charAt(0)==="#"){k.comments+=O+`
`;continue}if((P=O.match(S))&&(k.gamma=parseFloat(P[1])),(P=O.match(Q))&&(k.exposure=parseFloat(P[1])),(P=O.match(E))&&(k.valid|=2,k.format=P[1]),(P=O.match(N))&&(k.valid|=4,k.height=parseInt(P[1],10),k.width=parseInt(P[2],10)),k.valid&2&&k.valid&4)break}return k.valid&2||r(3,"missing format specifier"),k.valid&4||r(3,"missing image size specifier"),k},f=function(x,w,S){const Q=w;if(Q<8||Q>32767||x[0]!==2||x[1]!==2||x[2]&128)return new Uint8Array(x);Q!==(x[2]<<8|x[3])&&r(3,"wrong scanline width");const E=new Uint8Array(4*w*S);E.length||r(4,"unable to allocate buffer space");let N=0,k=0;const O=4*Q,P=new Uint8Array(4),M=new Uint8Array(O);let j=S;for(;j>0&&k<x.byteLength;){k+4>x.byteLength&&r(1),P[0]=x[k++],P[1]=x[k++],P[2]=x[k++],P[3]=x[k++],(P[0]!=2||P[1]!=2||(P[2]<<8|P[3])!=Q)&&r(3,"bad rgbe scanline format");let q=0,z;for(;q<O&&k<x.byteLength;){z=x[k++];const X=z>128;if(X&&(z-=128),(z===0||q+z>O)&&r(3,"bad scanline data"),X){const $=x[k++];for(let de=0;de<z;de++)M[q++]=$}else M.set(x.subarray(k,k+z),q),q+=z,k+=z}const Z=Q;for(let X=0;X<Z;X++){let $=0;E[N]=M[X+$],$+=Q,E[N+1]=M[X+$],$+=Q,E[N+2]=M[X+$],$+=Q,E[N+3]=M[X+$],N+=4}j--}return E},p=function(x,w,S,Q){const E=x[w+3],N=Math.pow(2,E-128)/255;S[Q+0]=x[w+0]*N,S[Q+1]=x[w+1]*N,S[Q+2]=x[w+2]*N,S[Q+3]=1},g=function(x,w,S,Q){const E=x[w+3],N=Math.pow(2,E-128)/255;S[Q+0]=A.DataUtils.toHalfFloat(Math.min(x[w+0]*N,65504)),S[Q+1]=A.DataUtils.toHalfFloat(Math.min(x[w+1]*N,65504)),S[Q+2]=A.DataUtils.toHalfFloat(Math.min(x[w+2]*N,65504)),S[Q+3]=A.DataUtils.toHalfFloat(1)},m=new Uint8Array(e);m.pos=0;const I=d(m),b=I.width,C=I.height,y=f(m.subarray(m.pos),b,C);let B,v,_;switch(this.type){case A.FloatType:_=y.length/4;const x=new Float32Array(_*4);for(let S=0;S<_;S++)p(y,S*4,x,S*4);B=x,v=A.FloatType;break;case A.HalfFloatType:_=y.length/4;const w=new Uint16Array(_*4);for(let S=0;S<_;S++)g(y,S*4,w,S*4);B=w,v=A.HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:b,height:C,data:B,header:I.string,gamma:I.gamma,exposure:I.exposure,type:v}}setDataType(e){return this.type=e,this}load(e,t,s,n){function i(r,o){switch(r.type){case A.FloatType:case A.HalfFloatType:r.colorSpace=A.LinearSRGBColorSpace,r.minFilter=A.LinearFilter,r.magFilter=A.LinearFilter,r.generateMipmaps=!1,r.flipY=!0;break}t&&t(r,o)}return super.load(e,i,s,n)}}class _e{static updateWorldMatrix(e,t=null){const s=t||e.getCenter(),n=Gs.MercatorCoordinate.fromLngLat(s),i=n.meterInMercatorCoordinateUnits(),r=[0,0,0],o=new A.Matrix4;return o.compose(new A.Vector3(n.x,n.y,n.z),new A.Quaternion().setFromEuler(new A.Euler(r[0],r[1],r[2])),new A.Vector3(i,-i,i)),o}static toScenePositionMercator(e,t){return new A.Vector3(t.x,t.y,t.z).applyMatrix4(e)}static toMapPositionMercator(e,t){const s=t.clone().applyMatrix4(e);return new Gs.MercatorCoordinate(s.x,s.y,s.z)}static toScenePosition(e,t,s){const n=Gs.MercatorCoordinate.fromLngLat(t,s);return this.toScenePositionMercator(e,n)}static toMapPosition(e,t){const s=this.toMapPositionMercator(e,t),n=s.toLngLat(),i=s.toAltitude();return[n.lng,n.lat,i]}static degToRad(e){return e/180*Math.PI}static radToDeg(e){return e/Math.PI*180}static toSceneGeometry(e){}}class oo{createScene(e=!0){const t=new A.Scene;if(e){const s=new A.DirectionalLight(16777215,4);s.position.set(1,2,3),t.add(s);const n=new A.AmbientLight(16777215,.2);t.add(n)}return t}createGroup(e,t){const s=new A.Group;return s.name=t,e.add(s),s}createCamera(e,t){const s=new A.PerspectiveCamera;s.name=t;const n=new A.Group;return n.name=t+"-parent",n.add(s),e.add(n),s}_calcProjectionMatrices(e){const t=e.centerOffset;let s;const n=e._camera.getCameraToClipPerspective(e._fov,e.width/e.height,e._nearZ,e._farZ);if(n[8]=-t.x*2/e.width,n[9]=t.y*2/e.height,e.isOrthographic){const r=(g,m,I)=>(1-I)*g+I*m,o=g=>g*g*g*g*g,c=(g,m,I,b)=>{for(let C=0;C<16;C++)g[C]=r(m[C],I[C],b);return g};let h=.5*e.height/Math.tan(e._fov/2)*1*Math.tan(e._fov*.5),u=h*e.aspect,d=-u,f=-h;u-=t.x,d-=t.x,h+=t.y,f+=t.y,s=e._camera.getCameraToClipOrthographic(d,u,f,h,e._nearZ,e._farZ);const p=e.pitch>=15?1:e.pitch/15;c(s,s,n,o(p))}else s=n;return new A.Matrix4().fromArray(s)}updateCameraForRender(e,t,s,n,i){const r=new A.Matrix4().fromArray(s),o=new A.Matrix4().multiplyMatrices(r,n);e.fov=_e.radToDeg(t.transform.fovX),e.aspect=t.transform.aspect,e.near=t.transform._nearZ,e.far=t.transform._farZ;const c=t.transform;this._calcProjectionMatrices(c);const l=this._calcProjectionMatrices(c);e.projectionMatrix.copy(l),e.projectionMatrixInverse.copy(e.projectionMatrix).invert();const h=e.projectionMatrixInverse,u=new A.Matrix4().multiplyMatrices(h,o),d=u.clone().invert();e.matrixWorld.copy(d),e.matrixWorldInverse.copy(u),e.matrixAutoUpdate=!1,e.matrixWorldAutoUpdate=!1;const f=new A.Vector3,p=new A.Quaternion,g=new A.Vector3;e.matrixWorld.decompose(f,p,g),e.position.set(f.x,f.y,f.z);const m=new A.Euler().setFromQuaternion(p,"YXZ");e.rotation.set(m.x,m.y,m.z)}createEnvTexture(e,t){e&&e.length>3&&e.indexOf(".hdr")===e.length-4&&new ao().load(e,n=>{n.mapping=A.EquirectangularReflectionMapping,t.environment=n,t.environmentRotation.x=Math.PI/2})}}const ht="scene-update",Kt="scene-recenter";function hi(a){if(!a)return null;const e=a.replace(/[a-z]+:\/\/[^/]+/i,"").replace(/\?.*$/i,"").replace(/.*\//g,""),t=e.lastIndexOf(".");return t===-1?null:e.substring(t+1)||null}const ui=2**30;class di{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(e){e.length===1?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(t,s)=>{const n=e(t),i=e(s);return n<i?-1:n>i?1:0}):this._unloadPriorityCallback=e}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=.3*ui,this.maxBytesSize=.4*ui,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const e=this.itemSet;this.defaultPriorityCallback=t=>e.get(t)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(e){return this.bytesMap.get(e)||0}setMemoryUsage(e,t){const{bytesMap:s,itemSet:n}=this;n.has(e)&&(this.cachedBytes-=s.get(e)||0,s.set(e,t),this.cachedBytes+=t)}add(e,t){const s=this.itemSet;if(s.has(e)||this.isFull())return!1;const n=this.usedSet,i=this.itemList,r=this.callbacks;return i.push(e),n.add(e),s.set(e,Date.now()),r.set(e,t),!0}has(e){return this.itemSet.has(e)}remove(e){const t=this.usedSet,s=this.itemSet,n=this.itemList,i=this.bytesMap,r=this.callbacks,o=this.loadedSet;if(s.has(e)){this.cachedBytes-=i.get(e)||0,i.delete(e),r.get(e)(e);const c=n.indexOf(e);return n.splice(c,1),t.delete(e),s.delete(e),r.delete(e),o.delete(e),!0}return!1}setLoaded(e,t){const{itemSet:s,loadedSet:n}=this;s.has(e)&&(t===!0?n.add(e):n.delete(e))}markUsed(e){const t=this.itemSet,s=this.usedSet;t.has(e)&&!s.has(e)&&(t.set(e,Date.now()),s.add(e))}markUnused(e){this.usedSet.delete(e)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:e,minSize:t,maxSize:s,itemList:n,itemSet:i,usedSet:r,loadedSet:o,callbacks:c,bytesMap:l,minBytesSize:h,maxBytesSize:u}=this,d=n.length-r.size,f=n.length-o.size,p=Math.max(Math.min(n.length-t,d),0),g=this.cachedBytes-h,m=this.unloadPriorityCallback||this.defaultPriorityCallback;let I=!1;const b=p>0&&d>0||f&&n.length>s;if(d&&this.cachedBytes>h||f&&this.cachedBytes>u||b){n.sort((S,Q)=>{const E=r.has(S),N=r.has(Q);if(E===N){const k=o.has(S),O=o.has(Q);return k===O?-m(S,Q):k?1:-1}else return E?1:-1});const y=Math.max(t*e,p*e),B=Math.ceil(Math.min(y,d,p)),v=Math.max(e*g,e*h),_=Math.min(v,g);let x=0,w=0;for(;this.cachedBytes-w>u||n.length-x>s;){const S=n[x],Q=l.get(S)||0;if(r.has(S)&&o.has(S)||this.cachedBytes-w-Q<u&&n.length-x<=s)break;w+=Q,x++}for(;w<_||x<B;){const S=n[x],Q=l.get(S)||0;if(r.has(S)||this.cachedBytes-w-Q<h&&x>=B)break;w+=Q,x++}n.splice(0,x).forEach(S=>{this.cachedBytes-=l.get(S)||0,c.get(S)(S),l.delete(S),i.delete(S),c.delete(S),o.delete(S),r.delete(S)}),I=x<p||w<g&&x<d,I=I&&x>0}I&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}}class Ps{get running(){return this.items.length!==0||this.currJobs!==0}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")},this.schedulingCallback=e=>{requestAnimationFrame(e)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const e=this.priorityCallback;this.items.sort(e)}has(e){return this.callbacks.has(e)}add(e,t){const s={callback:t,reject:null,resolve:null,promise:null};return s.promise=new Promise((n,i)=>{const r=this.items,o=this.callbacks;s.resolve=n,s.reject=i,r.push(e),o.set(e,s),this.autoUpdate&&this.scheduleJobRun()}),s.promise}remove(e){const t=this.items,s=this.callbacks,n=t.indexOf(e);if(n!==-1){const i=s.get(e);i.promise.catch(()=>{}),i.reject(new Error("PriorityQueue: Item removed.")),t.splice(n,1),s.delete(e)}}removeByFilter(e){const{items:t}=this;for(let s=0;s<t.length;s++){const n=t[s];e(n)&&this.remove(n)}}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,s=this.maxJobs;let n=0;const i=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&e.length>0&&n<s;){this.currJobs++,n++;const r=e.pop(),{callback:o,resolve:c,reject:l}=t.get(r);t.delete(r);let h;try{h=o(r)}catch(u){l(u),i()}h instanceof Promise?h.then(c).catch(l).finally(i):(c(h),i())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}const ut=-1,ke=0,Jt=1,Us=2,yt=3,fi=6378137,co=6356752314245179e-9,Yt={inView:!1,error:1/0,distanceFromCamera:1/0};function pi(a){return a===yt||a===ut}function ze(a,e){return a.__lastFrameVisited===e&&a.__used}function Ns(a){return a.__childrenProcessed===a.children.length}function Os(a,e){a.__lastFrameVisited!==e.frameCount&&(a.__lastFrameVisited=e.frameCount,a.__used=!1,a.__inFrustum=!1,a.__isLeaf=!1,a.__visible=!1,a.__active=!1,a.__error=1/0,a.__distanceFromCamera=1/0,a.__childrenWereVisible=!1,a.__allChildrenLoaded=!1,e.calculateTileViewError(a,Yt),a.__inFrustum=Yt.inView,a.__error=Yt.error,a.__distanceFromCamera=Yt.distanceFromCamera)}function gi(a,e){if(e.ensureChildrenArePreprocessed(a),Os(a,e),Rs(a,e),!a.__hasRenderableContent&&Ns(a)){const t=a.children;for(let s=0,n=t.length;s<n;s++)gi(t[s],e)}}function mi(a,e){if(e.ensureChildrenArePreprocessed(a),ze(a,e.frameCount)&&(a.__hasContent&&a.__loadingState===ke&&!e.lruCache.isFull()&&e.queueTileForDownload(a),Ns(a))){const t=a.children;for(let s=0,n=t.length;s<n;s++)mi(t[s],e)}}function Rs(a,e){a.__used||(a.__used=!0,e.markTileUsed(a),e.stats.used++,a.__inFrustum===!0&&e.stats.inFrustum++)}function Ao(a,e){return!(a.__error<=e.errorTarget||e.maxDepth>0&&a.__depth+1>=e.maxDepth||!Ns(a))}function Vs(a,e=null,t=null){const s=[];for(s.push(a),s.push(null),s.push(0);s.length>0;){const n=s.pop(),i=s.pop(),r=s.pop();if(e&&e(r,i,n)){t&&t(r,i,n);return}const o=r.children;if(o)for(let c=o.length-1;c>=0;c--)s.push(o[c]),s.push(r),s.push(n+1);t&&t(r,i,n)}}function bi(a,e){if(e.ensureChildrenArePreprocessed(a),Os(a,e),!a.__inFrustum)return;if(!Ao(a,e)){Rs(a,e);return}let t=!1,s=!1;const n=a.children;for(let i=0,r=n.length;i<r;i++){const o=n[i];bi(o,e),t=t||ze(o,e.frameCount),s=s||o.__inFrustum}if(Rs(a,e),t&&a.refine==="REPLACE")for(let i=0,r=n.length;i<r;i++){const o=n[i];gi(o,e)}}function Ci(a,e){const t=e.frameCount;if(!ze(a,t))return;const s=a.children;let n=!1;for(let i=0,r=s.length;i<r;i++){const o=s[i];n=n||ze(o,t)}if(!n)a.__isLeaf=!0;else{let i=!1,r=!0;for(let o=0,c=s.length;o<c;o++){const l=s[o];if(Ci(l,e),i=i||l.__wasSetVisible||l.__childrenWereVisible,ze(l,t)){const h=l.__allChildrenLoaded||l.__hasRenderableContent&&pi(l.__loadingState)||!l.__hasContent&&l.children.length===0||l.__hasUnrenderableContent&&l.__loadingState===ut;r=r&&h}}a.__childrenWereVisible=i,a.__allChildrenLoaded=r}}function Ii(a,e){const t=e.stats;if(!ze(a,e.frameCount))return;const s=e.lruCache;if(a.__isLeaf){a.__loadingState===yt?(a.__inFrustum&&(a.__visible=!0,t.visible++),a.__active=!0,t.active++):!s.isFull()&&a.__hasContent&&e.queueTileForDownload(a);return}const n=a.children,i=a.__hasContent,r=pi(a.__loadingState)&&i,o=(e.errorTarget+1)*e.errorThreshold,c=a.__error<=o,l=a.__childrenWereVisible,h=a.__allChildrenLoaded;if((c||a.refine==="ADD")&&!r&&!s.isFull()&&i&&e.queueTileForDownload(a),(c&&!h&&!l&&r||a.refine==="ADD"&&r)&&(a.__inFrustum&&(a.__visible=!0,t.visible++),a.__active=!0,t.active++),a.refine==="REPLACE"&&c&&!h)for(let d=0,f=n.length;d<f;d++){const p=n[d];ze(p,e.frameCount)&&mi(p,e)}else for(let d=0,f=n.length;d<f;d++)Ii(n[d],e)}function yi(a,e){const t=ze(a,e.frameCount);if(t||a.__usedLastFrame){let s=!1,n=!1;t?(s=a.__active,e.displayActiveTiles?n=a.__active||a.__visible:n=a.__visible):Os(a,e),a.__hasRenderableContent&&a.__loadingState===yt&&(a.__wasSetActive!==s&&e.invokeOnePlugin(r=>r.setTileActive&&r.setTileActive(a,s)),a.__wasSetVisible!==n&&e.invokeOnePlugin(r=>r.setTileVisible&&r.setTileVisible(a,n))),a.__wasSetActive=s,a.__wasSetVisible=n,a.__usedLastFrame=t;const i=a.children;for(let r=0,o=i.length;r<o;r++){const c=i[r];yi(c,e)}}}function lo(a,e=null){let t=a;for(;t;){const s=t.__depth,n=t.parent;e&&e(t,n,s),t=n}}function ho(a){let e=null;return()=>{e===null&&(e=requestAnimationFrame(()=>{e=null,a()}))}}const Bi=Symbol("PLUGIN_REGISTERED"),zs=(a,e)=>{const t=a.priority||0,s=e.priority||0;return t!==s?t>s?1:-1:a.__depthFromRenderedParent!==e.__depthFromRenderedParent?a.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:a.__inFrustum!==e.__inFrustum?a.__inFrustum?1:-1:a.__used!==e.__used?a.__used?1:-1:a.__error!==e.__error?a.__error>e.__error?1:-1:a.__distanceFromCamera!==e.__distanceFromCamera?a.__distanceFromCamera>e.__distanceFromCamera?-1:1:0},uo=(a,e)=>{const t=a.priority||0,s=e.priority||0;return t!==s?t>s?1:-1:a.__depthFromRenderedParent!==e.__depthFromRenderedParent?a.__depthFromRenderedParent>e.__depthFromRenderedParent?1:-1:a.__loadingState!==e.__loadingState?a.__loadingState>e.__loadingState?-1:1:a.__lastFrameVisited!==e.__lastFrameVisited?a.__lastFrameVisited>e.__lastFrameVisited?-1:1:a.__hasUnrenderableContent!==e.__hasUnrenderableContent?a.__hasUnrenderableContent?-1:1:a.__error!==e.__error?a.__error>e.__error?-1:1:0};class fo{get root(){const e=this.rootTileSet;return e?e.root:null}get loadProgress(){const{stats:e,isLoading:t}=this,s=e.downloading+e.parsing,n=e.inCacheSinceLoad+(t?1:0);return n===0?1:1-s/n}get errorThreshold(){return this._errorThreshold}set errorThreshold(e){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=e}constructor(e=null){this.rootLoadingState=ke,this.rootTileSet=null,this.rootURL=e,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const t=new di;t.unloadPriorityCallback=uo;const s=new Ps;s.maxJobs=25,s.priorityCallback=zs;const n=new Ps;n.maxJobs=5,n.priorityCallback=zs;const i=new Ps;i.maxJobs=25,i.priorityCallback=zs,i.log=!0,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=t,this.downloadQueue=s,this.parseQueue=n,this.processNodeQueue=i,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=ho(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(e){if(e[Bi]===!0)throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const t=this.plugins,s=e.priority||0;let n=t.length;for(let i=0;i<t.length;i++)if((t[i].priority||0)>s){n=i;break}t.splice(n,0,e),e[Bi]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if(typeof e=="string"&&(e=this.getPluginByName(name)),t.includes(e)){const s=t.indexOf(e);return t.splice(s,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find(t=>t.name===e)||null}traverse(e,t,s=!0){this.root&&Vs(this.root,(n,...i)=>(s&&this.ensureChildrenArePreprocessed(n,!0),e?e(n,...i):!1),t)}queueTileForDownload(e){e.__loadingState===ke&&this.queuedTiles.push(e)}markTileUsed(e){this.usedSet.add(e),this.lruCache.markUsed(e)}update(){const{lruCache:e,usedSet:t,stats:s,root:n,downloadQueue:i,parseQueue:r,processNodeQueue:o}=this;if(this.rootLoadingState===ke&&(this.rootLoadingState=Jt,this.invokeOnePlugin(h=>h.loadRootTileSet&&h.loadRootTileSet()).then(h=>{let u=this.rootURL;u!==null&&this.invokeAllPlugins(d=>u=d.preprocessURL?d.preprocessURL(u,null):u),this.rootLoadingState=yt,this.rootTileSet=h,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:h,url:u})}).catch(h=>{this.rootLoadingState=ut,console.error(h),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:h,url:this.rootURL})})),!n)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,t.forEach(h=>e.markUnused(h)),t.clear(),bi(n,this),Ci(n,this),Ii(n,this),yi(n,this);const c=this.queuedTiles;c.sort(e.unloadPriorityCallback);for(let h=0,u=c.length;h<u&&!e.isFull();h++)this.requestTileContents(c[h]);c.length=0,e.scheduleUnload(),(i.running||r.running||o.running)===!1&&this.isLoading===!0&&(this.cachedSinceLoadComplete.clear(),s.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===ut&&(this.rootLoadingState=ke);const e=this.stats;e.failed!==0&&(this.traverse(t=>{t.__loadingState===ut&&(t.__loadingState=ke)},null,!1),e.failed=0)}dispose(){[...this.plugins].forEach(n=>{this.unregisterPlugin(n)});const t=this.lruCache,s=[];this.traverse(n=>(s.push(n),!1),null,!1);for(let n=0,i=s.length;n<i;n++)t.remove(s[n]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(e,t){return 0}dispatchEvent(e){}fetchData(e,t){return fetch(e,t)}parseTile(e,t,s){return null}disposeTile(e){e.__visible&&(this.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,!1)),e.__visible=!1),e.__active&&(this.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,!1)),e.__active=!1)}preprocessNode(e,t,s=null){var n;if(this.processedTiles.add(e),e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=s,e.children=e.children||[],(n=e.content)!=null&&n.uri){const i=hi(e.content.uri);e.__hasContent=!0,e.__hasUnrenderableContent=!!(i&&/json$/.test(i)),e.__hasRenderableContent=!e.__hasUnrenderableContent}else e.__hasContent=!1,e.__hasUnrenderableContent=!1,e.__hasRenderableContent=!1;e.__childrenProcessed=0,s&&s.__childrenProcessed++,e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__childrenWereVisible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=ke,s===null?(e.__depth=0,e.__depthFromRenderedParent=e.__hasRenderableContent?1:0,e.refine=e.refine||"REPLACE"):(e.__depth=s.__depth+1,e.__depthFromRenderedParent=s.__depthFromRenderedParent+(e.__hasRenderableContent?1:0),e.refine=e.refine||s.refine),e.__basePath=t,e.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(e,t,s)})}setTileActive(e,t){t?this.activeTiles.add(e):this.activeTiles.delete(e)}setTileVisible(e,t){t?this.visibleTiles.add(e):this.visibleTiles.delete(e)}calculateTileViewError(e,t){}ensureChildrenArePreprocessed(e,t=!1){const s=e.children;for(let n=0,i=s.length;n<i;n++){const r=s[n];if("__depth"in r)break;t?(this.processNodeQueue.remove(r),this.preprocessNode(r,e.__basePath,e)):this.processNodeQueue.has(r)||this.processNodeQueue.add(r,o=>{this.preprocessNode(o,e.__basePath,e),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(e){let t=0;return this.invokeAllPlugins(s=>{s.calculateBytesUsed&&(t+=s.calculateBytesUsed(e,e.cached.scene)||0)}),t}recalculateBytesUsed(e=null){const{lruCache:t,processedTiles:s}=this;e===null?t.itemSet.forEach(n=>{s.has(n)&&t.setMemoryUsage(n,this.getBytesUsed(n))}):t.setMemoryUsage(e,this.getBytesUsed(e))}preprocessTileSet(e,t,s=null){const n=e.asset.version,[i,r]=n.split(".").map(c=>parseInt(c));console.assert(i<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),i===1&&r>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=t.replace(/\/[^/]*$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(e.root,o,s)}loadRootTileSet(){let e=this.rootURL;return this.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),this.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.fetchOptions)).then(s=>{if(s instanceof Response){if(s.ok)return s.json();throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${s.status} : ${s.statusText}`)}else return s}).then(s=>(this.preprocessTileSet(s,e),s))}requestTileContents(e){if(e.__loadingState!==ke)return;let t=!1,s=null,n=new URL(e.content.uri,e.__basePath+"/").toString();this.invokeAllPlugins(f=>n=f.preprocessURL?f.preprocessURL(n,e):n);const i=this.stats,r=this.lruCache,o=this.downloadQueue,c=this.parseQueue,l=hi(n),h=new AbortController,u=h.signal;if(r.add(e,f=>{h.abort(),t?(f.children.length=0,f.__childrenProcessed=0):this.invokeAllPlugins(p=>{p.disposeTile&&p.disposeTile(f)}),i.inCache--,this.cachedSinceLoadComplete.has(e)&&(this.cachedSinceLoadComplete.delete(e),i.inCacheSinceLoad--),f.__loadingState===Jt?i.downloading--:f.__loadingState===Us&&i.parsing--,f.__loadingState=ke,c.remove(f),o.remove(f)}))return this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),r.setMemoryUsage(e,this.getBytesUsed(e)),this.cachedSinceLoadComplete.add(e),i.inCacheSinceLoad++,i.inCache++,i.downloading++,e.__loadingState=Jt,o.add(e,f=>{if(u.aborted)return Promise.resolve();const p=this.invokeOnePlugin(g=>g.fetchData&&g.fetchData(n,{...this.fetchOptions,signal:u}));return this.dispatchEvent({type:"tile-download-start",tile:e}),p}).then(f=>{if(!u.aborted)if(f instanceof Response){if(f.ok)return l==="json"?f.json():f.arrayBuffer();throw new Error(`Failed to load model with error code ${f.status}`)}else return f}).then(f=>{if(!u.aborted)return i.downloading--,i.parsing++,e.__loadingState=Us,c.add(e,p=>u.aborted?Promise.resolve():l==="json"&&f.root?(this.preprocessTileSet(f,n,e),e.children.push(f.root),s=f,t=!0,Promise.resolve()):this.invokeOnePlugin(g=>g.parseTile&&g.parseTile(f,p,l,n,u)))}).then(()=>{if(!u.aborted){if(i.parsing--,e.__loadingState=yt,r.setLoaded(e,!0),r.getMemoryUsage(e)===0){const f=this.getBytesUsed(e);if(r.isFull()&&f>0){r.remove(e);return}else r.setMemoryUsage(e,f)}this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),t&&this.dispatchEvent({type:"load-tile-set",tileSet:s,url:n}),e.cached.scene&&this.dispatchEvent({type:"load-model",scene:e.cached.scene,tile:e})}}).catch(f=>{u.aborted||(f.name!=="AbortError"?(c.remove(e),o.remove(e),e.__loadingState===Us?i.parsing--:e.__loadingState===Jt&&i.downloading--,i.failed++,console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`),console.error(f),e.__loadingState=ut,r.setLoaded(e,!0),this.dispatchEvent({type:"load-error",tile:e,error:f,url:n})):r.remove(e))})}getAttributions(e=[]){return this.invokeAllPlugins(t=>t!==this&&t.getAttributions&&t.getAttributions(e)),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}invokeAllPlugins(e){const t=[...this.plugins,this],s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s.length===0?null:Promise.all(s)}}class Bt{constructor(){this.fetchOptions={},this.workingPath=""}load(...e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...e)}loadAsync(e){return fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(t=>(this.workingPath===""&&(this.workingPath=this.workingPathForURL(e)),this.parse(t)))}resolveExternalURL(e){return/^[^\\/]/.test(e)&&!/^http/.test(e)?this.workingPath+"/"+e:e}workingPathForURL(e){const t=e.split(/[\\/]/g);return t.pop(),t.join("/")+"/"}parse(e){throw new Error("LoaderBase: Parse not implemented.")}}const po=new TextDecoder;function js(a){return po.decode(a)}function xi(a,e,t,s,n,i){let r;switch(s){case"SCALAR":r=1;break;case"VEC2":r=2;break;case"VEC3":r=3;break;case"VEC4":r=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${i}".`)}let o;const c=t*r;switch(n){case"BYTE":o=new Int8Array(a,e,c);break;case"UNSIGNED_BYTE":o=new Uint8Array(a,e,c);break;case"SHORT":o=new Int16Array(a,e,c);break;case"UNSIGNED_SHORT":o=new Uint16Array(a,e,c);break;case"INT":o=new Int32Array(a,e,c);break;case"UNSIGNED_INT":o=new Uint32Array(a,e,c);break;case"FLOAT":o=new Float32Array(a,e,c);break;case"DOUBLE":o=new Float64Array(a,e,c);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${i}".`)}return o}class Xt{constructor(e,t,s,n){this.buffer=e,this.binOffset=t+s,this.binLength=n;let i=null;if(s!==0){const r=new Uint8Array(e,t,s);i=JSON.parse(js(r))}else i={};this.header=i}getKeys(){return Object.keys(this.header)}getData(e,t,s=null,n=null){const i=this.header;if(!(e in i))return null;const r=i[e];if(r instanceof Object){if(Array.isArray(r))return r;{const{buffer:o,binOffset:c,binLength:l}=this,h=r.byteOffset||0,u=r.type||n,d=r.componentType||s;if("type"in r&&n&&r.type!==n)throw new Error("FeatureTable: Specified type does not match expected type.");const f=c+h,p=xi(o,f,t,u,d,e);if(f+p.byteLength>c+l)throw new Error("FeatureTable: Feature data read outside binary body length.");return p}}else return r}getBuffer(e,t){const{buffer:s,binOffset:n}=this;return s.slice(n+e,n+e+t)}}class go{constructor(e){this.batchTable=e;const t=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=t.classes;for(const n of this.classes){const i=n.instances;for(const r in i)n.instances[r]=this._parseProperty(i[r],n.length,r)}if(this.instancesLength=t.instancesLength,this.classIds=this._parseProperty(t.classIds,this.instancesLength,"classIds"),t.parentCounts?this.parentCounts=this._parseProperty(t.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),t.parentIds){const n=this.parentCounts.reduce((i,r)=>i+r,0);this.parentIds=this._parseProperty(t.parentIds,n,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const n of this.classIds)s[n]=s[n]??0,this.instancesIds.push(s[n]),s[n]++}_parseProperty(e,t,s){if(Array.isArray(e))return e;{const{buffer:n,binOffset:i}=this.batchTable,r=e.byteOffset,o=e.componentType||"UNSIGNED_SHORT",c=i+r;return xi(n,c,t,"SCALAR",o,s)}}getDataFromId(e,t={}){const s=this.parentCounts[e];if(this.parentIds&&s>0){let c=0;for(let l=0;l<e;l++)c+=this.parentCounts[l];for(let l=0;l<s;l++){const h=this.parentIds[c+l];h!==e&&this.getDataFromId(h,t)}}const n=this.classIds[e],i=this.classes[n].instances,r=this.classes[n].name,o=this.instancesIds[e];for(const c in i)t[r]=t[r]||{},t[r][c]=i[c][o];return t}}class qs extends Xt{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(e,t,s,n,i){super(e,s,n,i),this.count=t,this.extensions={};const r=this.header.extensions;r&&r["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new go(this))}getData(e,t=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(e,this.count,t,s)}getDataFromId(e,t={}){if(e<0||e>=this.count)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())s!=="extensions"&&(t[s]=super.getData(s,this.count)[e]);for(const s in this.extensions){const n=this.extensions[s];n.getDataFromId instanceof Function&&(t[s]=t[s]||{},n.getDataFromId(e,t[s]))}return t}getPropertyArray(e){return super.getData(e,this.count)}}function He(a){if(a===null||a.byteLength<4)return"";let e;if(a instanceof DataView?e=a:e=new DataView(a),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let s=0;s<4;s++)t+=String.fromCharCode(e.getUint8(s));return t}class mo extends Bt{parse(e){const t=new DataView(e),s=He(t);console.assert(s==="b3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),c=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+o),d=new Xt(u,0,r,o),f=h+r+o,p=e.slice(f,f+c+l),g=new qs(p,d.getData("BATCH_LENGTH"),0,c,l),m=f+c+l,I=new Uint8Array(e,m,i-m);return{version:n,featureTable:d,batchTable:g,glbBytes:I}}}class bo extends Bt{parse(e){const t=new DataView(e),s=He(t);console.assert(s==="i3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),c=t.getUint32(20,!0),l=t.getUint32(24,!0),h=t.getUint32(28,!0),u=32,d=e.slice(u,u+r+o),f=new Xt(d,0,r,o),p=u+r+o,g=e.slice(p,p+c+l),m=new qs(g,f.getData("INSTANCES_LENGTH"),0,c,l),I=p+c+l,b=new Uint8Array(e,I,i-I);let C=null,y=null,B=null;if(h)C=b,y=Promise.resolve();else{const v=this.resolveExternalURL(js(b)),_=v.split(/[\\/]/g);_.pop(),B=_.join("/"),y=fetch(v,this.fetchOptions).then(x=>{if(!x.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${v}" with status ${x.status} : ${x.statusText}`);return x.arrayBuffer()}).then(x=>{C=new Uint8Array(x)})}return y.then(()=>({version:n,featureTable:f,batchTable:m,glbBytes:C,gltfWorkingPath:B}))}}class Co extends Bt{parse(e){const t=new DataView(e),s=He(t);console.assert(s==="pnts");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),c=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+o),d=new Xt(u,0,r,o),f=h+r+o,p=e.slice(f,f+c+l),g=new qs(p,d.getData("BATCH_LENGTH")||d.getData("POINTS_LENGTH"),0,c,l);return Promise.resolve({version:n,featureTable:d,batchTable:g})}}class Io extends Bt{parse(e){const t=new DataView(e),s=He(t);console.assert(s==="cmpt",'CMPTLoader: The magic bytes equal "cmpt".');const n=t.getUint32(4,!0);console.assert(n===1,'CMPTLoader: The version listed in the header is "1".');const i=t.getUint32(8,!0);console.assert(i===e.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const r=t.getUint32(12,!0),o=[];let c=16;for(let l=0;l<r;l++){const h=new DataView(e,c,12),u=He(h),d=h.getUint32(4,!0),f=h.getUint32(8,!0),p=new Uint8Array(e,c,f);o.push({type:u,buffer:p,version:d}),c+=f}return{version:n,tiles:o}}}function yo(a){let e=0;for(const s in a.attributes){const n=a.getAttribute(s);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const t=a.getIndex();return e+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,e}function _i(a,e){if(e===A.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(e===A.TriangleFanDrawMode||e===A.TriangleStripDrawMode){let t=a.getIndex();if(t===null){const r=[],o=a.getAttribute("position");if(o!==void 0){for(let c=0;c<o.count;c++)r.push(c);a.setIndex(r),t=a.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a}const s=t.count-2,n=[];if(e===A.TriangleFanDrawMode)for(let r=1;r<=s;r++)n.push(t.getX(0)),n.push(t.getX(r)),n.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(n.push(t.getX(r)),n.push(t.getX(r+1)),n.push(t.getX(r+2))):(n.push(t.getX(r+2)),n.push(t.getX(r+1)),n.push(t.getX(r)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=a.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),a}let Zt=class extends A.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new vo(t)}),this.register(function(t){return new So(t)}),this.register(function(t){return new Go(t)}),this.register(function(t){return new Po(t)}),this.register(function(t){return new Uo(t)}),this.register(function(t){return new Mo(t)}),this.register(function(t){return new Do(t)}),this.register(function(t){return new Lo(t)}),this.register(function(t){return new Eo(t)}),this.register(function(t){return new wo(t)}),this.register(function(t){return new Fo(t)}),this.register(function(t){return new Qo(t)}),this.register(function(t){return new ko(t)}),this.register(function(t){return new To(t)}),this.register(function(t){return new xo(t)}),this.register(function(t){return new No(t)}),this.register(function(t){return new Oo(t)})}load(e,t,s,n){const i=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const l=A.LoaderUtils.extractUrlBase(e);r=A.LoaderUtils.resolveURL(l,this.path)}else r=A.LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const o=function(l){n?n(l):console.error(l),i.manager.itemError(e),i.manager.itemEnd(e)},c=new A.FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(l){try{i.parse(l,r,function(h){t(h),i.manager.itemEnd(e)},o)}catch(h){o(h)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const r={},o={},c=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.decode(new Uint8Array(e,0,4))===wi){try{r[W.KHR_BINARY_GLTF]=new Ro(e)}catch(u){n&&n(u);return}i=JSON.parse(r[W.KHR_BINARY_GLTF].content)}else i=JSON.parse(c.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new ec(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const u=this.pluginCallbacks[h](l);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[u.name]=u,r[u.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const u=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(u){case W.KHR_MATERIALS_UNLIT:r[u]=new _o;break;case W.KHR_DRACO_MESH_COMPRESSION:r[u]=new Vo(i,this.dracoLoader);break;case W.KHR_TEXTURE_TRANSFORM:r[u]=new zo;break;case W.KHR_MESH_QUANTIZATION:r[u]=new jo;break;default:d.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}l.setExtensions(r),l.setPlugins(o),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}};function Bo(){let a={};return{get:function(e){return a[e]},add:function(e,t){a[e]=t},remove:function(e){delete a[e]},removeAll:function(){a={}}}}const W={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};let xo=class{constructor(e){this.parser=e,this.name=W.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let l;const h=new A.Color(16777215);c.color!==void 0&&h.setRGB(c.color[0],c.color[1],c.color[2],A.LinearSRGBColorSpace);const u=c.range!==void 0?c.range:0;switch(c.type){case"directional":l=new A.DirectionalLight(h),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new A.PointLight(h),l.distance=u;break;case"spot":l=new A.SpotLight(h),l.distance=u,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,l.angle=c.spot.outerConeAngle,l.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return l.position.set(0,0,0),Ge(l,c),c.intensity!==void 0&&(l.intensity=c.intensity),l.name=t.createUniqueName(c.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(c){return s._getNodeRef(t.cache,o,c)})}},_o=class{constructor(){this.name=W.KHR_MATERIALS_UNLIT}getMaterialType(){return A.MeshBasicMaterial}extendParams(e,t,s){const n=[];e.color=new A.Color(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],A.LinearSRGBColorSpace),e.opacity=r[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,A.SRGBColorSpace))}return Promise.all(n)}},wo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}},vo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const o=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new A.Vector2(o,o)}return Promise.all(i)}},So=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}},Qo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}},Mo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new A.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const o=r.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,A.SRGBColorSpace)),r.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}},Do=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}},Lo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return t.attenuationColor=new A.Color().setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace),Promise.all(i)}},Eo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}},Fo=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return t.specularColor=new A.Color().setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace),r.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,A.SRGBColorSpace)),Promise.all(i)}},To=class{constructor(e){this.parser=e,this.name=W.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&i.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}},ko=class{constructor(e){this.parser=e,this.name=W.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&i.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}},Go=class{constructor(e){this.parser=e,this.name=W.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}},Po=class{constructor(e){this.parser=e,this.name=W.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let c=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(c=l)}return s.loadTextureImage(e,r.source,c)}},Uo=class{constructor(e){this.parser=e,this.name=W.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let c=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(c=l)}return s.loadTextureImage(e,r.source,c)}},No=class{constructor(e){this.name=W.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(o){const c=n.byteOffset||0,l=n.byteLength||0,h=n.count,u=n.byteStride,d=new Uint8Array(o,c,l);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,u,d,n.mode,n.filter).then(function(f){return f.buffer}):r.ready.then(function(){const f=new ArrayBuffer(h*u);return r.decodeGltfBuffer(new Uint8Array(f),h,u,d,n.mode,n.filter),f})})}else return null}},Oo=class{constructor(e){this.name=W.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==me.TRIANGLES&&l.mode!==me.TRIANGLE_STRIP&&l.mode!==me.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=s.extensions[this.name].attributes,o=[],c={};for(const l in r)o.push(this.parser.getDependency("accessor",r[l]).then(h=>(c[l]=h,c[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const h=l.pop(),u=h.isGroup?h.children:[h],d=l[0].count,f=[];for(const p of u){const g=new A.Matrix4,m=new A.Vector3,I=new A.Quaternion,b=new A.Vector3(1,1,1),C=new A.InstancedMesh(p.geometry,p.material,d);for(let y=0;y<d;y++)c.TRANSLATION&&m.fromBufferAttribute(c.TRANSLATION,y),c.ROTATION&&I.fromBufferAttribute(c.ROTATION,y),c.SCALE&&b.fromBufferAttribute(c.SCALE,y),C.setMatrixAt(y,g.compose(m,I,b));for(const y in c)if(y==="_COLOR_0"){const B=c[y];C.instanceColor=new A.InstancedBufferAttribute(B.array,B.itemSize,B.normalized)}else y!=="TRANSLATION"&&y!=="ROTATION"&&y!=="SCALE"&&p.geometry.setAttribute(y,c[y]);A.Object3D.prototype.copy.call(C,p),this.parser.assignFinalMaterial(C),f.push(C)}return h.isGroup?(h.clear(),h.add(...f),h):f[0]}))}};const wi="glTF",xt=12,vi={JSON:1313821514,BIN:5130562};let Ro=class{constructor(e){this.name=W.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,xt),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==wi)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-xt,i=new DataView(e,xt);let r=0;for(;r<n;){const o=i.getUint32(r,!0);r+=4;const c=i.getUint32(r,!0);if(r+=4,c===vi.JSON){const l=new Uint8Array(e,xt+r,o);this.content=s.decode(l)}else if(c===vi.BIN){const l=xt+r;this.body=e.slice(l,l+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}},Vo=class{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=W.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,o={},c={},l={};for(const h in r){const u=Ks[h]||h.toLowerCase();o[u]=r[h]}for(const h in e.attributes){const u=Ks[h]||h.toLowerCase();if(r[h]!==void 0){const d=s.accessors[e.attributes[h]],f=dt[d.componentType];l[u]=f.name,c[u]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(u,d){n.decodeDracoFile(h,function(f){for(const p in f.attributes){const g=f.attributes[p],m=c[p];m!==void 0&&(g.normalized=m)}u(f)},o,l,A.LinearSRGBColorSpace,d)})})}},zo=class{constructor(){this.name=W.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}},jo=class{constructor(){this.name=W.KHR_MESH_QUANTIZATION}},Si=class extends A.Interpolant{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let r=0;r!==n;r++)t[r]=s[i+r];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,r=this.sampleValues,o=this.valueSize,c=o*2,l=o*3,h=n-t,u=(s-t)/h,d=u*u,f=d*u,p=e*l,g=p-l,m=-2*f+3*d,I=f-d,b=1-m,C=I-d+u;for(let y=0;y!==o;y++){const B=r[g+y+o],v=r[g+y+c]*h,_=r[p+y+o],x=r[p+y]*h;i[y]=b*B+C*v+m*_+I*x}return i}};const qo=new A.Quaternion;let Wo=class extends Si{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return qo.fromArray(i).normalize().toArray(i),i}};const me={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},dt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Qi={9728:A.NearestFilter,9729:A.LinearFilter,9984:A.NearestMipmapNearestFilter,9985:A.LinearMipmapNearestFilter,9986:A.NearestMipmapLinearFilter,9987:A.LinearMipmapLinearFilter},Mi={33071:A.ClampToEdgeWrapping,33648:A.MirroredRepeatWrapping,10497:A.RepeatWrapping},Ws={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ks={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},je={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Ko={CUBICSPLINE:void 0,LINEAR:A.InterpolateLinear,STEP:A.InterpolateDiscrete},Js={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Jo(a){return a.DefaultMaterial===void 0&&(a.DefaultMaterial=new A.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:A.FrontSide})),a.DefaultMaterial}function et(a,e,t){for(const s in t.extensions)a[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Ge(a,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(a.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Yo(a,e,t){let s=!1,n=!1,i=!1;for(let l=0,h=e.length;l<h;l++){const u=e[l];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(a);const r=[],o=[],c=[];for(let l=0,h=e.length;l<h;l++){const u=e[l];if(s){const d=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):a.attributes.position;r.push(d)}if(n){const d=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):a.attributes.normal;o.push(d)}if(i){const d=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):a.attributes.color;c.push(d)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(c)]).then(function(l){const h=l[0],u=l[1],d=l[2];return s&&(a.morphAttributes.position=h),n&&(a.morphAttributes.normal=u),i&&(a.morphAttributes.color=d),a.morphTargetsRelative=!0,a})}function Xo(a,e){if(a.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)a.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(a.morphTargetInfluences.length===t.length){a.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)a.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Zo(a){let e;const t=a.extensions&&a.extensions[W.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Ys(t.attributes):e=a.indices+":"+Ys(a.attributes)+":"+a.mode,a.targets!==void 0)for(let s=0,n=a.targets.length;s<n;s++)e+=":"+Ys(a.targets[s]);return e}function Ys(a){let e="";const t=Object.keys(a).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+a[t[s]]+";";return e}function Xs(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function $o(a){return a.search(/\.jpe?g($|\?)/i)>0||a.search(/^data\:image\/jpeg/)===0?"image/jpeg":a.search(/\.webp($|\?)/i)>0||a.search(/^data\:image\/webp/)===0?"image/webp":a.search(/\.ktx2($|\?)/i)>0||a.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const Ho=new A.Matrix4;let ec=class{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Bo,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,i=!1,r=-1;if(typeof navigator<"u"){const o=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(o)===!0;const c=o.match(/Version\/(\d+)/);n=s&&c?parseInt(c[1],10):-1,i=o.indexOf("Firefox")>-1,r=i?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||i&&r<98?this.textureLoader=new A.TextureLoader(this.options.manager):this.textureLoader=new A.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new A.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const o={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:s,userData:{}};return et(i,o,n),Ge(o,n),Promise.all(s._invokeAll(function(c){return c.afterRoot&&c.afterRoot(o)})).then(function(){for(const c of o.scenes)c.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n].joints;for(let o=0,c=r.length;o<c;o++)e[r[o]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const r=e[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(r,o)=>{const c=this.associations.get(r);c!=null&&this.associations.set(o,c);for(const[l,h]of r.children.entries())i(h,o.children[l])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[W.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,r){s.load(A.LoaderUtils.resolveURL(t.uri,n.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const r=Ws[n.type],o=dt[n.componentType],c=n.normalized===!0,l=new o(n.count*r);return Promise.resolve(new A.BufferAttribute(l,r,c))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(r){const o=r[0],c=Ws[n.type],l=dt[n.componentType],h=l.BYTES_PER_ELEMENT,u=h*c,d=n.byteOffset||0,f=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,p=n.normalized===!0;let g,m;if(f&&f!==u){const I=Math.floor(d/f),b="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+I+":"+n.count;let C=t.cache.get(b);C||(g=new l(o,I*f,n.count*f/h),C=new A.InterleavedBuffer(g,f/h),t.cache.add(b,C)),m=new A.InterleavedBufferAttribute(C,c,d%f/h,p)}else o===null?g=new l(n.count*c):g=new l(o,d,n.count*c),m=new A.BufferAttribute(g,c,p);if(n.sparse!==void 0){const I=Ws.SCALAR,b=dt[n.sparse.indices.componentType],C=n.sparse.indices.byteOffset||0,y=n.sparse.values.byteOffset||0,B=new b(r[1],C,n.sparse.count*I),v=new l(r[2],y,n.sparse.count*c);o!==null&&(m=new A.BufferAttribute(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let _=0,x=B.length;_<x;_++){const w=B[_];if(m.setX(w,v[_*c]),c>=2&&m.setY(w,v[_*c+1]),c>=3&&m.setZ(w,v[_*c+2]),c>=4&&m.setW(w,v[_*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=p}return m})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let o=this.textureLoader;if(r.uri){const c=s.manager.getHandler(r.uri);c!==null&&(o=c)}return this.loadTextureImage(e,i,o)}loadTextureImage(e,t,s){const n=this,i=this.json,r=i.textures[e],o=i.images[t],c=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[c])return this.textureCache[c];const l=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||o.name||"",h.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(h.name=o.uri);const d=(i.samplers||{})[r.sampler]||{};return h.magFilter=Qi[d.magFilter]||A.LinearFilter,h.minFilter=Qi[d.minFilter]||A.LinearMipmapLinearFilter,h.wrapS=Mi[d.wrapS]||A.RepeatWrapping,h.wrapT=Mi[d.wrapT]||A.RepeatWrapping,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==A.NearestFilter&&h.minFilter!==A.LinearFilter,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[c]=l,l}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const r=n.images[e],o=self.URL||self.webkitURL;let c=r.uri||"",l=!1;if(r.bufferView!==void 0)c=s.getDependency("bufferView",r.bufferView).then(function(u){l=!0;const d=new Blob([u],{type:r.mimeType});return c=o.createObjectURL(d),c});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(c).then(function(u){return new Promise(function(d,f){let p=d;t.isImageBitmapLoader===!0&&(p=function(g){const m=new A.Texture(g);m.needsUpdate=!0,d(m)}),t.load(A.LoaderUtils.resolveURL(u,i.path),p,void 0,f)})}).then(function(u){return l===!0&&o.revokeObjectURL(c),Ge(u,r),u.userData.mimeType=r.mimeType||$o(r.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),u});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),i.extensions[W.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[W.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const c=i.associations.get(r);r=i.extensions[W.KHR_TEXTURE_TRANSFORM].extendTexture(r,o),i.associations.set(r,c)}}return n!==void 0&&(r.colorSpace=n),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let c=this.cache.get(o);c||(c=new A.PointsMaterial,A.Material.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,c.sizeAttenuation=!1,this.cache.add(o,c)),s=c}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let c=this.cache.get(o);c||(c=new A.LineBasicMaterial,A.Material.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,this.cache.add(o,c)),s=c}if(n||i||r){let o="ClonedMaterial:"+s.uuid+":";n&&(o+="derivative-tangents:"),i&&(o+="vertex-colors:"),r&&(o+="flat-shading:");let c=this.cache.get(o);c||(c=s.clone(),i&&(c.vertexColors=!0),r&&(c.flatShading=!0),n&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(o,c),this.associations.set(c,this.associations.get(s))),s=c}e.material=s}getMaterialType(){return A.MeshStandardMaterial}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let r;const o={},c=i.extensions||{},l=[];if(c[W.KHR_MATERIALS_UNLIT]){const u=n[W.KHR_MATERIALS_UNLIT];r=u.getMaterialType(),l.push(u.extendParams(o,i,t))}else{const u=i.pbrMetallicRoughness||{};if(o.color=new A.Color(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],A.LinearSRGBColorSpace),o.opacity=d[3]}u.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",u.baseColorTexture,A.SRGBColorSpace)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}i.doubleSided===!0&&(o.side=A.DoubleSide);const h=i.alphaMode||Js.OPAQUE;if(h===Js.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,h===Js.MASK&&(o.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==A.MeshBasicMaterial&&(l.push(t.assignTexture(o,"normalMap",i.normalTexture)),o.normalScale=new A.Vector2(1,1),i.normalTexture.scale!==void 0)){const u=i.normalTexture.scale;o.normalScale.set(u,u)}if(i.occlusionTexture!==void 0&&r!==A.MeshBasicMaterial&&(l.push(t.assignTexture(o,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==A.MeshBasicMaterial){const u=i.emissiveFactor;o.emissive=new A.Color().setRGB(u[0],u[1],u[2],A.LinearSRGBColorSpace)}return i.emissiveTexture!==void 0&&r!==A.MeshBasicMaterial&&l.push(t.assignTexture(o,"emissiveMap",i.emissiveTexture,A.SRGBColorSpace)),Promise.all(l).then(function(){const u=new r(o);return i.name&&(u.name=i.name),Ge(u,i),t.associations.set(u,{materials:e}),i.extensions&&et(n,u,i),u})}createUniqueName(e){const t=A.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(o){return s[W.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(c){return Di(c,o,t)})}const r=[];for(let o=0,c=e.length;o<c;o++){const l=e[o],h=Zo(l),u=n[h];if(u)r.push(u.promise);else{let d;l.extensions&&l.extensions[W.KHR_DRACO_MESH_COMPRESSION]?d=i(l):d=Di(new A.BufferGeometry,l,t),n[h]={primitive:l,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],r=i.primitives,o=[];for(let c=0,l=r.length;c<l;c++){const h=r[c].material===void 0?Jo(this.cache):this.getDependency("material",r[c].material);o.push(h)}return o.push(t.loadGeometries(r)),Promise.all(o).then(function(c){const l=c.slice(0,c.length-1),h=c[c.length-1],u=[];for(let f=0,p=h.length;f<p;f++){const g=h[f],m=r[f];let I;const b=l[f];if(m.mode===me.TRIANGLES||m.mode===me.TRIANGLE_STRIP||m.mode===me.TRIANGLE_FAN||m.mode===void 0)I=i.isSkinnedMesh===!0?new A.SkinnedMesh(g,b):new A.Mesh(g,b),I.isSkinnedMesh===!0&&I.normalizeSkinWeights(),m.mode===me.TRIANGLE_STRIP?I.geometry=_i(I.geometry,A.TriangleStripDrawMode):m.mode===me.TRIANGLE_FAN&&(I.geometry=_i(I.geometry,A.TriangleFanDrawMode));else if(m.mode===me.LINES)I=new A.LineSegments(g,b);else if(m.mode===me.LINE_STRIP)I=new A.Line(g,b);else if(m.mode===me.LINE_LOOP)I=new A.LineLoop(g,b);else if(m.mode===me.POINTS)I=new A.Points(g,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(I.geometry.morphAttributes).length>0&&Xo(I,i),I.name=t.createUniqueName(i.name||"mesh_"+e),Ge(I,i),m.extensions&&et(n,I,m),t.assignFinalMaterial(I),u.push(I)}for(let f=0,p=u.length;f<p;f++)t.associations.set(u[f],{meshes:e,primitives:f});if(u.length===1)return i.extensions&&et(n,u[0],i),u[0];const d=new A.Group;i.extensions&&et(n,d,i),t.associations.set(d,{meshes:e});for(let f=0,p=u.length;f<p;f++)d.add(u[f]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new A.PerspectiveCamera(A.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new A.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Ge(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),r=n,o=[],c=[];for(let l=0,h=r.length;l<h;l++){const u=r[l];if(u){o.push(u);const d=new A.Matrix4;i!==null&&d.fromArray(i.array,l*16),c.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new A.Skeleton(o,c)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],i=n.name?n.name:"animation_"+e,r=[],o=[],c=[],l=[],h=[];for(let u=0,d=n.channels.length;u<d;u++){const f=n.channels[u],p=n.samplers[f.sampler],g=f.target,m=g.node,I=n.parameters!==void 0?n.parameters[p.input]:p.input,b=n.parameters!==void 0?n.parameters[p.output]:p.output;g.node!==void 0&&(r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",I)),c.push(this.getDependency("accessor",b)),l.push(p),h.push(g))}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(c),Promise.all(l),Promise.all(h)]).then(function(u){const d=u[0],f=u[1],p=u[2],g=u[3],m=u[4],I=[];for(let b=0,C=d.length;b<C;b++){const y=d[b],B=f[b],v=p[b],_=g[b],x=m[b];if(y===void 0)continue;y.updateMatrix&&y.updateMatrix();const w=s._createAnimationTracks(y,B,v,_,x);if(w)for(let S=0;S<w.length;S++)I.push(w[S])}return new A.AnimationClip(i,void 0,I)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const r=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&r.traverse(function(o){if(o.isMesh)for(let c=0,l=n.weights.length;c<l;c++)o.morphTargetInfluences[c]=n.weights[c]}),r})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],i=s._loadNodeShallow(e),r=[],o=n.children||[];for(let l=0,h=o.length;l<h;l++)r.push(s.getDependency("node",o[l]));const c=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([i,Promise.all(r),c]).then(function(l){const h=l[0],u=l[1],d=l[2];d!==null&&h.traverse(function(f){f.isSkinnedMesh&&f.bind(d,Ho)});for(let f=0,p=u.length;f<p;f++)h.add(u[f]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],r=i.name?n.createUniqueName(i.name):"",o=[],c=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return c&&o.push(c),i.camera!==void 0&&o.push(n.getDependency("camera",i.camera).then(function(l){return n._getNodeRef(n.cameraCache,i.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),this.nodeCache[e]=Promise.all(o).then(function(l){let h;if(i.isBone===!0?h=new A.Bone:l.length>1?h=new A.Group:l.length===1?h=l[0]:h=new A.Object3D,h!==l[0])for(let u=0,d=l.length;u<d;u++)h.add(l[u]);if(i.name&&(h.userData.name=i.name,h.name=r),Ge(h,i),i.extensions&&et(s,h,i),i.matrix!==void 0){const u=new A.Matrix4;u.fromArray(i.matrix),h.applyMatrix4(u)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);if(!n.associations.has(h))n.associations.set(h,{});else if(i.mesh!==void 0&&n.meshCache.refs[i.mesh]>1){const u=n.associations.get(h);n.associations.set(h,{...u})}return n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new A.Group;s.name&&(i.name=n.createUniqueName(s.name)),Ge(i,s),s.extensions&&et(t,i,s);const r=s.nodes||[],o=[];for(let c=0,l=r.length;c<l;c++)o.push(n.getDependency("node",r[c]));return Promise.all(o).then(function(c){for(let h=0,u=c.length;h<u;h++)i.add(c[h]);const l=h=>{const u=new Map;for(const[d,f]of n.associations)(d instanceof A.Material||d instanceof A.Texture)&&u.set(d,f);return h.traverse(d=>{const f=n.associations.get(d);f!=null&&u.set(d,f)}),u};return n.associations=l(i),i})}_createAnimationTracks(e,t,s,n,i){const r=[],o=e.name?e.name:e.uuid,c=[];je[i.path]===je.weights?e.traverse(function(d){d.morphTargetInfluences&&c.push(d.name?d.name:d.uuid)}):c.push(o);let l;switch(je[i.path]){case je.weights:l=A.NumberKeyframeTrack;break;case je.rotation:l=A.QuaternionKeyframeTrack;break;case je.translation:case je.scale:l=A.VectorKeyframeTrack;break;default:switch(s.itemSize){case 1:l=A.NumberKeyframeTrack;break;case 2:case 3:default:l=A.VectorKeyframeTrack;break}break}const h=n.interpolation!==void 0?Ko[n.interpolation]:A.InterpolateLinear,u=this._getArrayFromAccessor(s);for(let d=0,f=c.length;d<f;d++){const p=new l(c[d]+"."+je[i.path],t.array,u,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(p),r.push(p)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Xs(t.constructor),n=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)n[i]=t[i]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof A.QuaternionKeyframeTrack?Wo:Si;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}};function tc(a,e,t){const s=e.attributes,n=new A.Box3;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(n.set(new A.Vector3(c[0],c[1],c[2]),new A.Vector3(l[0],l[1],l[2])),o.normalized){const h=Xs(dt[o.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new A.Vector3,c=new A.Vector3;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],f=d.min,p=d.max;if(f!==void 0&&p!==void 0){if(c.setX(Math.max(Math.abs(f[0]),Math.abs(p[0]))),c.setY(Math.max(Math.abs(f[1]),Math.abs(p[1]))),c.setZ(Math.max(Math.abs(f[2]),Math.abs(p[2]))),d.normalized){const g=Xs(dt[d.componentType]);c.multiplyScalar(g)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}a.boundingBox=n;const r=new A.Sphere;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,a.boundingSphere=r}function Di(a,e,t){const s=e.attributes,n=[];function i(r,o){return t.getDependency("accessor",r).then(function(c){a.setAttribute(o,c)})}for(const r in s){const o=Ks[r]||r.toLowerCase();o in a.attributes||n.push(i(s[r],o))}if(e.indices!==void 0&&!a.index){const r=t.getDependency("accessor",e.indices).then(function(o){a.setIndex(o)});n.push(r)}return A.ColorManagement.workingColorSpace!==A.LinearSRGBColorSpace&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${A.ColorManagement.workingColorSpace}" not supported.`),Ge(a,e),tc(a,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Yo(a,e.targets,t):a})}class Li extends mo{constructor(e=A.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new A.Matrix4}parse(e){const t=super.parse(e),s=t.glbBytes.slice().buffer;return new Promise((n,i)=>{const r=this.manager,o=this.fetchOptions,c=r.getHandler("path.gltf")||new Zt(r);o.credentials==="include"&&o.mode==="cors"&&c.setCrossOrigin("use-credentials"),"credentials"in o&&c.setWithCredentials(o.credentials==="include"),o.headers&&c.setRequestHeader(o.headers);let l=this.workingPath;!/[\\/]$/.test(l)&&l.length&&(l+="/");const h=this.adjustmentTransform;c.parse(s,l,u=>{const{batchTable:d,featureTable:f}=t,{scene:p}=u,g=f.getData("RTC_CENTER",1,"FLOAT","VEC3");g&&(p.position.x+=g[0],p.position.y+=g[1],p.position.z+=g[2]),u.scene.updateMatrix(),u.scene.matrix.multiply(h),u.scene.matrix.decompose(u.scene.position,u.scene.quaternion,u.scene.scale),u.batchTable=d,u.featureTable=f,p.batchTable=d,p.featureTable=f,n(u)},i)})}}function sc(a){const e=a>>11,t=a>>5&63,s=a&31,n=Math.round(e/31*255),i=Math.round(t/63*255),r=Math.round(s/31*255);return[n,i,r]}const _t=new A.Vector2;function nc(a,e,t=new A.Vector3){_t.set(a,e).divideScalar(256).multiplyScalar(2).subScalar(1),t.set(_t.x,_t.y,1-Math.abs(_t.x)-Math.abs(_t.y));const s=A.MathUtils.clamp(-t.z,0,1);return t.x>=0?t.setX(t.x-s):t.setX(t.x+s),t.y>=0?t.setY(t.y-s):t.setY(t.y+s),t.normalize(),t}const Ei={RGB:"color",POSITION:"position"};class Fi extends Co{constructor(e=A.DefaultLoadingManager){super(),this.manager=e}parse(e){return super.parse(e).then(async t=>{const{featureTable:s,batchTable:n}=t,i=new A.PointsMaterial,r=s.header.extensions,o=new A.Vector3;let c;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:u,byteLength:d,properties:f}=r["3DTILES_draco_point_compression"],p=this.manager.getHandler("draco.drc");if(p==null)throw new Error("PNTSLoader: dracoLoader not available.");const g={};for(const b in f)if(b in Ei&&b in f){const C=Ei[b];g[C]=f[b]}const m={attributeIDs:g,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},I=s.getBuffer(u,d);c=await p.decodeGeometry(I,m),c.attributes.color&&(i.vertexColors=!0)}else{const u=s.getData("POINTS_LENGTH"),d=s.getData("POSITION",u,"FLOAT","VEC3"),f=s.getData("NORMAL",u,"FLOAT","VEC3"),p=s.getData("NORMAL",u,"UNSIGNED_BYTE","VEC2"),g=s.getData("RGB",u,"UNSIGNED_BYTE","VEC3"),m=s.getData("RGBA",u,"UNSIGNED_BYTE","VEC4"),I=s.getData("RGB565",u,"UNSIGNED_SHORT","SCALAR"),b=s.getData("CONSTANT_RGBA",u,"UNSIGNED_BYTE","VEC4"),C=s.getData("POSITION_QUANTIZED",u,"UNSIGNED_SHORT","VEC3"),y=s.getData("QUANTIZED_VOLUME_SCALE",u,"FLOAT","VEC3"),B=s.getData("QUANTIZED_VOLUME_OFFSET",u,"FLOAT","VEC3");if(c=new A.BufferGeometry,C){const v=new Float32Array(u*3);for(let _=0;_<u;_++)for(let x=0;x<3;x++){const w=3*_+x;v[w]=C[w]/65535*y[x]}o.x=B[0],o.y=B[1],o.z=B[2],c.setAttribute("position",new A.BufferAttribute(v,3,!1))}else c.setAttribute("position",new A.BufferAttribute(d,3,!1));if(f!==null)c.setAttribute("normal",new A.BufferAttribute(f,3,!1));else if(p!==null){const v=new Float32Array(u*3),_=new A.Vector3;for(let x=0;x<u;x++){const w=p[x*2],S=p[x*2+1],Q=nc(w,S,_);v[x*3]=Q.x,v[x*3+1]=Q.y,v[x*3+2]=Q.z}c.setAttribute("normal",new A.BufferAttribute(v,3,!1))}if(m!==null)c.setAttribute("color",new A.BufferAttribute(m,4,!0)),i.vertexColors=!0,i.transparent=!0,i.depthWrite=!1;else if(g!==null)c.setAttribute("color",new A.BufferAttribute(g,3,!0)),i.vertexColors=!0;else if(I!==null){const v=new Uint8Array(u*3);for(let _=0;_<u;_++){const x=sc(I[_]);for(let w=0;w<3;w++){const S=3*_+w;v[S]=x[w]}}c.setAttribute("color",new A.BufferAttribute(v,3,!0)),i.vertexColors=!0}else if(b!==null){const v=new A.Color(b[0],b[1],b[2]);i.color=v;const _=b[3]/255;_<1&&(i.opacity=_,i.transparent=!0,i.depthWrite=!1)}}const l=new A.Points(c,i);l.position.copy(o),t.scene=l,t.scene.featureTable=s,t.scene.batchTable=n;const h=s.getData("RTC_CENTER",1,"FLOAT","VEC3");return h&&(t.scene.position.x+=h[0],t.scene.position.y+=h[1],t.scene.position.z+=h[2]),t})}}new A.Spherical,new A.Vector3;function ic(a){const{x:e,y:t,z:s}=a;a.x=s,a.y=e,a.z=t}function rc(a){return-a+Math.PI/2}const Ti=new A.Spherical,qe=new A.Vector3,be=new A.Vector3,Zs=new A.Vector3,We=new A.Matrix4,we=new A.Matrix4,ki=new A.Matrix4,$s=new A.Sphere,pe=new A.Euler,Gi=new A.Vector3,Pi=new A.Vector3,Ui=new A.Vector3,tt=new A.Vector3,Ni=new A.Ray,ac=1e-12,oc=.1,$t=0,Oi=1,Ht=2;class Ri{constructor(e=1,t=1,s=1){this.name="",this.radius=new A.Vector3(e,t,s)}intersectRay(e,t){return We.makeScale(...this.radius).invert(),$s.center.set(0,0,0),$s.radius=1,Ni.copy(e).applyMatrix4(We),Ni.intersectSphere($s,t)?(We.makeScale(...this.radius),t.applyMatrix4(We),t):null}getEastNorthUpFrame(e,t,s,n){return s.isMatrix4&&(n=s,s=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(e,t,Gi,Pi,Ui),this.getCartographicToPosition(e,t,s,tt),n.makeBasis(Gi,Pi,Ui).setPosition(tt)}getOrientedEastNorthUpFrame(e,t,s,n,i,r,o){return this.getObjectFrame(e,t,s,n,i,r,o,$t)}getObjectFrame(e,t,s,n,i,r,o,c=Ht){return this.getEastNorthUpFrame(e,t,s,We),pe.set(i,r,-n,"ZXY"),o.makeRotationFromEuler(pe).premultiply(We),c===Oi?(pe.set(Math.PI/2,0,0,"XYZ"),we.makeRotationFromEuler(pe),o.multiply(we)):c===Ht&&(pe.set(-Math.PI/2,0,Math.PI,"XYZ"),we.makeRotationFromEuler(pe),o.multiply(we)),o}getCartographicFromObjectFrame(e,t,s=Ht){return s===Oi?(pe.set(-Math.PI/2,0,0,"XYZ"),we.makeRotationFromEuler(pe).premultiply(e)):s===Ht?(pe.set(-Math.PI/2,0,Math.PI,"XYZ"),we.makeRotationFromEuler(pe).premultiply(e)):we.copy(e),tt.setFromMatrixPosition(we),this.getPositionToCartographic(tt,t),this.getEastNorthUpFrame(t.lat,t.lon,0,We).invert(),we.premultiply(We),pe.setFromRotationMatrix(we,"ZXY"),t.azimuth=-pe.z,t.elevation=pe.x,t.roll=pe.y,t}getEastNorthUpAxes(e,t,s,n,i,r=tt){this.getCartographicToPosition(e,t,0,r),this.getCartographicToNormal(e,t,i),s.set(-r.y,r.x,0).normalize(),n.crossVectors(i,s).normalize()}getAzElRollFromRotationMatrix(e,t,s,n,i=$t){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(e,t,0,tt),ki.copy(s).setPosition(tt),this.getCartographicFromObjectFrame(ki,n,i),delete n.height,delete n.lat,delete n.lon,n}getRotationMatrixFromAzElRoll(e,t,s,n,i,r,o=$t){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,0,s,n,i,r,o),r.setPosition(0,0,0),r}getFrame(e,t,s,n,i,r,o,c=$t){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,r,s,n,i,o,c)}getCartographicToPosition(e,t,s,n){this.getCartographicToNormal(e,t,qe);const i=this.radius;be.copy(qe),be.x*=i.x**2,be.y*=i.y**2,be.z*=i.z**2;const r=Math.sqrt(qe.dot(be));return be.divideScalar(r),n.copy(be).addScaledVector(qe,s)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,be),this.getPositionToNormal(e,qe);const s=Zs.subVectors(e,be);return t.lon=Math.atan2(qe.y,qe.x),t.lat=Math.asin(qe.z),t.height=Math.sign(s.dot(e))*s.length(),t}getCartographicToNormal(e,t,s){return Ti.set(1,rc(e),t),s.setFromSpherical(Ti).normalize(),ic(s),s}getPositionToNormal(e,t){const s=this.radius;return t.copy(e),t.x/=s.x**2,t.y/=s.y**2,t.z/=s.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const s=this.radius,n=1/s.x**2,i=1/s.y**2,r=1/s.z**2,o=e.x*e.x*n,c=e.y*e.y*i,l=e.z*e.z*r,h=o+c+l,u=Math.sqrt(1/h),d=be.copy(e).multiplyScalar(u);if(h<oc)return isFinite(u)?t.copy(d):null;const f=Zs.set(d.x*n*2,d.y*i*2,d.z*r*2);let p=(1-u)*e.length()/(.5*f.length()),g=0,m,I,b,C,y,B,v,_,x,w,S;do{p-=g,b=1/(1+p*n),C=1/(1+p*i),y=1/(1+p*r),B=b*b,v=C*C,_=y*y,x=B*b,w=v*C,S=_*y,m=o*B+c*v+l*_-1,I=o*x*n+c*w*i+l*S*r;const Q=-2*I;g=m/Q}while(Math.abs(m)>ac);return t.set(e.x*b,e.y*C,e.z*y)}calculateHorizonDistance(e,t){const s=this.calculateEffectiveRadius(e);return Math.sqrt(2*s*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,n=1-this.radius.z**2/t**2,i=e*A.MathUtils.DEG2RAD,r=Math.sin(i)**2;return t/Math.sqrt(1-n*r)}getPositionElevation(e){this.getPositionToSurfacePoint(e,be);const t=Zs.subVectors(e,be);return Math.sign(t.dot(e))*t.length()}copy(e){return this.radius.copy(e.radius),this}clone(){return new this.constructor().copy(this)}}const es=new Ri(fi,fi,co);es.name="WGS84 Earth";const Vi=new A.Vector3,Hs=new A.Vector3,en=new A.Vector3,tn=new A.Vector3,sn=new A.Quaternion,ts=new A.Vector3,ss=new A.Matrix4,zi=new A.Matrix4,ji=new A.Vector3,qi=new A.Matrix4,nn=new A.Quaternion,rn={};class Wi extends bo{constructor(e=A.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new A.Matrix4,this.ellipsoid=es.clone()}resolveExternalURL(e){return this.manager.resolveURL(super.resolveExternalURL(e))}parse(e){return super.parse(e).then(t=>{const{featureTable:s,batchTable:n}=t,i=t.glbBytes.slice().buffer;return new Promise((r,o)=>{const c=this.fetchOptions,l=this.manager,h=l.getHandler("path.gltf")||new Zt(l);c.credentials==="include"&&c.mode==="cors"&&h.setCrossOrigin("use-credentials"),"credentials"in c&&h.setWithCredentials(c.credentials==="include"),c.headers&&h.setRequestHeader(c.headers);let u=t.gltfWorkingPath??this.workingPath;/[\\/]$/.test(u)||(u+="/");const d=this.adjustmentTransform;h.parse(i,u,f=>{const p=s.getData("INSTANCES_LENGTH"),g=s.getData("POSITION",p,"FLOAT","VEC3"),m=s.getData("NORMAL_UP",p,"FLOAT","VEC3"),I=s.getData("NORMAL_RIGHT",p,"FLOAT","VEC3"),b=s.getData("SCALE_NON_UNIFORM",p,"FLOAT","VEC3"),C=s.getData("SCALE",p,"FLOAT","SCALAR"),y=s.getData("RTC_CENTER",1,"FLOAT","VEC3"),B=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(w=>{w in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${w}" detected.`)});const v=new A.Vector3;for(let w=0;w<p;w++)v.x+=g[w*3+0]/p,v.y+=g[w*3+1]/p,v.z+=g[w*3+2]/p;const _=[],x=[];f.scene.updateMatrixWorld(),f.scene.traverse(w=>{if(w.isMesh){x.push(w);const{geometry:S,material:Q}=w,E=new A.InstancedMesh(S,Q,p);E.position.copy(v),y&&(E.position.x+=y[0],E.position.y+=y[1],E.position.z+=y[2]),_.push(E)}});for(let w=0;w<p;w++){tn.set(g[w*3+0]-v.x,g[w*3+1]-v.y,g[w*3+2]-v.z),sn.identity(),m&&(Hs.set(m[w*3+0],m[w*3+1],m[w*3+2]),en.set(I[w*3+0],I[w*3+1],I[w*3+2]),Vi.crossVectors(en,Hs).normalize(),ss.makeBasis(en,Hs,Vi),sn.setFromRotationMatrix(ss)),ts.set(1,1,1),b&&ts.set(b[w*3+0],b[w*3+1],b[w*3+2]),C&&ts.multiplyScalar(C[w]);for(let S=0,Q=_.length;S<Q;S++){const E=_[S];nn.copy(sn),B&&(E.updateMatrixWorld(),ji.copy(tn).applyMatrix4(E.matrixWorld),this.ellipsoid.getPositionToCartographic(ji,rn),this.ellipsoid.getEastNorthUpFrame(rn.lat,rn.lon,qi),nn.setFromRotationMatrix(qi)),ss.compose(tn,nn,ts).multiply(d);const N=x[S];zi.multiplyMatrices(ss,N.matrixWorld),E.setMatrixAt(w,zi)}}f.scene.clear(),f.scene.add(..._),f.batchTable=n,f.featureTable=s,f.scene.batchTable=n,f.scene.featureTable=s,r(f)},o)})})}}class cc extends Io{constructor(e=A.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new A.Matrix4,this.ellipsoid=es.clone()}parse(e){const t=super.parse(e),{manager:s,ellipsoid:n,adjustmentTransform:i}=this,r=[];for(const o in t.tiles){const{type:c,buffer:l}=t.tiles[o];switch(c){case"b3dm":{const h=l.slice(),u=new Li(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}case"pnts":{const h=l.slice(),u=new Fi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions;const d=u.parse(h.buffer);r.push(d);break}case"i3dm":{const h=l.slice(),u=new Wi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.ellipsoid.copy(n),u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}}}return Promise.all(r).then(o=>{const c=new A.Group;return o.forEach(l=>{c.add(l.scene)}),{tiles:o,scene:c}})}}const wt=new A.Matrix4;class Ac extends A.Group{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.matrixWorldInverse=new A.Matrix4}raycast(e,t){return this.tilesRenderer.optimizeRaycast?(this.tilesRenderer.raycast(e,t),!1):!0}updateMatrixWorld(e){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||e){this.parent===null?wt.copy(this.matrix):wt.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=wt.elements,s=this.matrixWorld.elements;let n=!1;for(let i=0;i<16;i++){const r=t[i],o=s[i];if(Math.abs(r-o)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(wt),this.matrixWorldInverse.copy(wt).invert();const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].updateMatrixWorld()}}}updateWorldMatrix(e,t){this.parent&&e&&this.parent.updateWorldMatrix(e,!1),this.updateMatrixWorld(!0)}}const Ki=new A.Ray,an=new A.Vector3,ns=[];function Ji(a,e){return a.distance-e.distance}function Yi(a,e,t,s){const{scene:n}=a.cached;t.invokeOnePlugin(r=>r.raycastTile&&r.raycastTile(a,n,e,s))||e.intersectObject(n,!0,s)}function lc(a,e,t){Yi(a,e,t,ns),ns.sort(Ji);const s=ns[0]||null;return ns.length=0,s}function Xi(a){return"__used"in a}function Zi(a,e,t,s=null){const{group:n,activeTiles:i}=a;s===null&&(s=Ki,s.copy(t.ray).applyMatrix4(n.matrixWorldInverse));const r=[],o=e.children;for(let h=0,u=o.length;h<u;h++){const d=o[h];if(!Xi(d)||!d.__used)continue;d.cached.boundingVolume.intersectRay(s,an)!==null&&(an.applyMatrix4(n.matrixWorld),r.push({distance:an.distanceToSquared(t.ray.origin),tile:d}))}r.sort(Ji);let c=null,l=1/0;if(i.has(e)){const h=lc(e,t,a);h&&(c=h,l=h.distance*h.distance)}for(let h=0,u=r.length;h<u;h++){const d=r[h],f=d.distance,p=d.tile;if(f>l)break;const g=Zi(a,p,t,s);if(g){const m=g.distance*g.distance;m<l&&(c=g,l=m)}}return c}function $i(a,e,t,s,n=null){if(!Xi(e))return;const{group:i,activeTiles:r}=a,{boundingVolume:o}=e.cached;if(n===null&&(n=Ki,n.copy(t.ray).applyMatrix4(i.matrixWorldInverse)),!e.__used||!o.intersectsRay(n))return;r.has(e)&&Yi(e,t,a,s);const c=e.children;for(let l=0,h=c.length;l<h;l++)$i(a,c[l],t,s,n)}const is=new A.Vector3,rs=new A.Vector3,ge=new A.Vector3,as=new A.Ray;class Hi{constructor(e=new A.Box3,t=new A.Matrix4){this.box=e.clone(),this.transform=t.clone(),this.inverseTransform=new A.Matrix4,this.points=new Array(8).fill().map(()=>new A.Vector3),this.planes=new Array(6).fill().map(()=>new A.Plane)}copy(e){return this.box.copy(e.box),this.transform.copy(e.transform),this.update(),this}clone(){return new this.constructor().copy(this)}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,ge).distanceTo(e)}containsPoint(e){return ge.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(ge)}intersectsRay(e){return as.copy(e).applyMatrix4(this.inverseTransform),as.intersectsBox(this.box)}intersectRay(e,t){return as.copy(e).applyMatrix4(this.inverseTransform),as.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:s,box:n}=this;t.copy(s).invert();const{min:i,max:r}=n;let o=0;for(let c=-1;c<=1;c+=2)for(let l=-1;l<=1;l+=2)for(let h=-1;h<=1;h+=2)e[o].set(c<0?i.x:r.x,l<0?i.y:r.y,h<0?i.z:r.z).applyMatrix4(s),o++;this.updatePlanes()}updatePlanes(){is.copy(this.box.min).applyMatrix4(this.transform),rs.copy(this.box.max).applyMatrix4(this.transform),ge.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(ge,is),this.planes[1].setFromNormalAndCoplanarPoint(ge,rs).negate(),ge.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(ge,is),this.planes[3].setFromNormalAndCoplanarPoint(ge,rs).negate(),ge.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(ge,is),this.planes[5].setFromNormalAndCoplanarPoint(ge,rs).negate()}intersectsSphere(e){return this.clampPoint(e.center,ge),ge.distanceToSquared(e.center)<=e.radius*e.radius}intersectsFrustum(e){return this._intersectsPlaneShape(e.planes,e.points)}intersectsOBB(e){return this._intersectsPlaneShape(e.planes,e.points)}_intersectsPlaneShape(e,t){const s=this.points,n=this.planes;for(let i=0;i<6;i++){const r=e[i];let o=-1/0;for(let c=0;c<8;c++){const l=s[c],h=r.distanceToPoint(l);o=o<h?h:o}if(o<0)return!1}for(let i=0;i<6;i++){const r=n[i];let o=-1/0;for(let c=0;c<8;c++){const l=t[c],h=r.distanceToPoint(l);o=o<h?h:o}if(o<0)return!1}return!0}}const Ke=Math.PI,os=Ke/2,vt=new A.Vector3,ft=new A.Vector3,pt=new A.Vector3,er=new A.Matrix4;let St=0;const on=[];function hc(a=!1){return a?(on[St]||(on[St]=new A.Vector3),St++,on[St-1]):new A.Vector3}function tr(){St=0}class sr extends Ri{constructor(e,t,s,n=-os,i=os,r=0,o=2*Ke,c=0,l=0){super(e,t,s),this.latStart=n,this.latEnd=i,this.lonStart=r,this.lonEnd=o,this.heightStart=c,this.heightEnd=l}_getPoints(e=!1){const{latStart:t,latEnd:s,lonStart:n,lonEnd:i,heightStart:r,heightEnd:o}=this,c=A.MathUtils.mapLinear(.5,0,1,t,s),l=A.MathUtils.mapLinear(.5,0,1,n,i),h=Math.floor(n/os)*os,u=[[-Ke/2,0],[Ke/2,0],[0,h],[0,h+Ke/2],[0,h+Ke],[0,h+3*Ke/2],[t,i],[s,i],[t,n],[s,n],[0,n],[0,i],[c,l],[t,l],[s,l],[c,n],[c,i]],d=[],f=u.length;for(let p=0;p<=1;p++){const g=A.MathUtils.mapLinear(p,0,1,r,o);for(let m=0,I=f;m<I;m++){const[b,C]=u[m];if(b>=t&&b<=s&&C>=n&&C<=i){const y=hc(e);d.push(y),this.getCartographicToPosition(b,C,g,y)}}}return d}getBoundingBox(e,t){tr();const{latStart:s,latEnd:n,lonStart:i,lonEnd:r}=this;if(n-s<Ke/2){const l=A.MathUtils.mapLinear(.5,0,1,s,n),h=A.MathUtils.mapLinear(.5,0,1,i,r);this.getCartographicToNormal(l,h,pt),ft.set(0,0,1),vt.crossVectors(ft,pt),ft.crossVectors(vt,pt),t.makeBasis(vt,ft,pt)}else vt.set(1,0,0),ft.set(0,1,0),pt.set(0,0,1),t.makeBasis(vt,ft,pt);er.copy(t).invert();const c=this._getPoints(!0);for(let l=0,h=c.length;l<h;l++)c[l].applyMatrix4(er);e.makeEmpty(),e.setFromPoints(c)}getBoundingSphere(e,t){tr();const s=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(s,t)}}const Pe=new A.Vector3,Ue=new A.Vector3,Ne=new A.Vector3,nr=new A.Vector3,ir=new A.Vector3;class uc{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,s=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t)||s&&!s.intersectsRay(e))}intersectRay(e,t=null){const s=this.sphere,n=this.obb||this.regionObb;let i=-1/0,r=-1/0;s&&e.intersectSphere(s,nr)&&(i=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(nr)),n&&n.intersectRay(e,ir)&&(r=n.containsPoint(e.origin)?0:e.origin.distanceToSquared(ir));const o=Math.max(i,r);return o===-1/0?null:(e.at(Math.sqrt(o),t),t)}distanceToPoint(e){const t=this.sphere,s=this.obb||this.regionObb;let n=-1/0,i=-1/0;return t&&(n=Math.max(t.distanceToPoint(e),0)),s&&(i=s.distanceToPoint(e)),n>i?n:i}intersectsFrustum(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsFrustum(e)?!1:!!(s||t)}intersectsSphere(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!s.intersectsSphere(e)||t&&!t.intersectsSphere(e)?!1:!!(s||t)}intersectsOBB(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsOBB(e)?!1:!!(s||t)}getOBB(e,t){const s=this.obb||this.regionObb;s?(e.copy(s.box),t.copy(s.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const s=new Hi;Pe.set(e[3],e[4],e[5]),Ue.set(e[6],e[7],e[8]),Ne.set(e[9],e[10],e[11]);const n=Pe.length(),i=Ue.length(),r=Ne.length();Pe.normalize(),Ue.normalize(),Ne.normalize(),n===0&&Pe.crossVectors(Ue,Ne),i===0&&Ue.crossVectors(Pe,Ne),r===0&&Ne.crossVectors(Pe,Ue),s.transform.set(Pe.x,Ue.x,Ne.x,e[0],Pe.y,Ue.y,Ne.y,e[1],Pe.z,Ue.z,Ne.z,e[2],0,0,0,1).premultiply(t),s.box.min.set(-n,-i,-r),s.box.max.set(n,i,r),s.update(),this.obb=s}setSphereData(e,t,s,n,i){const r=new A.Sphere;r.center.set(e,t,s),r.radius=n,r.applyMatrix4(i),this.sphere=r}setRegionData(e,t,s,n,i,r,o){const c=new sr(...e.radius,s,i,t,n,r,o),l=new Hi;c.getBoundingBox(l.box,l.transform),l.update(),this.region=c,this.regionObb=l}}const dc=new A.Matrix3;function fc(a,e,t,s){const n=dc.set(a.normal.x,a.normal.y,a.normal.z,e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z);return s.set(-a.constant,-e.constant,-t.constant),s.applyMatrix3(n.invert()),s}class pc extends A.Frustum{constructor(){super(),this.points=Array(8).fill().map(()=>new A.Vector3)}setFromProjectionMatrix(e,t){return super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((n,i)=>{fc(n[0],n[1],n[2],t[i])})}}function gc(a){const{TextureUtils:e}=Y;if(!e||!a)return 0;const{format:t,type:s,image:n}=a,{width:i,height:r}=n;let o=e.getByteLength(i,r,t,s);return o*=a.generateMipmaps?4/3:1,o}function mc(a){const e=new Set;let t=0;return a.traverse(s=>{if(s.geometry&&!e.has(s.geometry)&&(t+=yo(s.geometry),e.add(s.geometry)),s.material){const n=s.material;for(const i in n){const r=n[i];r&&r.isTexture&&!e.has(r)&&(t+=gc(r),e.add(r))}}}),t}const rr=new A.Matrix4,ar=new A.Euler,or=Symbol("INITIAL_FRUSTUM_CULLED"),cs=new A.Matrix4,Qt=new A.Vector3,cn=new A.Vector2,As={inView:!1,error:1/0},bc=new A.Vector3(1,0,0),Cc=new A.Vector3(0,1,0);function cr(a,e){a.traverse(t=>{t.frustumCulled=t[or]&&e})}class Ic extends fo{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{cr(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new Ac(this),this.ellipsoid=es.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new A.Matrix4,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const t=new A.LoadingManager;t.setURLModifier(s=>this.preprocessURL?this.preprocessURL(s):s),this.manager=t,this._listeners={}}addEventListener(...e){A.EventDispatcher.prototype.addEventListener.call(this,...e)}hasEventListener(...e){A.EventDispatcher.prototype.hasEventListener.call(this,...e)}removeEventListener(...e){A.EventDispatcher.prototype.removeEventListener.call(this,...e)}dispatchEvent(...e){A.EventDispatcher.prototype.dispatchEvent.call(this,...e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getAABB(e),!0):!1}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return s?(s.getOBB(e,t),!0):!1}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getSphere(e),!0):!1}forEachLoadedModel(e){this.traverse(t=>{const s=t.cached&&t.cached.scene;s&&e(s,t)},null,!1)}raycast(e,t){if(this.root)if(e.firstHitOnly){const s=Zi(this,this.root,e);s&&t.push(s)}else $i(this,this.root,e,t)}hasCamera(e){return this.cameraMap.has(e)}setCamera(e){const t=this.cameras,s=this.cameraMap;return s.has(e)?!1:(s.set(e,new A.Vector2),t.push(e),this.dispatchEvent({type:"add-camera",camera:e}),!0)}setResolution(e,t,s){const n=this.cameraMap;if(!n.has(e))return!1;const i=t.isVector2?t.x:t,r=t.isVector2?t.y:s,o=n.get(e);return(o.width!==i||o.height!==r)&&(o.set(i,r),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(e,t){return t.getSize(cn),this.setResolution(e,cn.x,cn.y)}deleteCamera(e){const t=this.cameras,s=this.cameraMap;if(s.has(e)){const n=t.indexOf(e);return t.splice(n,1),s.delete(e),this.dispatchEvent({type:"delete-camera",camera:e}),!0}return!1}loadRootTileSet(...e){return super.loadRootTileSet(...e).then(t=>{const{asset:s,extensions:n={}}=t;switch((s&&s.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(Cc,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(bc,Math.PI/2);break}if("3DTILES_ellipsoid"in n){const r=n["3DTILES_ellipsoid"],{ellipsoid:o}=this;o.name=r.body,r.radii?o.radius.set(...r.radii):o.radius.set(1,1,1)}return t})}update(){let e=null;if(this.invokeAllPlugins(r=>{if(r.doTilesNeedUpdate){const o=r.doTilesNeedUpdate();e===null?e=o:e=!!(e||o)}}),e===!1){this.dispatchEvent({type:"update-before"}),this.dispatchEvent({type:"update-after"});return}this.dispatchEvent({type:"update-before"});const t=this.group,s=this.cameras,n=this.cameraMap,i=this.cameraInfo;for(;i.length>s.length;)i.pop();for(;i.length<s.length;)i.push({frustum:new pc,isOrthographic:!1,sseDenominator:-1,position:new A.Vector3,invScale:-1,pixelSize:0});Qt.setFromMatrixScale(t.matrixWorldInverse),Math.abs(Math.max(Qt.x-Qt.y,Qt.x-Qt.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let r=0,o=i.length;r<o;r++){const c=s[r],l=i[r],h=l.frustum,u=l.position,d=n.get(c);(d.width===0||d.height===0)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const f=c.projectionMatrix.elements;if(l.isOrthographic=f[15]===1,l.isOrthographic){const p=2/f[0],g=2/f[5];l.pixelSize=Math.max(g/d.height,p/d.width)}else l.sseDenominator=2/f[5]/d.height;cs.copy(t.matrixWorld),cs.premultiply(c.matrixWorldInverse),cs.premultiply(c.projectionMatrix),h.setFromProjectionMatrix(cs),u.set(0,0,0),u.applyMatrix4(c.matrixWorld),u.applyMatrix4(t.matrixWorldInverse)}if(super.update(),this.dispatchEvent({type:"update-after"}),s.length===0&&this.root){let r=!1;this.invokeAllPlugins(o=>r=r||!!(o!==this&&o.calculateTileViewError)),r===!1&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(e,t,s=null){super.preprocessNode(e,t,s);const n=new A.Matrix4;if(e.transform){const o=e.transform;for(let c=0;c<16;c++)n.elements[c]=o[c]}s&&n.premultiply(s.cached.transform);const i=new A.Matrix4().copy(n).invert(),r=new uc;"sphere"in e.boundingVolume&&r.setSphereData(...e.boundingVolume.sphere,n),"box"in e.boundingVolume&&r.setObbData(e.boundingVolume.box,n),"region"in e.boundingVolume&&r.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.cached={transform:n,transformInverse:i,active:!1,boundingVolume:r,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(e,t,s,n,i){const r=t.cached,o=n.split(/[\\/]/g);o.pop();const c=o.join("/"),l=this.fetchOptions,h=this.manager;let u=null;const d=r.transform,f=this._upRotationMatrix,p=(He(e)||s).toLowerCase();switch(p){case"b3dm":{const B=new Li(h);B.workingPath=c,B.fetchOptions=l,B.adjustmentTransform.copy(f),u=B.parse(e);break}case"pnts":{const B=new Fi(h);B.workingPath=c,B.fetchOptions=l,u=B.parse(e);break}case"i3dm":{const B=new Wi(h);B.workingPath=c,B.fetchOptions=l,B.adjustmentTransform.copy(f),B.ellipsoid.copy(this.ellipsoid),u=B.parse(e);break}case"cmpt":{const B=new cc(h);B.workingPath=c,B.fetchOptions=l,B.adjustmentTransform.copy(f),B.ellipsoid.copy(this.ellipsoid),u=B.parse(e).then(v=>v.scene);break}case"gltf":case"glb":{const B=h.getHandler("path.gltf")||h.getHandler("path.glb")||new Zt(h);B.setWithCredentials(l.credentials==="include"),B.setRequestHeader(l.headers||{}),l.credentials==="include"&&l.mode==="cors"&&B.setCrossOrigin("use-credentials");let v=B.resourcePath||B.path||c;!/[\\/]$/.test(v)&&v.length&&(v+="/"),u=B.parseAsync(e,v).then(_=>{_.scene=_.scene||new A.Group;const{scene:x}=_;return x.updateMatrix(),x.matrix.multiply(f).decompose(x.position,x.quaternion,x.scale),_});break}default:{u=this.invokeOnePlugin(B=>B.parseToMesh&&B.parseToMesh(e,t,s,n,i));break}}const g=await u;if(g===null)throw new Error(`TilesRenderer: Content type "${p}" not supported.`);let m,I;g.isObject3D?(m=g,I=null):(m=g.scene,I=g),m.updateMatrix(),m.matrix.premultiply(d),m.matrix.decompose(m.position,m.quaternion,m.scale),await this.invokeAllPlugins(B=>B.processTileModel&&B.processTileModel(m,t)),m.traverse(B=>{B[or]=B.frustumCulled}),cr(m,!this.autoDisableRendererCulling);const b=[],C=[],y=[];if(m.traverse(B=>{if(B.geometry&&C.push(B.geometry),B.material){const v=B.material;b.push(B.material);for(const _ in v){const x=v[_];x&&x.isTexture&&y.push(x)}}}),i.aborted){for(let B=0,v=y.length;B<v;B++){const _=y[B];_.image instanceof ImageBitmap&&_.image.close(),_.dispose()}return}r.materials=b,r.geometry=C,r.textures=y,r.scene=m,r.metadata=I}disposeTile(e){super.disposeTile(e);const t=e.cached;if(t.scene){const s=t.materials,n=t.geometry,i=t.textures,r=t.scene.parent;t.scene.traverse(o=>{o.userData.meshFeatures&&o.userData.meshFeatures.dispose(),o.userData.structuralMetadata&&o.userData.structuralMetadata.dispose()});for(let o=0,c=n.length;o<c;o++)n[o].dispose();for(let o=0,c=s.length;o<c;o++)s[o].dispose();for(let o=0,c=i.length;o<c;o++){const l=i[o];l.image instanceof ImageBitmap&&l.image.close(),l.dispose()}r&&r.remove(t.scene),this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const s=e.cached.scene,n=this.group;t?s&&(n.add(s),s.updateMatrixWorld(!0)):s&&n.remove(s),super.setTileVisible(e,t),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:e,visible:t})}calculateBytesUsed(e,t){const s=this._bytesUsed;return!s.has(e)&&t&&s.set(e,mc(t)),s.get(e)??null}calculateTileViewError(e,t){const s=e.cached,n=this.cameras,i=this.cameraInfo,r=s.boundingVolume;let o=!1,c=-1/0,l=1/0,h=-1/0,u=1/0;for(let d=0,f=n.length;d<f;d++){const p=i[d];let g,m;if(p.isOrthographic){const b=p.pixelSize;g=e.geometricError/b,m=1/0}else{const b=p.sseDenominator;m=r.distanceToPoint(p.position),g=m===0?1/0:e.geometricError/(m*b)}const I=i[d].frustum;r.intersectsFrustum(I)&&(o=!0,c=Math.max(c,g),l=Math.min(l,m)),h=Math.max(h,g),u=Math.min(u,m)}this.invokeAllPlugins(d=>{d!==this&&d.calculateTileViewError&&(d.calculateTileViewError(e,As),As.inView&&(o=!0,c=Math.max(c,As.error)),h=Math.max(h,As.error))}),o?(t.inView=!0,t.error=c,t.distanceFromCamera=l):(t.inView=!1,t.error=h,t.distanceFromCamera=u)}setLatLonToYUp(e,t){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:n}=this;ar.set(Math.PI/2,Math.PI/2,0),rr.makeRotationFromEuler(ar),s.getEastNorthUpFrame(e,t,0,n.matrix).multiply(rr).invert().decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}class yc{static intersectsFrustum(e,t){if(!e.intersectsFrustum(t))return!1;const s=this._getOBBAxes(e),n=this._getFrustumEdges(t),i=[...s,...n];for(const r of i){const o=this._projectOBB(e,r),c=this._projectFrustum(t,r);if(!this._intervalsOverlap(o,c))return!1}return!0}static _getOBBAxes(e){return[e.planes[0].normal,e.planes[2].normal,e.planes[4].normal]}static _getFrustumEdges(e){const t=[];for(let s=0;s<e.planes.length;s++){for(let n=s+1;n<e.planes.length;n++){const i=new A.Vector3().crossVectors(e.planes[s].normal,e.planes[n].normal);i.length()>0&&t.push(i.normalize())}t.push(e.planes[s].normal)}return t}static _projectOBB(e,t){let s=1/0,n=-1/0;for(const i of e.points){const r=i.dot(t);s>r&&(s=r),n<r&&(n=r)}return{min:s,max:n}}static _projectFrustum(e,t){let s=1/0,n=-1/0;for(const i of e.points){const r=i.dot(t);s>r&&(s=r),n<r&&(n=r)}return{min:s,max:n}}static _intervalsOverlap(e,t){return e.max>=t.min&&t.max>=e.min}}const ls={inView:!1,error:1/0};class Bc extends Ic{constructor(){super(...arguments),this.dynamicScreenSpaceError=!0}calculateTileViewError(e,t){const s=e.cached,n=this.cameras,i=this.cameraInfo,r=s.boundingVolume;let o=!1,c=-1/0,l=1/0,h=-1/0,u=1/0;for(let d=0,f=n.length;d<f;d++){const p=i[d];let g,m;if(p.isOrthographic){const b=p.pixelSize;g=e.geometricError/b,m=1/0}else{const b=p.sseDenominator;if(m=r.distanceToPoint(p.position),g=e.geometricError/(m*b),this.dynamicScreenSpaceError){const C=this._calculateDynamicScreenSpaceDistance(e,p,m);g=e.geometricError/(C*b)}}const I=i[d].frustum;this._intersectsFrustum(I,r)&&(o=!0,c=Math.max(c,g),l=Math.min(l,m)),h=Math.max(h,g),u=Math.min(u,m)}this.invokeAllPlugins(d=>{d!==this&&d.calculateTileViewError&&(d.calculateTileViewError(e,ls),ls.inView&&(o=!0,c=Math.max(c,ls.error)),h=Math.max(h,ls.error))}),o?(t.inView=!0,t.error=c,t.distanceFromCamera=l):(t.inView=!1,t.error=h,t.distanceFromCamera=u)}_calculateDynamicScreenSpaceDistance(e,t,s){const n=new A.Matrix4().copy(e.cached.transform).invert(),i=t.frustum.planes[5].normal.clone(),r=t.position.clone();r.applyMatrix4(n),i.transformDirection(n);const o=r.z,c=r.z/Math.abs(i.z);if(s>c){const l=o/c,u=(s-c)/l;return c+u}else return s}_intersectsFrustum(e,t){const s=t.obb||t.regionObb,n=t.sphere;return n&&!e.intersectsSphere(n)||s&&!yc.intersectsFrustum(s,e)?!1:!!(n||s)}}function hs(a){return a.__implicitRoot.implicitTiling.subdivisionScheme==="OCTREE"}function An(a){return hs(a)?8:4}function xc(a,e){if(!e)return[0,0,0];const t=2*e.__x+a.__subtreeIdx%2,s=2*e.__y+Math.floor(a.__subtreeIdx/2)%2,n=hs(a)?2*e.__z+Math.floor(a.__subtreeIdx/4)%2:0;return[t,s,n]}class Ar{constructor(e,t){this.parent=e,this.children=[],this.__level=e.__level+1,this.__implicitRoot=e.__implicitRoot,this.__subtreeIdx=t,[this.__x,this.__y,this.__z]=xc(this,e)}static copy(e){const t={};return t.children=[],t.__level=e.__level,t.__implicitRoot=e.__implicitRoot,t.__subtreeIdx=e.__subtreeIdx,[t.__x,t.__y,t.__z]=[e.__x,e.__y,e.__z],t.boundingVolume=e.boundingVolume,t.geometricError=e.geometricError,t}}class _c extends Bt{constructor(e){super(),this.tile=e,this.rootTile=e.__implicitRoot,this.workingPath=null}parseBuffer(e){const t=new DataView(e);let s=0;const n=He(t);console.assert(n==="subt",'SUBTREELoader: The magic bytes equal "subt".'),s+=4;const i=t.getUint32(s,!0);console.assert(i===1,'SUBTREELoader: The version listed in the header is "1".'),s+=4;const r=t.getUint32(s,!0);s+=8;const o=t.getUint32(s,!0);s+=8;const c=JSON.parse(js(new Uint8Array(e,s,r)));s+=r;const l=e.slice(s,s+o);return{version:i,subtreeJson:c,subtreeByte:l}}async parse(e){const t=this.parseBuffer(e),s=t.subtreeJson;s.contentAvailabilityHeaders=[].concat(s.contentAvailability);const n=this.preprocessBuffers(s.buffers),i=this.preprocessBufferViews(s.bufferViews,n);this.markActiveBufferViews(s,i);const r=await this.requestActiveBuffers(n,t.subtreeByte),o=this.parseActiveBufferViews(i,r);this.parseAvailability(t,s,o),this.expandSubtree(this.tile,t)}markActiveBufferViews(e,t){let s;const n=e.tileAvailability;isNaN(n.bitstream)?isNaN(n.bufferView)||(s=t[n.bufferView]):s=t[n.bitstream],s&&(s.isActive=!0,s.bufferHeader.isActive=!0);const i=e.contentAvailabilityHeaders;for(let o=0;o<i.length;o++)s=void 0,isNaN(i[o].bitstream)?isNaN(i[o].bufferView)||(s=t[i[o].bufferView]):s=t[i[o].bitstream],s&&(s.isActive=!0,s.bufferHeader.isActive=!0);s=void 0;const r=e.childSubtreeAvailability;isNaN(r.bitstream)?isNaN(r.bufferView)||(s=t[r.bufferView]):s=t[r.bitstream],s&&(s.isActive=!0,s.bufferHeader.isActive=!0)}async requestActiveBuffers(e,t){const s=[];for(let r=0;r<e.length;r++){const o=e[r];if(!o.isActive)s.push(Promise.resolve());else if(o.isExternal){const c=this.parseImplicitURIBuffer(this.tile,this.rootTile.implicitTiling.subtrees.uri,o.uri),l=fetch(c,this.fetchOptions).then(h=>{if(!h.ok)throw new Error(`SUBTREELoader: Failed to load external buffer from ${o.uri} with error code ${h.status}.`);return h.arrayBuffer()}).then(h=>new Uint8Array(h));s.push(l)}else s.push(Promise.resolve(new Uint8Array(t)))}const n=await Promise.all(s),i={};for(let r=0;r<n.length;r++){const o=n[r];o&&(i[r]=o)}return i}parseActiveBufferViews(e,t){const s={};for(let n=0;n<e.length;n++){const i=e[n];if(!i.isActive)continue;const r=i.byteOffset,o=r+i.byteLength,c=t[i.buffer];s[n]=c.slice(r,o)}return s}preprocessBuffers(e=[]){for(let t=0;t<e.length;t++){const s=e[t];s.isActive=!1,s.isExternal=!!s.uri}return e}preprocessBufferViews(e=[],t){for(let s=0;s<e.length;s++){const n=e[s];n.bufferHeader=t[n.buffer],n.isActive=!1,n.isExternal=n.bufferHeader.isExternal}return e}parseAvailability(e,t,s){const n=An(this.rootTile),i=this.rootTile.implicitTiling.subtreeLevels,r=(Math.pow(n,i)-1)/(n-1),o=Math.pow(n,i);e._tileAvailability=this.parseAvailabilityBitstream(t.tileAvailability,s,r),e._contentAvailabilityBitstreams=[];for(let c=0;c<t.contentAvailabilityHeaders.length;c++){const l=this.parseAvailabilityBitstream(t.contentAvailabilityHeaders[c],s,r);e._contentAvailabilityBitstreams.push(l)}e._childSubtreeAvailability=this.parseAvailabilityBitstream(t.childSubtreeAvailability,s,o)}parseAvailabilityBitstream(e,t,s){if(!isNaN(e.constant))return{constant:!!e.constant,lengthBits:s};let n;return isNaN(e.bitstream)?isNaN(e.bufferView)||(n=t[e.bufferView]):n=t[e.bitstream],{bitstream:n,lengthBits:s}}expandSubtree(e,t){const s=Ar.copy(e);for(let r=0;t&&r<t._contentAvailabilityBitstreams.length;r++)if(t&&this.getBit(t._contentAvailabilityBitstreams[r],0)){s.content={uri:this.parseImplicitURI(e,this.rootTile.content.uri)};break}e.children.push(s);const n=this.transcodeSubtreeTiles(s,t),i=this.listChildSubtrees(t,n);for(let r=0;r<i.length;r++){const o=i[r],c=o.tile,l=this.deriveChildTile(null,c,null,o.childMortonIndex);l.content={uri:this.parseImplicitURI(l,this.rootTile.implicitTiling.subtrees.uri)},c.children.push(l)}}transcodeSubtreeTiles(e,t){let s=[e],n=[];for(let i=1;i<this.rootTile.implicitTiling.subtreeLevels;i++){const r=An(this.rootTile),o=(Math.pow(r,i)-1)/(r-1),c=r*s.length;for(let l=0;l<c;l++){const h=o+l,u=l>>Math.log2(r),d=s[u];if(!this.getBit(t._tileAvailability,h)){n.push(void 0);continue}const f=this.deriveChildTile(t,d,h,l);d.children.push(f),n.push(f)}s=n,n=[]}return s}deriveChildTile(e,t,s,n){const i=new Ar(t,n);i.boundingVolume=this.getTileBoundingVolume(i),i.geometricError=this.getGeometricError(i);for(let r=0;e&&r<e._contentAvailabilityBitstreams.length;r++)if(e&&this.getBit(e._contentAvailabilityBitstreams[r],s)){i.content={uri:this.parseImplicitURI(i,this.rootTile.content.uri)};break}return i}getBit(e,t){if(t<0||t>=e.lengthBits)throw new Error("Bit index out of bounds.");if(e.constant!==void 0)return e.constant;const s=t>>3,n=t%8;return(new Uint8Array(e.bitstream)[s]>>n&1)===1}getTileBoundingVolume(e){const t={};if(this.rootTile.boundingVolume.region){const s=[...this.rootTile.boundingVolume.region],n=s[0],i=s[2],r=s[1],o=s[3],c=(i-n)/Math.pow(2,e.__level),l=(o-r)/Math.pow(2,e.__level);s[0]=n+c*e.__x,s[2]=n+c*(e.__x+1),s[1]=r+l*e.__y,s[3]=r+l*(e.__y+1);for(let h=0;h<4;h++){const u=s[h];u<-Math.PI?s[h]+=2*Math.PI:u>Math.PI&&(s[h]-=2*Math.PI)}if(hs(e)){const h=s[4],d=(s[5]-h)/Math.pow(2,e.__level);s[4]=h+d*e.__z,s[5]=h+d*(e.__z+1)}t.region=s}if(this.rootTile.boundingVolume.box){const s=[...this.rootTile.boundingVolume.box],n=2**e.__level-1,i=Math.pow(2,-e.__level),r=hs(e)?3:2;for(let o=0;o<r;o++){s[3+o*3+0]*=i,s[3+o*3+1]*=i,s[3+o*3+2]*=i;const c=s[3+o*3+0],l=s[3+o*3+1],h=s[3+o*3+2],u=o===0?e.__x:o===1?e.__y:e.__z;s[0]+=2*c*(-.5*n+u),s[1]+=2*l*(-.5*n+u),s[2]+=2*h*(-.5*n+u)}t.box=s}return t}getGeometricError(e){return this.rootTile.geometricError/Math.pow(2,e.__level)}listChildSubtrees(e,t){const s=[],n=An(this.rootTile);for(let i=0;i<t.length;i++){const r=t[i];if(r!==void 0)for(let o=0;o<n;o++){const c=i*n+o;this.getBit(e._childSubtreeAvailability,c)&&s.push({tile:r,childMortonIndex:c})}}return s}parseImplicitURI(e,t){return t=t.replace("{level}",e.__level),t=t.replace("{x}",e.__x),t=t.replace("{y}",e.__y),t=t.replace("{z}",e.__z),t}parseImplicitURIBuffer(e,t,s){const n=this.parseImplicitURI(e,t),i=new URL(n,this.workingPath+"/");return i.pathname=i.pathname.substring(0,i.pathname.lastIndexOf("/")),new URL(i.pathname+"/"+s,this.workingPath+"/").toString()}}class wc{constructor(){this.name="IMPLICIT_TILING_PLUGIN"}init(e){this.tiles=e}preprocessNode(e,t,s){var n;e.implicitTiling?(e.__hasUnrenderableContent=!0,e.__hasRenderableContent=!1,e.__subtreeIdx=0,e.__implicitRoot=e,e.__x=0,e.__y=0,e.__z=0,e.__level=0):/.subtree$/i.test((n=e.content)==null?void 0:n.uri)&&(e.__hasUnrenderableContent=!0,e.__hasRenderableContent=!1)}parseTile(e,t,s){if(/^subtree$/i.test(s)){const n=new _c(t);return n.workingPath=t.__basePath,n.fetchOptions=this.tiles.fetchOptions,n.parse(e)}}preprocessURL(e,t){if(t&&t.implicitTiling){const s=t.implicitTiling.subtrees.uri.replace("{level}",t.__level).replace("{x}",t.__x).replace("{y}",t.__y).replace("{z}",t.__z);return new URL(s,t.__basePath+"/").toString()}return e}disposeTile(e){var t;/.subtree$/i.test((t=e.content)==null?void 0:t.uri)&&(e.children.forEach(s=>{this.tiles.processNodeQueue.remove(s)}),e.children.length=0,e.__childrenProcessed=0)}}const vc=new A.OrthographicCamera(-1,1,1,-1,0,1);class Sc extends A.BufferGeometry{constructor(){super(),this.setAttribute("position",new A.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new A.Float32BufferAttribute([0,2,0,0,2,0],2))}}const Qc=new Sc;class Mc{constructor(e){this._mesh=new A.Mesh(Qc,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,vc)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class Dc{set delay(e){this.deferCallbacks.delay=e}get delay(){return this.deferCallbacks.delay}set bytesTarget(e){this.lruCache.minBytesSize=e}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(e={}){const{delay:t=0,bytesTarget:s=0}=e;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new di,this.deferCallbacks=new Lc,this.delay=t,this.bytesTarget=s}init(e){this.tiles=e;const{lruCache:t,deferCallbacks:s}=this;s.callback=i=>{t.markUnused(i),t.scheduleUnload(!1)};const n=i=>{const r=i.cached.scene;e.visibleTiles.has(i)||e.invokeOnePlugin(c=>c.unloadTileFromGPU&&c.unloadTileFromGPU(r,i))};this._onUpdateBefore=()=>{t.unloadPriorityCallback=e.lruCache.unloadPriorityCallback,t.computeMemoryUsageCallback=e.lruCache.computeMemoryUsageCallback,t.minSize=1/0,t.maxSize=1/0,t.maxBytesSize=1/0,t.unloadPercent=1,t.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:i,visible:r})=>{r?(t.add(i,n),e.markTileUsed(i),s.cancel(i)):s.run(i)},e.forEachLoadedModel((i,r)=>{const o=e.visibleTiles.has(r);this._onVisibilityChangeCallback({scene:i,visible:o})}),e.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),e.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(e,t){e&&e.traverse(s=>{if(s.material){const n=s.material;n.dispose();for(const i in n){const r=n[i];r&&r.isTexture&&r.dispose()}}s.geometry&&s.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class Lc{constructor(e=()=>{}){this.map=new Map,this.callback=e,this.delay=0}run(e){const{map:t,delay:s}=this;if(t.has(e))throw new Error("DeferCallbackManager: Callback already initialized.");s===0?this.callback(e):t.set(e,setTimeout(()=>this.callback(e),s))}cancel(e){const{map:t}=this;t.has(e)&&(clearTimeout(t.get(e)),t.delete(e))}cancelAll(){this.map.forEach((e,t)=>{this.cancel(t)})}}const Be=new A.Vector3,lr=["x","y","z"];class Ec extends A.LineSegments{constructor(e,t=16776960,s=40){const n=new A.BufferGeometry,i=[];for(let r=0;r<3;r++){const o=lr[r],c=lr[(r+1)%3];Be.set(0,0,0);for(let l=0;l<s;l++){let h;h=2*Math.PI*l/(s-1),Be[o]=Math.sin(h),Be[c]=Math.cos(h),i.push(Be.x,Be.y,Be.z),h=2*Math.PI*(l+1)/(s-1),Be[o]=Math.sin(h),Be[c]=Math.cos(h),i.push(Be.x,Be.y,Be.z)}}n.setAttribute("position",new A.BufferAttribute(new Float32Array(i),3)),n.computeBoundingSphere(),super(n,new A.LineBasicMaterial({color:t,toneMapped:!1})),this.sphere=e,this.type="SphereHelper"}updateMatrixWorld(e){const t=this.sphere;this.position.copy(t.center),this.scale.setScalar(t.radius),super.updateMatrixWorld(e)}}const ln=new A.Vector3,us=new A.Vector3,ve=new A.Vector3;new A.Vector3,new A.Vector3;function Fc(a,{computeNormals:e=!1}={}){const{latStart:t=-Math.PI/2,latEnd:s=Math.PI/2,lonStart:n=0,lonEnd:i=2*Math.PI,heightStart:r=0,heightEnd:o=0}=a,c=new A.BoxGeometry(1,1,1,32,32),{normal:l,position:h}=c.attributes,u=h.clone();for(let d=0,f=h.count;d<f;d++){ve.fromBufferAttribute(h,d);const p=A.MathUtils.mapLinear(ve.x,-.5,.5,t,s),g=A.MathUtils.mapLinear(ve.y,-.5,.5,n,i);let m=r;a.getCartographicToNormal(p,g,ln),ve.z<0&&(m=o),a.getCartographicToPosition(p,g,m,ve),h.setXYZ(d,...ve)}e&&c.computeVertexNormals();for(let d=0,f=u.count;d<f;d++){ve.fromBufferAttribute(u,d);const p=A.MathUtils.mapLinear(ve.x,-.5,.5,t,s),g=A.MathUtils.mapLinear(ve.y,-.5,.5,n,i);ln.fromBufferAttribute(l,d),a.getCartographicToNormal(p,g,us),Math.abs(ln.dot(us))>.1&&(ve.z>0&&us.multiplyScalar(-1),l.setXYZ(d,...us))}return c}class Tc extends A.LineSegments{constructor(e=new sr,t=16776960){super(),this.ellipsoidRegion=e,this.material.color.set(t),this.update()}update(){const e=Fc(this.ellipsoidRegion);this.geometry.dispose(),this.geometry=new A.EdgesGeometry(e,80)}dispose(){this.geometry.dispose(),this.material.dispose()}}const hr=Symbol("ORIGINAL_MATERIAL"),hn=Symbol("HAS_RANDOM_COLOR"),un=Symbol("HAS_RANDOM_NODE_COLOR"),dn=Symbol("LOAD_TIME"),st=Symbol("PARENT_BOUND_REF_COUNT"),ur=new A.Sphere,fn=()=>{},pn={};function gn(a){if(!pn[a]){const e=Math.random(),t=.5+Math.random()*.5,s=.375+Math.random()*.25;pn[a]=new A.Color().setHSL(e,t,s)}return pn[a]}const Mt=0,dr=1,fr=2,pr=3,gr=4,mr=5,br=6,ds=7,fs=8,Cr=9,mn=10,kc=Object.freeze({NONE:Mt,SCREEN_ERROR:dr,GEOMETRIC_ERROR:fr,DISTANCE:pr,DEPTH:gr,RELATIVE_DEPTH:mr,IS_LEAF:br,RANDOM_COLOR:ds,RANDOM_NODE_COLOR:fs,CUSTOM_COLOR:Cr,LOAD_ORDER:mn});class Gc{static get ColorModes(){return kc}get unlit(){return this._unlit}set unlit(e){e!==this._unlit&&(this._unlit=e,this.materialsNeedUpdate=!0)}get colorMode(){return this._colorMode}set colorMode(e){e!==this._colorMode&&(this._colorMode=e,this.materialsNeedUpdate=!0)}constructor(e){e={displayParentBounds:!1,displayBoxBounds:!1,displaySphereBounds:!1,displayRegionBounds:!1,colorMode:Mt,maxDebugDepth:-1,maxDebugDistance:-1,maxDebugError:-1,customColorCallback:null,unlit:!1,enabled:!0,...e},this.name="DEBUG_TILES_PLUGIN",this.tiles=null,this._colorMode=null,this._unlit=null,this.materialsNeedUpdate=!1,this.extremeDebugDepth=-1,this.extremeDebugError=-1,this.boxGroup=null,this.sphereGroup=null,this.regionGroup=null,this._enabled=e.enabled,this._displayParentBounds=e.displayParentBounds,this.displayBoxBounds=e.displayBoxBounds,this.displaySphereBounds=e.displaySphereBounds,this.displayRegionBounds=e.displayRegionBounds,this.colorMode=e.colorMode,this.maxDebugDepth=e.maxDebugDepth,this.maxDebugDistance=e.maxDebugDistance,this.maxDebugError=e.maxDebugError,this.customColorCallback=e.customColorCallback,this.unlit=e.unlit,this.getDebugColor=(t,s)=>{s.setRGB(t,t,t)}}get enabled(){return this._enabled}set enabled(e){e!==this._enabled&&this.tiles!==null&&(e?this.init(this.tiles):this.dispose()),this._enabled=e}get displayParentBounds(){return this._displayParentBounds}set displayParentBounds(e){this._displayParentBounds!==e&&(this._displayParentBounds=e,e?this.tiles.traverse(t=>{t.__visible&&this._onTileVisibilityChange(t,!0)}):Vs(this.tiles.root,null,t=>{t[st]=null,this._onTileVisibilityChange(t,t.__visible)}))}init(e){if(this.tiles=e,!this.enabled)return;const t=e.group;this.boxGroup=new A.Group,this.boxGroup.name="DebugTilesRenderer.boxGroup",t.add(this.boxGroup),this.boxGroup.updateMatrixWorld(),this.sphereGroup=new A.Group,this.sphereGroup.name="DebugTilesRenderer.sphereGroup",t.add(this.sphereGroup),this.sphereGroup.updateMatrixWorld(),this.regionGroup=new A.Group,this.regionGroup.name="DebugTilesRenderer.regionGroup",t.add(this.regionGroup),this.regionGroup.updateMatrixWorld(),this._onLoadTileSetCB=()=>{this._initExtremes()},this._onLoadModelCB=({scene:s,tile:n})=>{this._onLoadModel(s,n)},this._onDisposeModelCB=({tile:s})=>{this._onDisposeModel(s)},this._onUpdateAfterCB=()=>{this._onUpdateAfter()},this._onTileVisibilityChangeCB=({scene:s,tile:n,visible:i})=>{this._onTileVisibilityChange(n,i)},e.addEventListener("load-tile-set",this._onLoadTileSetCB),e.addEventListener("load-model",this._onLoadModelCB),e.addEventListener("dispose-model",this._onDisposeModelCB),e.addEventListener("update-after",this._onUpdateAfterCB),e.addEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this._initExtremes(),e.traverse(s=>{s.cached.scene&&this._onLoadModel(s.cached.scene,s)}),e.visibleTiles.forEach(s=>{this._onTileVisibilityChange(s,!0)})}getTileInformationFromActiveObject(e){let t=null;return this.tiles.activeTiles.forEach(n=>{if(t)return!0;const i=n.cached.scene;i&&i.traverse(r=>{r===e&&(t=n)})}),t?{distanceToCamera:t.__distanceFromCamera,geometricError:t.geometricError,screenSpaceError:t.__error,depth:t.__depth,isLeaf:t.__isLeaf}:null}_initExtremes(){if(!(this.tiles&&this.tiles.root))return;let e=-1,t=-1;Vs(this.tiles.root,null,(s,n,i)=>{e=Math.max(e,i),t=Math.max(t,s.geometricError)}),this.extremeDebugDepth=e,this.extremeDebugError=t}_onUpdateAfter(){const{tiles:e,colorMode:t}=this;if(!e.root)return;this.materialsNeedUpdate&&(e.forEachLoadedModel(l=>{this._updateMaterial(l)}),this.materialsNeedUpdate=!1),this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds,this.regionGroup.visible=this.displayRegionBounds;let s=-1;this.maxDebugDepth===-1?s=this.extremeDebugDepth:s=this.maxDebugDepth;let n=-1;this.maxDebugError===-1?n=this.extremeDebugError:n=this.maxDebugError;let i=-1;this.maxDebugDistance===-1?(e.getBoundingSphere(ur),i=ur.radius):i=this.maxDebugDistance;const{errorTarget:r,visibleTiles:o}=e;let c;t===mn&&(c=Array.from(o).sort((l,h)=>l[dn]-h[dn])),o.forEach(l=>{const h=l.cached.scene;let u,d,f;t===ds&&(u=Math.random(),d=.5+Math.random()*.5,f=.375+Math.random()*.25),h.traverse(p=>{if(t===fs&&(u=Math.random(),d=.5+Math.random()*.5,f=.375+Math.random()*.25),p.material)switch(t!==ds&&delete p.material[hn],t!==fs&&delete p.material[un],t){case gr:{const g=l.__depth/s;this.getDebugColor(g,p.material.color);break}case mr:{const g=l.__depthFromRenderedParent/s;this.getDebugColor(g,p.material.color);break}case dr:{const g=l.__error/r;g>1?p.material.color.setRGB(1,0,0):this.getDebugColor(g,p.material.color);break}case fr:{const g=Math.min(l.geometricError/n,1);this.getDebugColor(g,p.material.color);break}case pr:{const g=Math.min(l.__distanceFromCamera/i,1);this.getDebugColor(g,p.material.color);break}case br:{!l.children||l.children.length===0?this.getDebugColor(1,p.material.color):this.getDebugColor(0,p.material.color);break}case fs:{p.material[un]||(p.material.color.setHSL(u,d,f),p.material[un]=!0);break}case ds:{p.material[hn]||(p.material.color.setHSL(u,d,f),p.material[hn]=!0);break}case Cr:{this.customColorCallback?this.customColorCallback(l,p):console.warn("DebugTilesRenderer: customColorCallback not defined");break}case mn:{const g=c.indexOf(l);this.getDebugColor(g/(c.length-1),p.material.color);break}}})})}_onTileVisibilityChange(e,t){this.displayParentBounds?lo(e,s=>{s[st]==null&&(s[st]=0),t?s[st]++:s[st]>0&&s[st]--;const n=s===e&&t||this.displayParentBounds&&s[st]>0;this._updateBoundHelper(s,n)}):this._updateBoundHelper(e,t)}_createBoundHelper(e){const t=this.tiles,s=e.cached,{sphere:n,obb:i,region:r}=s.boundingVolume;if(i){const o=new A.Group;o.name="DebugTilesRenderer.boxHelperGroup",o.matrix.copy(i.transform),o.matrixAutoUpdate=!1;const c=new A.Box3Helper(i.box,gn(e.__depth));c.raycast=fn,o.add(c),s.boxHelperGroup=o,t.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(o),o.updateMatrixWorld(!0))}if(n){const o=new Ec(n,gn(e.__depth));o.raycast=fn,s.sphereHelper=o,t.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(o),o.updateMatrixWorld(!0))}if(r){const o=new Tc(r,gn(e.__depth));o.raycast=fn;const c=new A.Sphere;r.getBoundingSphere(c),o.position.copy(c.center),c.center.multiplyScalar(-1),o.geometry.translate(...c.center),s.regionHelper=o,t.visibleTiles.has(e)&&this.displayRegionBounds&&(this.regionGroup.add(o),o.updateMatrixWorld(!0))}}_updateHelperMaterial(e,t){e.__visible||!this.displayParentBounds?t.opacity=1:t.opacity=.2;const s=t.transparent;t.transparent=t.opacity<1,t.transparent!==s&&(t.needsUpdate=!0)}_updateBoundHelper(e,t){const s=e.cached;if(!s)return;const n=this.sphereGroup,i=this.boxGroup,r=this.regionGroup;t&&s.boxHelperGroup==null&&s.sphereHelper==null&&s.regionHelper==null&&this._createBoundHelper(e);const o=s.boxHelperGroup,c=s.sphereHelper,l=s.regionHelper;t?(o&&(i.add(o),o.updateMatrixWorld(!0),this._updateHelperMaterial(e,o.children[0].material)),c&&(n.add(c),c.updateMatrixWorld(!0),this._updateHelperMaterial(e,c.material)),l&&(r.add(l),l.updateMatrixWorld(!0),this._updateHelperMaterial(e,l.material))):(o&&i.remove(o),c&&n.remove(c),l&&r.remove(l))}_updateMaterial(e){const{colorMode:t,unlit:s}=this;e.traverse(n=>{if(!n.material)return;const i=n.material,r=n[hr];if(i!==r&&i.dispose(),t!==Mt||s){if(n.isPoints){const o=new A.PointsMaterial;o.size=r.size,o.sizeAttenuation=r.sizeAttenuation,n.material=o}else s?n.material=new A.MeshBasicMaterial:(n.material=new A.MeshStandardMaterial,n.material.flatShading=!0);t===Mt&&(n.material.map=r.map,n.material.color.set(r.color))}else n.material=r})}_onLoadModel(e,t){t[dn]=performance.now(),e.traverse(s=>{const n=s.material;n&&(s[hr]=n)}),this._updateMaterial(e)}_onDisposeModel(e){const t=e.cached;t.boxHelperGroup&&(t.boxHelperGroup.children[0].geometry.dispose(),delete t.boxHelperGroup),t.sphereHelper&&(t.sphereHelper.geometry.dispose(),delete t.sphereHelper),t.regionHelper&&(t.regionHelper.geometry.dispose(),delete t.regionHelper)}dispose(){var t,s,n;if(!this.enabled)return;const e=this.tiles;e.removeEventListener("load-tile-set",this._onLoadTileSetCB),e.removeEventListener("load-model",this._onLoadModelCB),e.removeEventListener("dispose-model",this._onDisposeModelCB),e.removeEventListener("update-after",this._onUpdateAfterCB),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this.colorMode=Mt,this.unlit=!1,e.forEachLoadedModel(i=>{this._updateMaterial(i)}),e.traverse(i=>{this._onDisposeModel(i)}),(t=this.boxGroup)==null||t.removeFromParent(),(s=this.sphereGroup)==null||s.removeFromParent(),(n=this.regionGroup)==null||n.removeFromParent()}}function Ir(a,e){if(e===A.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(e===A.TriangleFanDrawMode||e===A.TriangleStripDrawMode){let t=a.getIndex();if(t===null){const r=[],o=a.getAttribute("position");if(o!==void 0){for(let c=0;c<o.count;c++)r.push(c);a.setIndex(r),t=a.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a}const s=t.count-2,n=[];if(e===A.TriangleFanDrawMode)for(let r=1;r<=s;r++)n.push(t.getX(0)),n.push(t.getX(r)),n.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(n.push(t.getX(r)),n.push(t.getX(r+1)),n.push(t.getX(r+2))):(n.push(t.getX(r+2)),n.push(t.getX(r+1)),n.push(t.getX(r)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=a.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),a}class Pc extends A.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Vc(t)}),this.register(function(t){return new zc(t)}),this.register(function(t){return new $c(t)}),this.register(function(t){return new Hc(t)}),this.register(function(t){return new eA(t)}),this.register(function(t){return new qc(t)}),this.register(function(t){return new Wc(t)}),this.register(function(t){return new Kc(t)}),this.register(function(t){return new Jc(t)}),this.register(function(t){return new Rc(t)}),this.register(function(t){return new Yc(t)}),this.register(function(t){return new jc(t)}),this.register(function(t){return new Zc(t)}),this.register(function(t){return new Xc(t)}),this.register(function(t){return new Nc(t)}),this.register(function(t){return new tA(t)}),this.register(function(t){return new sA(t)})}load(e,t,s,n){const i=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const l=A.LoaderUtils.extractUrlBase(e);r=A.LoaderUtils.resolveURL(l,this.path)}else r=A.LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const o=function(l){n?n(l):console.error(l),i.manager.itemError(e),i.manager.itemEnd(e)},c=new A.FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(l){try{i.parse(l,r,function(h){t(h),i.manager.itemEnd(e)},o)}catch(h){o(h)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const r={},o={},c=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.decode(new Uint8Array(e,0,4))===yr){try{r[K.KHR_BINARY_GLTF]=new nA(e)}catch(u){n&&n(u);return}i=JSON.parse(r[K.KHR_BINARY_GLTF].content)}else i=JSON.parse(c.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new gA(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const u=this.pluginCallbacks[h](l);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[u.name]=u,r[u.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const u=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(u){case K.KHR_MATERIALS_UNLIT:r[u]=new Oc;break;case K.KHR_DRACO_MESH_COMPRESSION:r[u]=new iA(i,this.dracoLoader);break;case K.KHR_TEXTURE_TRANSFORM:r[u]=new rA;break;case K.KHR_MESH_QUANTIZATION:r[u]=new aA;break;default:d.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}l.setExtensions(r),l.setPlugins(o),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}}function Uc(){let a={};return{get:function(e){return a[e]},add:function(e,t){a[e]=t},remove:function(e){delete a[e]},removeAll:function(){a={}}}}const K={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Nc{constructor(e){this.parser=e,this.name=K.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let l;const h=new A.Color(16777215);c.color!==void 0&&h.setRGB(c.color[0],c.color[1],c.color[2],A.LinearSRGBColorSpace);const u=c.range!==void 0?c.range:0;switch(c.type){case"directional":l=new A.DirectionalLight(h),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new A.PointLight(h),l.distance=u;break;case"spot":l=new A.SpotLight(h),l.distance=u,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,l.angle=c.spot.outerConeAngle,l.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return l.position.set(0,0,0),Oe(l,c),c.intensity!==void 0&&(l.intensity=c.intensity),l.name=t.createUniqueName(c.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(c){return s._getNodeRef(t.cache,o,c)})}}class Oc{constructor(){this.name=K.KHR_MATERIALS_UNLIT}getMaterialType(){return A.MeshBasicMaterial}extendParams(e,t,s){const n=[];e.color=new A.Color(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],A.LinearSRGBColorSpace),e.opacity=r[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,A.SRGBColorSpace))}return Promise.all(n)}}class Rc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class Vc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const o=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new A.Vector2(o,o)}return Promise.all(i)}}class zc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class jc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class qc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new A.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const o=r.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,A.SRGBColorSpace)),r.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class Wc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class Kc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return t.attenuationColor=new A.Color().setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace),Promise.all(i)}}class Jc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Yc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return t.specularColor=new A.Color().setRGB(o[0],o[1],o[2],A.LinearSRGBColorSpace),r.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,A.SRGBColorSpace)),Promise.all(i)}}class Xc{constructor(e){this.parser=e,this.name=K.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&i.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}}class Zc{constructor(e){this.parser=e,this.name=K.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:A.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&i.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}}class $c{constructor(e){this.parser=e,this.name=K.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class Hc{constructor(e){this.parser=e,this.name=K.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let c=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(c=l)}return this.detectSupport().then(function(l){if(l)return s.loadTextureImage(e,r.source,c);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class eA{constructor(e){this.parser=e,this.name=K.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let c=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(c=l)}return this.detectSupport().then(function(l){if(l)return s.loadTextureImage(e,r.source,c);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class tA{constructor(e){this.name=K.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(o){const c=n.byteOffset||0,l=n.byteLength||0,h=n.count,u=n.byteStride,d=new Uint8Array(o,c,l);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,u,d,n.mode,n.filter).then(function(f){return f.buffer}):r.ready.then(function(){const f=new ArrayBuffer(h*u);return r.decodeGltfBuffer(new Uint8Array(f),h,u,d,n.mode,n.filter),f})})}else return null}}class sA{constructor(e){this.name=K.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==Ce.TRIANGLES&&l.mode!==Ce.TRIANGLE_STRIP&&l.mode!==Ce.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=s.extensions[this.name].attributes,o=[],c={};for(const l in r)o.push(this.parser.getDependency("accessor",r[l]).then(h=>(c[l]=h,c[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const h=l.pop(),u=h.isGroup?h.children:[h],d=l[0].count,f=[];for(const p of u){const g=new A.Matrix4,m=new A.Vector3,I=new A.Quaternion,b=new A.Vector3(1,1,1),C=new A.InstancedMesh(p.geometry,p.material,d);for(let y=0;y<d;y++)c.TRANSLATION&&m.fromBufferAttribute(c.TRANSLATION,y),c.ROTATION&&I.fromBufferAttribute(c.ROTATION,y),c.SCALE&&b.fromBufferAttribute(c.SCALE,y),C.setMatrixAt(y,g.compose(m,I,b));for(const y in c)if(y==="_COLOR_0"){const B=c[y];C.instanceColor=new A.InstancedBufferAttribute(B.array,B.itemSize,B.normalized)}else y!=="TRANSLATION"&&y!=="ROTATION"&&y!=="SCALE"&&p.geometry.setAttribute(y,c[y]);A.Object3D.prototype.copy.call(C,p),this.parser.assignFinalMaterial(C),f.push(C)}return h.isGroup?(h.clear(),h.add(...f),h):f[0]}))}}const yr="glTF",Dt=12,Br={JSON:1313821514,BIN:5130562};class nA{constructor(e){this.name=K.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Dt),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==yr)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Dt,i=new DataView(e,Dt);let r=0;for(;r<n;){const o=i.getUint32(r,!0);r+=4;const c=i.getUint32(r,!0);if(r+=4,c===Br.JSON){const l=new Uint8Array(e,Dt+r,o);this.content=s.decode(l)}else if(c===Br.BIN){const l=Dt+r;this.body=e.slice(l,l+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class iA{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=K.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,o={},c={},l={};for(const h in r){const u=Cn[h]||h.toLowerCase();o[u]=r[h]}for(const h in e.attributes){const u=Cn[h]||h.toLowerCase();if(r[h]!==void 0){const d=s.accessors[e.attributes[h]],f=gt[d.componentType];l[u]=f.name,c[u]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(u,d){n.decodeDracoFile(h,function(f){for(const p in f.attributes){const g=f.attributes[p],m=c[p];m!==void 0&&(g.normalized=m)}u(f)},o,l,A.LinearSRGBColorSpace,d)})})}}class rA{constructor(){this.name=K.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class aA{constructor(){this.name=K.KHR_MESH_QUANTIZATION}}class xr extends A.Interpolant{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let r=0;r!==n;r++)t[r]=s[i+r];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,r=this.sampleValues,o=this.valueSize,c=o*2,l=o*3,h=n-t,u=(s-t)/h,d=u*u,f=d*u,p=e*l,g=p-l,m=-2*f+3*d,I=f-d,b=1-m,C=I-d+u;for(let y=0;y!==o;y++){const B=r[g+y+o],v=r[g+y+c]*h,_=r[p+y+o],x=r[p+y]*h;i[y]=b*B+C*v+m*_+I*x}return i}}const oA=new A.Quaternion;class cA extends xr{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return oA.fromArray(i).normalize().toArray(i),i}}const Ce={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},gt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},_r={9728:A.NearestFilter,9729:A.LinearFilter,9984:A.NearestMipmapNearestFilter,9985:A.LinearMipmapNearestFilter,9986:A.NearestMipmapLinearFilter,9987:A.LinearMipmapLinearFilter},wr={33071:A.ClampToEdgeWrapping,33648:A.MirroredRepeatWrapping,10497:A.RepeatWrapping},bn={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Cn={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Je={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},AA={CUBICSPLINE:void 0,LINEAR:A.InterpolateLinear,STEP:A.InterpolateDiscrete},In={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function lA(a){return a.DefaultMaterial===void 0&&(a.DefaultMaterial=new A.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:A.FrontSide})),a.DefaultMaterial}function nt(a,e,t){for(const s in t.extensions)a[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Oe(a,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(a.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function hA(a,e,t){let s=!1,n=!1,i=!1;for(let l=0,h=e.length;l<h;l++){const u=e[l];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(a);const r=[],o=[],c=[];for(let l=0,h=e.length;l<h;l++){const u=e[l];if(s){const d=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):a.attributes.position;r.push(d)}if(n){const d=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):a.attributes.normal;o.push(d)}if(i){const d=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):a.attributes.color;c.push(d)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(c)]).then(function(l){const h=l[0],u=l[1],d=l[2];return s&&(a.morphAttributes.position=h),n&&(a.morphAttributes.normal=u),i&&(a.morphAttributes.color=d),a.morphTargetsRelative=!0,a})}function uA(a,e){if(a.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)a.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(a.morphTargetInfluences.length===t.length){a.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)a.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function dA(a){let e;const t=a.extensions&&a.extensions[K.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+yn(t.attributes):e=a.indices+":"+yn(a.attributes)+":"+a.mode,a.targets!==void 0)for(let s=0,n=a.targets.length;s<n;s++)e+=":"+yn(a.targets[s]);return e}function yn(a){let e="";const t=Object.keys(a).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+a[t[s]]+";";return e}function Bn(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function fA(a){return a.search(/\.jpe?g($|\?)/i)>0||a.search(/^data\:image\/jpeg/)===0?"image/jpeg":a.search(/\.webp($|\?)/i)>0||a.search(/^data\:image\/webp/)===0?"image/webp":a.search(/\.ktx2($|\?)/i)>0||a.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const pA=new A.Matrix4;class gA{constructor(e={},t={}){var c;this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Uc,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,i=!1,r=-1;if(typeof navigator<"u"){const l=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(l)===!0;const h=l.match(/Version\/(\d+)/);n=s&&h?parseInt(h[1],10):-1,i=l.indexOf("Firefox")>-1,r=i?l.match(/Firefox\/([0-9]+)\./)[1]:-1}((c=e.images)==null?void 0:c.some(l=>{var h;return((h=l.uri||l.mimeType)==null?void 0:h.slice(-4))==="ktx2"}))&&this.options.ktx2Loader?this.textureLoader=this.options.ktx2Loader:typeof createImageBitmap>"u"||s&&n<17||i&&r<98?this.textureLoader=new A.TextureLoader(this.options.manager):this.textureLoader=new A.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new A.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}dispose(){this.extensions={},this.plugins={},this.cache.removeAll(),this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={}}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const o={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:s,userData:{}};return nt(i,o,n),Oe(o,n),Promise.all(s._invokeAll(function(c){return c.afterRoot&&c.afterRoot(o)})).then(function(){for(const c of o.scenes)c.updateMatrixWorld();e(o)})}).catch(t).finally(function(){s.dispose()})}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n].joints;for(let o=0,c=r.length;o<c;o++)e[r[o]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const r=e[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(r,o)=>{const c=this.associations.get(r);c!=null&&this.associations.set(o,c);for(const[l,h]of r.children.entries())i(h,o.children[l])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[K.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,r){s.load(A.LoaderUtils.resolveURL(t.uri,n.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const r=bn[n.type],o=gt[n.componentType],c=n.normalized===!0,l=new o(n.count*r);return Promise.resolve(new A.BufferAttribute(l,r,c))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(r){const o=r[0],c=bn[n.type],l=gt[n.componentType],h=l.BYTES_PER_ELEMENT,u=h*c,d=n.byteOffset||0,f=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,p=n.normalized===!0;let g,m;if(f&&f!==u){const I=Math.floor(d/f),b="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+I+":"+n.count;let C=t.cache.get(b);C||(g=new l(o,I*f,n.count*f/h),C=new A.InterleavedBuffer(g,f/h),t.cache.add(b,C)),m=new A.InterleavedBufferAttribute(C,c,d%f/h,p)}else o===null?g=new l(n.count*c):g=new l(o,d,n.count*c),m=new A.BufferAttribute(g,c,p);if(n.sparse!==void 0){const I=bn.SCALAR,b=gt[n.sparse.indices.componentType],C=n.sparse.indices.byteOffset||0,y=n.sparse.values.byteOffset||0,B=new b(r[1],C,n.sparse.count*I),v=new l(r[2],y,n.sparse.count*c);o!==null&&(m=new A.BufferAttribute(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let _=0,x=B.length;_<x;_++){const w=B[_];if(m.setX(w,v[_*c]),c>=2&&m.setY(w,v[_*c+1]),c>=3&&m.setZ(w,v[_*c+2]),c>=4&&m.setW(w,v[_*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=p}return m})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let o=this.textureLoader;if(r.uri){const c=s.manager.getHandler(r.uri);c!==null&&(o=c)}return this.loadTextureImage(e,i,o)}loadTextureImage(e,t,s){const n=this,i=this.json,r=i.textures[e],o=i.images[t],c=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[c])return this.textureCache[c];const l=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||o.name||"",h.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(h.name=o.uri);const d=(i.samplers||{})[r.sampler]||{};return h.magFilter=_r[d.magFilter]||A.LinearFilter,h.minFilter=_r[d.minFilter]||A.LinearMipmapLinearFilter,h.wrapS=wr[d.wrapS]||A.RepeatWrapping,h.wrapT=wr[d.wrapT]||A.RepeatWrapping,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==A.NearestFilter&&h.minFilter!==A.LinearFilter,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[c]=l,l}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const r=n.images[e],o=self.URL||self.webkitURL;let c=r.uri||"",l=!1;if(r.bufferView!==void 0)c=s.getDependency("bufferView",r.bufferView).then(function(u){l=!0;const d=new Blob([u],{type:r.mimeType});return c=o.createObjectURL(d),c});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(c).then(function(u){return new Promise(function(d,f){let p=d;t.isImageBitmapLoader===!0&&(p=function(g){const m=new A.Texture(g);m.needsUpdate=!0,d(m)}),t.load(A.LoaderUtils.resolveURL(u,i.path),p,void 0,f)})}).then(function(u){return l===!0&&o.revokeObjectURL(c),Oe(u,r),u.userData.mimeType=r.mimeType||fA(r.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),u});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),i.extensions[K.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[K.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const c=i.associations.get(r);r=i.extensions[K.KHR_TEXTURE_TRANSFORM].extendTexture(r,o),i.associations.set(r,c)}}return n!==void 0&&(r.colorSpace=n),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let c=this.cache.get(o);c||(c=new A.PointsMaterial,A.Material.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,c.sizeAttenuation=!1,this.cache.add(o,c)),s=c}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let c=this.cache.get(o);c||(c=new A.LineBasicMaterial,A.Material.prototype.copy.call(c,s),c.color.copy(s.color),c.map=s.map,this.cache.add(o,c)),s=c}if(n||i||r){let o="ClonedMaterial:"+s.uuid+":";n&&(o+="derivative-tangents:"),i&&(o+="vertex-colors:"),r&&(o+="flat-shading:");let c=this.cache.get(o);c||(c=s.clone(),i&&(c.vertexColors=!0),r&&(c.flatShading=!0),n&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(o,c),this.associations.set(c,this.associations.get(s))),s=c}e.material=s}getMaterialType(){return A.MeshStandardMaterial}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let r;const o={},c=i.extensions||{},l=[];if(c[K.KHR_MATERIALS_UNLIT]){const u=n[K.KHR_MATERIALS_UNLIT];r=u.getMaterialType(),l.push(u.extendParams(o,i,t))}else{const u=i.pbrMetallicRoughness||{};if(o.color=new A.Color(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],A.LinearSRGBColorSpace),o.opacity=d[3]}u.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",u.baseColorTexture,A.SRGBColorSpace)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}i.doubleSided===!0&&(o.side=A.DoubleSide);const h=i.alphaMode||In.OPAQUE;if(h===In.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,h===In.MASK&&(o.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==A.MeshBasicMaterial&&(l.push(t.assignTexture(o,"normalMap",i.normalTexture)),o.normalScale=new A.Vector2(1,1),i.normalTexture.scale!==void 0)){const u=i.normalTexture.scale;o.normalScale.set(u,u)}if(i.occlusionTexture!==void 0&&r!==A.MeshBasicMaterial&&(l.push(t.assignTexture(o,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==A.MeshBasicMaterial){const u=i.emissiveFactor;o.emissive=new A.Color().setRGB(u[0],u[1],u[2],A.LinearSRGBColorSpace)}return i.emissiveTexture!==void 0&&r!==A.MeshBasicMaterial&&l.push(t.assignTexture(o,"emissiveMap",i.emissiveTexture,A.SRGBColorSpace)),Promise.all(l).then(function(){const u=new r(o);return i.name&&(u.name=i.name),Oe(u,i),t.associations.set(u,{materials:e}),i.extensions&&nt(n,u,i),u})}createUniqueName(e){const t=A.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(o){return s[K.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(c){return vr(c,o,t)})}const r=[];for(let o=0,c=e.length;o<c;o++){const l=e[o],h=dA(l),u=n[h];if(u)r.push(u.promise);else{let d;l.extensions&&l.extensions[K.KHR_DRACO_MESH_COMPRESSION]?d=i(l):d=vr(new A.BufferGeometry,l,t),n[h]={primitive:l,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],r=i.primitives,o=[];for(let c=0,l=r.length;c<l;c++){const h=r[c].material===void 0?lA(this.cache):this.getDependency("material",r[c].material);o.push(h)}return o.push(t.loadGeometries(r)),Promise.all(o).then(function(c){const l=c.slice(0,c.length-1),h=c[c.length-1],u=[];for(let f=0,p=h.length;f<p;f++){const g=h[f],m=r[f];let I;const b=l[f];if(m.mode===Ce.TRIANGLES||m.mode===Ce.TRIANGLE_STRIP||m.mode===Ce.TRIANGLE_FAN||m.mode===void 0)I=i.isSkinnedMesh===!0?new A.SkinnedMesh(g,b):new A.Mesh(g,b),I.isSkinnedMesh===!0&&I.normalizeSkinWeights(),m.mode===Ce.TRIANGLE_STRIP?I.geometry=Ir(I.geometry,A.TriangleStripDrawMode):m.mode===Ce.TRIANGLE_FAN&&(I.geometry=Ir(I.geometry,A.TriangleFanDrawMode));else if(m.mode===Ce.LINES)I=new A.LineSegments(g,b);else if(m.mode===Ce.LINE_STRIP)I=new A.Line(g,b);else if(m.mode===Ce.LINE_LOOP)I=new A.LineLoop(g,b);else if(m.mode===Ce.POINTS)I=new A.Points(g,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(I.geometry.morphAttributes).length>0&&uA(I,i),I.name=t.createUniqueName(i.name||"mesh_"+e),Oe(I,i),m.extensions&&nt(n,I,m),t.assignFinalMaterial(I),u.push(I)}for(let f=0,p=u.length;f<p;f++)t.associations.set(u[f],{meshes:e,primitives:f});if(u.length===1)return i.extensions&&nt(n,u[0],i),u[0];const d=new A.Group;i.extensions&&nt(n,d,i),t.associations.set(d,{meshes:e});for(let f=0,p=u.length;f<p;f++)d.add(u[f]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new A.PerspectiveCamera(A.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new A.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Oe(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),r=n,o=[],c=[];for(let l=0,h=r.length;l<h;l++){const u=r[l];if(u){o.push(u);const d=new A.Matrix4;i!==null&&d.fromArray(i.array,l*16),c.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new A.Skeleton(o,c)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],i=n.name?n.name:"animation_"+e,r=[],o=[],c=[],l=[],h=[];for(let u=0,d=n.channels.length;u<d;u++){const f=n.channels[u],p=n.samplers[f.sampler],g=f.target,m=g.node,I=n.parameters!==void 0?n.parameters[p.input]:p.input,b=n.parameters!==void 0?n.parameters[p.output]:p.output;g.node!==void 0&&(r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",I)),c.push(this.getDependency("accessor",b)),l.push(p),h.push(g))}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(c),Promise.all(l),Promise.all(h)]).then(function(u){const d=u[0],f=u[1],p=u[2],g=u[3],m=u[4],I=[];for(let b=0,C=d.length;b<C;b++){const y=d[b],B=f[b],v=p[b],_=g[b],x=m[b];if(y===void 0)continue;y.updateMatrix&&y.updateMatrix();const w=s._createAnimationTracks(y,B,v,_,x);if(w)for(let S=0;S<w.length;S++)I.push(w[S])}return new A.AnimationClip(i,void 0,I)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const r=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&r.traverse(function(o){if(o.isMesh)for(let c=0,l=n.weights.length;c<l;c++)o.morphTargetInfluences[c]=n.weights[c]}),r})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],i=s._loadNodeShallow(e),r=[],o=n.children||[];for(let l=0,h=o.length;l<h;l++)r.push(s.getDependency("node",o[l]));const c=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([i,Promise.all(r),c]).then(function(l){const h=l[0],u=l[1],d=l[2];d!==null&&h.traverse(function(f){f.isSkinnedMesh&&f.bind(d,pA)});for(let f=0,p=u.length;f<p;f++)h.add(u[f]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],r=i.name?n.createUniqueName(i.name):"",o=[],c=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return c&&o.push(c),i.camera!==void 0&&o.push(n.getDependency("camera",i.camera).then(function(l){return n._getNodeRef(n.cameraCache,i.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),this.nodeCache[e]=Promise.all(o).then(function(l){let h;if(i.isBone===!0?h=new A.Bone:l.length>1?h=new A.Group:l.length===1?h=l[0]:h=new A.Object3D,h!==l[0])for(let u=0,d=l.length;u<d;u++)h.add(l[u]);if(i.name&&(h.userData.name=i.name,h.name=r),Oe(h,i),i.extensions&&nt(s,h,i),i.matrix!==void 0){const u=new A.Matrix4;u.fromArray(i.matrix),h.applyMatrix4(u)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);return n.associations.has(h)||n.associations.set(h,{}),n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new A.Group;s.name&&(i.name=n.createUniqueName(s.name)),Oe(i,s),s.extensions&&nt(t,i,s);const r=s.nodes||[],o=[];for(let c=0,l=r.length;c<l;c++)o.push(n.getDependency("node",r[c]));return Promise.all(o).then(function(c){for(let h=0,u=c.length;h<u;h++)i.add(c[h]);const l=h=>{const u=new Map;for(const[d,f]of n.associations)(d instanceof A.Material||d instanceof A.Texture)&&u.set(d,f);return h.traverse(d=>{const f=n.associations.get(d);f!=null&&u.set(d,f)}),u};return n.associations=l(i),i})}_createAnimationTracks(e,t,s,n,i){const r=[],o=e.name?e.name:e.uuid,c=[];Je[i.path]===Je.weights?e.traverse(function(d){d.morphTargetInfluences&&c.push(d.name?d.name:d.uuid)}):c.push(o);let l;switch(Je[i.path]){case Je.weights:l=A.NumberKeyframeTrack;break;case Je.rotation:l=A.QuaternionKeyframeTrack;break;case Je.position:case Je.scale:l=A.VectorKeyframeTrack;break;default:switch(s.itemSize){case 1:l=A.NumberKeyframeTrack;break;case 2:case 3:default:l=A.VectorKeyframeTrack;break}break}const h=n.interpolation!==void 0?AA[n.interpolation]:A.InterpolateLinear,u=this._getArrayFromAccessor(s);for(let d=0,f=c.length;d<f;d++){const p=new l(c[d]+"."+Je[i.path],t.array,u,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(p),r.push(p)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Bn(t.constructor),n=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)n[i]=t[i]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof A.QuaternionKeyframeTrack?cA:xr;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function mA(a,e,t){const s=e.attributes,n=new A.Box3;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(n.set(new A.Vector3(c[0],c[1],c[2]),new A.Vector3(l[0],l[1],l[2])),o.normalized){const h=Bn(gt[o.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new A.Vector3,c=new A.Vector3;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],f=d.min,p=d.max;if(f!==void 0&&p!==void 0){if(c.setX(Math.max(Math.abs(f[0]),Math.abs(p[0]))),c.setY(Math.max(Math.abs(f[1]),Math.abs(p[1]))),c.setZ(Math.max(Math.abs(f[2]),Math.abs(p[2]))),d.normalized){const g=Bn(gt[d.componentType]);c.multiplyScalar(g)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}a.boundingBox=n;const r=new A.Sphere;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,a.boundingSphere=r}function vr(a,e,t){const s=e.attributes,n=[];function i(r,o){return t.getDependency("accessor",r).then(function(c){a.setAttribute(o,c)})}for(const r in s){const o=Cn[r]||r.toLowerCase();o in a.attributes||n.push(i(s[r],o))}if(e.indices!==void 0&&!a.index){const r=t.getDependency("accessor",e.indices).then(function(o){a.setIndex(o)});n.push(r)}return A.ColorManagement.workingColorSpace!==A.LinearSRGBColorSpace&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${A.ColorManagement.workingColorSpace}" not supported.`),Oe(a,e),mA(a,e,t),Promise.all(n).then(function(){return e.targets!==void 0?hA(a,e.targets,t):a})}function re(a,e,t){return a&&e in a?a[e]:t}function Sr(a){return a!=="BOOLEAN"&&a!=="STRING"&&a!=="ENUM"}function bA(a){return/^FLOAT/.test(a)}function Lt(a){return/^VEC/.test(a)}function Et(a){return/^MAT/.test(a)}function Qr(a,e,t,s=null){return Et(t)||Lt(t)?s.fromArray(a,e):a[e]}function xn(a){const{type:e,componentType:t}=a;switch(e){case"SCALAR":return t==="INT64"?0n:0;case"VEC2":return new A.Vector2;case"VEC3":return new A.Vector3;case"VEC4":return new A.Vector4;case"MAT2":return new A.Matrix2;case"MAT3":return new A.Matrix3;case"MAT4":return new A.Matrix4;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function Mr(a,e){if(e==null)return!1;switch(a){case"SCALAR":return typeof e=="number"||typeof e=="bigint";case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return typeof e=="boolean";case"STRING":return typeof e=="string";case"ENUM":return typeof e=="number"||typeof e=="bigint"}throw new Error("ClassProperty: invalid type.")}function Ft(a,e=null){switch(a){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":return Uint8Array;case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function CA(a,e=null){if(a.array){e=e&&Array.isArray(e)?e:[],e.length=a.count;for(let s=0,n=e.length;s<n;s++)e[s]=ps(a,e[s])}else e=ps(a,e);return e}function ps(a,e=null){const t=a.default,s=a.type;if(e=e||xn(a),t===null){switch(s){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":return e.identity();case"MAT3":return e.identity();case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}else if(Et(s))e.fromArray(t);else if(Lt(s))e.fromArray(t);else return t}function IA(a,e){if(a.noData===null)return e;const t=a.noData,s=a.type;if(Array.isArray(e))for(let r=0,o=e.length;r<o;r++)e[r]=n(e[r]);else e=n(e);return e;function n(r){return i(r)&&(r=ps(a,r)),r}function i(r){if(Et(s)){const o=r.elements;for(let c=0,l=t.length;c<l;c++)if(t[c]!==o[c])return!1;return!0}else if(Lt(s)){for(let o=0,c=t.length;o<c;o++)if(t[o]!==r.getComponent(o))return!1;return!0}else return t===r}}function yA(a,e){switch(a){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/9223372036854776e3,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/18446744073709552e3}}function BA(a,e){const{type:t,componentType:s,scale:n,offset:i,normalized:r}=a;if(Array.isArray(e))for(let u=0,d=e.length;u<d;u++)e[u]=o(e[u]);else e=o(e);return e;function o(u){return Et(t)?u=l(u):Lt(t)?u=c(u):u=h(u),u}function c(u){return u.x=h(u.x),u.y=h(u.y),"z"in u&&(u.z=h(u.z)),"w"in u&&(u.w=h(u.w)),u}function l(u){const d=u.elements;for(let f=0,p=d.length;f<p;f++)d[f]=h(d[f]);return u}function h(u){return r&&(u=yA(s,u)),(r||bA(s))&&(u=u*n+i),u}}function _n(a,e,t=null){if(a.array){Array.isArray(e)||(e=new Array(a.count||0)),e.length=t!==null?t:a.count;for(let s=0,n=e.length;s<n;s++)Mr(a.type,e[s])||(e[s]=xn(a))}else Mr(a.type,e)||(e=xn(a));return e}function gs(a,e){for(const t in e)t in a||delete e[t];for(const t in a){const s=a[t];e[t]=_n(s,e[t])}}function xA(a){switch(a){case"ENUM":return 1;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;case"BOOLEAN":return-1;case"STRING":return-1;default:return-1}}class ms{constructor(e,t,s=null){this.name=t.name||null,this.description=t.description||null,this.type=t.type,this.componentType=t.componentType||null,this.enumType=t.enumType||null,this.array=t.array||!1,this.count=t.count||0,this.normalized=t.normalized||!1,this.offset=t.offset||0,this.scale=re(t,"scale",1),this.max=re(t,"max",1/0),this.min=re(t,"min",-1/0),this.required=t.required||!1,this.noData=re(t,"noData",null),this.default=re(t,"default",null),this.semantic=re(t,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=re(s,"offset",this.offset),this.scale=re(s,"scale",this.scale),this.max=re(s,"max",this.max),this.min=re(s,"min",this.min)),t.type==="ENUM"&&(this.enumSet=e[this.enumType],this.componentType===null&&(this.componentType=re(this.enumSet,"valueType","UINT16")))}shapeToProperty(e,t=null){return _n(this,e,t)}resolveDefaultElement(e){return ps(this,e)}resolveDefault(e){return CA(this,e)}resolveNoData(e){return IA(this,e)}resolveEnumsToStrings(e){const t=this.enumSet;if(this.type==="ENUM")if(Array.isArray(e))for(let n=0,i=e.length;n<i;n++)e[n]=s(e[n]);else e=s(e);return e;function s(n){const i=t.values.find(r=>r.value===n);return i===null?"":i.name}}adjustValueScaleOffset(e){return Sr(this.type)?BA(this,e):e}}class wn{constructor(e,t={},s={},n=null){this.definition=e,this.class=t[e.class],this.className=e.class,this.enums=s,this.data=n,this.name="name"in e?e.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(e){return!!this.definition.properties[e]}dispose(){}_initProperties(e=ms){const t={};for(const s in this.class.properties)t[s]=new e(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=t}}class _A extends ms{constructor(e,t,s=null){super(e,t,s),this.attribute=s.attribute}}class wA extends wn{constructor(...e){super(...e),this.isPropertyAttributeAccessor=!0,this._initProperties(_A)}getData(e,t,s={}){const n=this.properties;gs(n,s);for(const i in n)s[i]=this.getPropertyValue(i,e,t,s[i]);return s}getPropertyValue(e,t,s,n=null){if(t>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const i=this.properties[e],r=i.type;if(i){if(!this.definition.properties[e])return i.resolveDefault(n)}else throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");n=i.shapeToProperty(n);const o=s.getAttribute(i.attribute.toLowerCase());if(Et(r)){const c=n.elements;for(let l=0,h=c.length;l<h;l<h)c[l]=o.getComponent(t,l)}else if(Lt(r))n.fromBufferAttribute(o,t);else if(r==="SCALAR"||r==="ENUM")n=o.getX(t);else throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");return n=i.adjustValueScaleOffset(n),n=i.resolveEnumsToStrings(n),n=i.resolveNoData(n),n}}class vA extends ms{constructor(e,t,s=null){super(e,t,s),this.values=s.values,this.valueLength=xA(this.type),this.arrayOffsets=re(s,"arrayOffsets",null),this.stringOffsets=re(s,"stringOffsets",null),this.arrayOffsetType=re(s,"arrayOffsetType","UINT32"),this.stringOffsetType=re(s,"stringOffsetType","UINT32")}getArrayLengthFromId(e,t){let s=this.count;if(this.arrayOffsets!==null){const{arrayOffsets:n,arrayOffsetType:i}=this,r=Ft(i),o=new r(e[n]);s=o[t+1]-o[t]}return s}getIndexOffsetFromId(e,t){let s=t;if(this.arrayOffsets){const{arrayOffsets:n,arrayOffsetType:i}=this,r=Ft(i);s=new r(e[n])[s]}else this.array&&(s*=this.count);return s}}class SA extends wn{constructor(...e){super(...e),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(vA)}getData(e,t={}){const s=this.properties;gs(s,t);for(const n in s)t[n]=this.getPropertyValue(n,e,t[n]);return t}_readValueAtIndex(e,t,s,n=null){const i=this.properties[e],{componentType:r,type:o}=i,c=this.data,l=c[i.values],h=Ft(r,o),u=new h(l),d=i.getIndexOffsetFromId(c,t);if(Sr(o)||o==="ENUM")return Qr(u,(d+s)*i.valueLength,o,n);if(o==="STRING"){let f=d+s,p=0;if(i.stringOffsets!==null){const{stringOffsets:m,stringOffsetType:I}=i,b=Ft(I),C=new b(c[m]);p=C[f+1]-C[f],f=C[f]}const g=new Uint8Array(u.buffer,f,p);n=new TextDecoder().decode(g)}else if(o==="BOOLEAN"){const f=d+s,p=Math.floor(f/8),g=f%8;n=(u[p]>>g&1)===1}return n}getPropertyValue(e,t,s=null){if(t>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const n=this.properties[e];if(n){if(!this.definition.properties[e])return n.resolveDefault(s)}else throw new Error("PropertyTableAccessor: Requested property does not exist.");const i=n.array,r=this.data,o=n.getArrayLengthFromId(r,t);if(s=n.shapeToProperty(s,o),i)for(let c=0,l=s.length;c<l;c++)s[c]=this._readValueAtIndex(e,t,c,s[c]);else s=this._readValueAtIndex(e,t,0,s);return s=n.adjustValueScaleOffset(s),s=n.resolveEnumsToStrings(s),s=n.resolveNoData(s),s}}const Tt=new A.Box2;class Dr{constructor(){this._renderer=new A.WebGLRenderer,this._target=new A.WebGLRenderTarget(1,1),this._texTarget=new A.WebGLRenderTarget,this._quad=new Mc(new A.ShaderMaterial({blending:A.CustomBlending,blendDst:A.ZeroFactor,blendSrc:A.OneFactor,uniforms:{map:{value:null},pixel:{value:new A.Vector2}},vertexShader:`
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,fragmentShader:`
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`}))}increaseSizeTo(e){this._target.setSize(Math.max(this._target.width,e),1)}readDataAsync(e){const{_renderer:t,_target:s}=this;return t.readRenderTargetPixelsAsync(s,0,0,e.length/4,1,e)}readData(e){const{_renderer:t,_target:s}=this;t.readRenderTargetPixels(s,0,0,e.length/4,1,e)}renderPixelToTarget(e,t,s){const{_renderer:n,_target:i}=this;Tt.min.copy(t),Tt.max.copy(t),Tt.max.x+=1,Tt.max.y+=1,n.initRenderTarget(i),n.copyTextureToTexture(e,i.texture,Tt,s,0)}}const Ye=new class{constructor(){let a=null;Object.getOwnPropertyNames(Dr.prototype).forEach(e=>{e!=="constructor"&&(this[e]=(...t)=>(a=a||new Dr,a[e](...t)))})}},Lr=new A.Vector2,Er=new A.Vector2,Fr=new A.Vector2;function QA(a,e){return e===0?a.getAttribute("uv"):a.getAttribute(`uv${e}`)}function Tr(a,e,t=new Array(3)){let s=3*e,n=3*e+1,i=3*e+2;return a.index&&(s=a.index.getX(s),n=a.index.getX(n),i=a.index.getX(i)),t[0]=s,t[1]=n,t[2]=i,t}function kr(a,e,t,s,n){const[i,r,o]=s,c=QA(a,e);Lr.fromBufferAttribute(c,i),Er.fromBufferAttribute(c,r),Fr.fromBufferAttribute(c,o),n.set(0,0,0).addScaledVector(Lr,t.x).addScaledVector(Er,t.y).addScaledVector(Fr,t.z)}function Gr(a,e,t,s){const n=a.x-Math.floor(a.x),i=a.y-Math.floor(a.y),r=Math.floor(n*e%e),o=Math.floor(i*t%t);return s.set(r,o),s}const Pr=new A.Vector2,Ur=new A.Vector2,Nr=new A.Vector2;class MA extends ms{constructor(e,t,s=null){super(e,t,s),this.channels=re(s,"channels",[0]),this.index=re(s,"index",null),this.texCoord=re(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(e,t,s=null){const n=this.type;if(n==="BOOLEAN"||n==="STRING")throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return Qr(e,t*this.valueLength,n,s)}}class DA extends wn{constructor(...e){super(...e),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(MA)}getData(e,t,s,n={}){const i=this.properties;gs(i,n);const r=Object.keys(i),o=r.map(c=>n[c]);return this.getPropertyValuesAtTexel(r,e,t,s,o),r.forEach((c,l)=>n[c]=o[l]),n}async getDataAsync(e,t,s,n={}){const i=this.properties;gs(i,n);const r=Object.keys(i),o=r.map(c=>n[c]);return await this.getPropertyValuesAtTexelAsync(r,e,t,s,o),r.forEach((c,l)=>n[c]=o[l]),n}getPropertyValuesAtTexelAsync(...e){this._asyncRead=!0;const t=this.getPropertyValuesAtTexel(...e);return this._asyncRead=!1,t}getPropertyValuesAtTexel(e,t,s,n,i=[]){for(;i.length<e.length;)i.push(null);i.length=e.length,Ye.increaseSizeTo(i.length);const r=this.data,o=this.definition.properties,c=this.properties,l=Tr(n,t);for(let d=0,f=e.length;d<f;d++){const p=e[d];if(!o[p])continue;const g=c[p],m=r[g.index];kr(n,g.texCoord,s,l,Pr),Gr(Pr,m.image.width,m.image.height,Ur),Nr.set(d,0),Ye.renderPixelToTarget(m,Ur,Nr)}const h=new Uint8Array(e.length*4);if(this._asyncRead)return Ye.readDataAsync(h).then(()=>(u.call(this),i));return Ye.readData(h),u.call(this),i;function u(){for(let d=0,f=e.length;d<f;d++){const p=e[d],g=c[p],m=g.type;if(i[d]=_n(g,i[d]),g){if(!o[p]){i[d]=g.resolveDefault(i);continue}}else throw new Error("PropertyTextureAccessor: Requested property does not exist.");const I=g.valueLength*(g.count||1),b=g.channels.map(v=>h[4*d+v]),C=g.componentType,y=Ft(C,m),B=new y(I);if(new Uint8Array(B.buffer).set(b),g.array){const v=i[d];for(let _=0,x=v.length;_<x;_++)v[_]=g.readDataFromBuffer(B,_,v[_])}else i[d]=g.readDataFromBuffer(B,0,i[d]);i[d]=g.adjustValueScaleOffset(i[d]),i[d]=g.resolveEnumsToStrings(i[d]),i[d]=g.resolveNoData(i[d])}}}dispose(){this.data.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}class Or{constructor(e,t,s,n=null,i=null){const{schema:r,propertyTables:o=[],propertyTextures:c=[],propertyAttributes:l=[]}=e,{enums:h,classes:u}=r,d=o.map(g=>new SA(g,u,h,s));let f=[],p=[];n&&(n.propertyTextures&&(f=n.propertyTextures.map(g=>new DA(c[g],u,h,t))),n.propertyAttributes&&(p=n.propertyAttributes.map(g=>new wA(l[g],u,h)))),this.schema=r,this.tableAccessors=d,this.textureAccessors=f,this.attributeAccessors=p,this.object=i,this.textures=t,this.nodeMetadata=n}getPropertyTableData(e,t,s=null){if(!Array.isArray(e)||!Array.isArray(t))s=s||{},s=this.tableAccessors[e].getData(t,s);else{s=s||[];const n=Math.min(e.length,t.length);s.length=n;for(let i=0;i<n;i++){const r=this.tableAccessors[e[i]];s[i]=r.getData(t[i],s[i])}}return s}getPropertyTableInfo(e=null){if(e===null&&(e=this.tableAccessors.map((t,s)=>s)),Array.isArray(e))return e.map(t=>{const s=this.tableAccessors[t];return{name:s.name,className:s.definition.class}});{const t=this.tableAccessors[e];return{name:t.name,className:t.definition.class}}}getPropertyTextureData(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;for(let i=0;i<n.length;i++){const r=n[i];s[i]=r.getData(e,t,this.object.geometry,s[i])}return s}async getPropertyTextureDataAsync(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;const i=[];for(let r=0;r<n.length;r++){const c=n[r].getDataAsync(e,t,this.object.geometry,s[r]).then(l=>{s[r]=l});i.push(c)}return await Promise.all(i),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(e,t=[]){const s=this.attributeAccessors;t.length=s.length;for(let n=0;n<s.length;n++){const i=s[n];t[n]=i.getData(e,this.object.geometry,t[n])}return t}getPropertyAttributeInfo(){return this.attributeAccessors.map(e=>({name:e.name,className:e.definition.class}))}dispose(){this.textureAccessors.forEach(e=>e.dispose()),this.tableAccessors.forEach(e=>e.dispose()),this.attributeAccessors.forEach(e=>e.dispose())}}const kt="EXT_structural_metadata";function LA(a,e=[]){var n;const t=((n=a.json.textures)==null?void 0:n.length)||0,s=new Array(t).fill(null);return e.forEach(({properties:i})=>{for(const r in i){const{index:o}=i[r];s[o]===null&&(s[o]=a.loadTexture(o))}}),Promise.all(s)}function EA(a,e=[]){var n;const t=((n=a.json.bufferViews)==null?void 0:n.length)||0,s=new Array(t).fill(null);return e.forEach(({properties:i})=>{for(const r in i){const{values:o,arrayOffsets:c,stringOffsets:l}=i[r];s[o]===null&&(s[o]=a.loadBufferView(o)),s[c]===null&&(s[c]=a.loadBufferView(c)),s[l]===null&&(s[l]=a.loadBufferView(l))}}),Promise.all(s)}class FA{constructor(e){this.parser=e,this.name=kt}async afterRoot({scene:e,parser:t}){const s=t.json.extensionsUsed;if(!s||!s.includes(kt))return;let n=null,i=t.json.extensions[kt];if(i.schemaUri){const{manager:l,path:h,requestHeader:u,crossOrigin:d}=t.options,f=new URL(i.schemaUri,h).toString(),p=new A.FileLoader(l);p.setCrossOrigin(d),p.setResponseType("json"),p.setRequestHeader(u),n=p.loadAsync(f).then(g=>{i={...i,schema:g}})}const[r,o]=await Promise.all([LA(t,i.propertyTextures),EA(t,i.propertyTables),n]),c=new Or(i,r,o);e.userData.structuralMetadata=c,e.traverse(l=>{if(t.associations.has(l)){const{meshes:h,primitives:u}=t.associations.get(l),d=t.json.meshes[h].primitives[u];if(d&&d.extensions&&d.extensions[kt]){const f=d.extensions[kt];l.userData.structuralMetadata=new Or(i,r,o,f,l)}else l.userData.structuralMetadata=c}})}}const Rr=new A.Vector2,Vr=new A.Vector2,zr=new A.Vector2;function TA(a){return a.x>a.y&&a.x>a.z?0:a.y>a.z?1:2}class kA{constructor(e,t,s){this.geometry=e,this.textures=t,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(n=>{const{texture:i,...r}=n,o={label:null,propertyTable:null,nullFeatureId:null,...r};return i&&(o.texture={texCoord:0,channels:[0],...i}),o})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const t=this.getFeatures(...e);return this._asyncRead=!1,t}getFeatures(e,t){const{geometry:s,textures:n,featureIds:i}=this,r=new Array(i.length).fill(null),o=i.length;Ye.increaseSizeTo(o);const c=Tr(s,e),l=c[TA(t)];for(let d=0,f=i.length;d<f;d++){const p=i[d],g="nullFeatureId"in p?p.nullFeatureId:null;if("texture"in p){const m=n[p.texture.index];kr(s,p.texture.texCoord,t,c,Rr),Gr(Rr,m.image.width,m.image.height,Vr),zr.set(d,0),Ye.renderPixelToTarget(n[p.texture.index],Vr,zr)}else if("attribute"in p){const I=s.getAttribute(`_feature_id_${p.attribute}`).getX(l);I!==g&&(r[d]=I)}else{const m=l;m!==g&&(r[d]=m)}}const h=new Uint8Array(o*4);if(this._asyncRead)return Ye.readDataAsync(h).then(()=>(u(),r));return Ye.readData(h),u(),r;function u(){const d=new Uint32Array(1);for(let f=0,p=i.length;f<p;f++){const g=i[f],m="nullFeatureId"in g?g.nullFeatureId:null;if("texture"in g){const{channels:I}=g.texture,b=I.map(y=>h[4*f+y]);new Uint8Array(d.buffer).set(b);const C=d[0];C!==m&&(r[f]=C)}}}}dispose(){this.textures.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}const bs="EXT_mesh_features";function jr(a,e,t){a.traverse(s=>{if(e.associations.has(s)){const{meshes:n,primitives:i}=e.associations.get(s),r=e.json.meshes[n].primitives[i];r&&r.extensions&&r.extensions[bs]&&t(s,r.extensions[bs])}})}class GA{constructor(e){this.parser=e,this.name=bs}async afterRoot({scene:e,parser:t}){var o;const s=t.json.extensionsUsed;if(!s||!s.includes(bs))return;const n=((o=t.json.textures)==null?void 0:o.length)||0,i=new Array(n).fill(null);jr(e,t,(c,{featureIds:l})=>{l.forEach(h=>{if(h.texture&&i[h.texture.index]===null){const u=h.texture.index;i[u]=t.loadTexture(u)}})});const r=await Promise.all(i);jr(e,t,(c,l)=>{c.userData.meshFeatures=new kA(c.geometry,r,l)})}}class PA{constructor(){this.name="CESIUM_RTC"}afterRoot(e){if(e.parser.json.extensions&&e.parser.json.extensions.CESIUM_RTC){const{center:t}=e.parser.json.extensions.CESIUM_RTC;t&&(e.scene.position.x+=t[0],e.scene.position.y+=t[1],e.scene.position.z+=t[2])}}}class UA{constructor(e){e={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...e},this.tiles=null,this.metadata=e.metadata,this.rtc=e.rtc,this.plugins=e.plugins,this.autoDispose=e.autoDispose,this.dracoLoader=e.dracoLoader,this.ktxLoader=e.ktxLoader,this.meshoptDecoder=e.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(e){const t=new Pc(e.manager);this.dracoLoader&&(t.setDRACOLoader(this.dracoLoader),e.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&t.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&t.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&t.register(()=>new PA),this.metadata&&(t.register(()=>new FA),t.register(()=>new GA)),this.plugins.forEach(s=>t.register(s)),e.manager.addHandler(this._gltfRegex,t),this.tiles=e,this._loader=t}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}disposeTile(e){const t=e.cached;t.scene&&t.scene.traverse(n=>{n.dispose&&n.dispose()})}}class NA{constructor(e={}){}init(e){e.lruCache.maxBytesSize=1/0,e.lruCache.minSize=0,e.lruCache.maxSize=1/0}}class OA{constructor(e={}){this.rootUrl="",this.urlParams=""}init(e){const{rootUrl:t}=e;t&&t.length>0&&this.setRootUrl(t)}setRootUrl(e){if(e&&e.length>0){this.rootUrl=e;const t=new URL(e);this.urlParams=t.search}}preprocessURL(e){if((!this.rootUrl||this.rootUrl.length==0)&&this.setRootUrl(e),e!=this.rootUrl&&this.urlParams&&this.urlParams.length>0){const t=new URL(e);return t.search=this.urlParams,t.toString()}return e}}const he=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function qr(){const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(he[a&255]+he[a>>8&255]+he[a>>16&255]+he[a>>24&255]+"-"+he[e&255]+he[e>>8&255]+"-"+he[e>>16&15|64]+he[e>>24&255]+"-"+he[t&63|128]+he[t>>8&255]+"-"+he[t>>16&255]+he[t>>24&255]+he[s&255]+he[s>>8&255]+he[s>>16&255]+he[s>>24&255]).toLowerCase()}let Wr=class{constructor(e){this._pendingActions=new Map,this._actionIdCounter=0,this._workerInfos=e.map(t=>({workerPromise:Promise.resolve(t),idle:!0,actionId:"",cancelAction:!1}))}dispose(){for(const e of this._workerInfos)e.workerPromise.then(t=>{t.terminate()});this._workerInfos.length=0,this._pendingActions.clear()}push(e){const t=this._generateActionId();return this._executeOnIdleWorker(t,e)||this._pendingActions.set(t,e),t}cancel(e){this._pendingActions.has(e)&&this._pendingActions.delete(e);for(const t of this._workerInfos)t.cancelAction&&(t.cancelAction=!0,t.workerPromise.then(s=>{s.terminate()}))}_generateActionId(){return qr()}_executeOnIdleWorker(e,t){for(const s of this._workerInfos)if(s.idle)return this._execute(s,e,t),!0;return!1}_execute(e,t,s){e.idle=!1,e.actionId=t,e.cancelAction=!1,e.workerPromise.then(n=>{s(n,()=>{if(e.cancelAction)n.terminate();else{this._pendingActions.delete(t);const i=this._pendingActions.entries().next().value;if(i){const[r,o]=i;this._execute(e,r,o)}else e.actionId="",e.idle=!0}})})}};const Es=class Es extends Wr{constructor(e,t,s=Es.DefaultOptions){super([]),this._maxWorkers=e,this._createWorkerAsync=t,this._options=s}push(e){const t=this._generateActionId();if(!this._executeOnIdleWorker(t,e))if(this._workerInfos.length<this._maxWorkers){const s={workerPromise:this._createWorkerAsync(),idle:!1,actionId:t,cancelAction:!1};this._workerInfos.push(s),this._execute(s,t,e)}else this._pendingActions.set(t,e);return t}_execute(e,t,s){e.timeoutId&&(clearTimeout(e.timeoutId),delete e.timeoutId),super._execute(e,t,(n,i)=>{s(n,()=>{i(),e.idle&&(e.timeoutId=setTimeout(()=>{e.workerPromise.then(o=>{o.terminate()});const r=this._workerInfos.indexOf(e);r!==-1&&this._workerInfos.splice(r,1)},this._options.idleTimeElapsedBeforeRelease))})})}};Es.DefaultOptions={idleTimeElapsedBeforeRelease:1e3};let Gt=Es;const Fs=class Fs{init(e){const t=`(${Fs._CreateWorker.toString()})(self)`,s=URL.createObjectURL(new Blob([t],{type:"application/javascript"})),n=e.downloadQueue.maxJobs;this._WorkerPool=new Gt(n,()=>{const i=new Worker(s);return Promise.resolve(i)})}async fetchData(e,t){return new Promise((s,n)=>{this._WorkerPool.push((i,r)=>{const o=l=>{i.removeEventListener("error",o),i.removeEventListener("message",c),n(l),r()},c=l=>{i.removeEventListener("error",o),i.removeEventListener("message",c);try{const{success:h,status:u,statusText:d,ok:f,data:p,error:g}=l.data;h?s(p):n({message:g})}catch(h){n({message:h})}r()};i.addEventListener("error",o),i.addEventListener("message",c),i.postMessage({url:e,options:{...t,signal:void 0}})})})}};Fs._CreateWorker=function(e){e.onmessage=async function(t){const{url:s,options:n}=t.data;try{const i=await fetch(s,n),r=s.endsWith(".json");let o;r?o=await i.json():o=await i.arrayBuffer(),e.postMessage({url:s,success:!0,status:i.status,statusText:i.statusText,ok:i.ok,data:o})}catch(i){e.postMessage({url:s,success:!1,error:i.message})}}};let vn=Fs;const Sn=new WeakMap;class RA extends A.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,n){const i=new A.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,r=>{this.parse(r,t,n)},s,n)}parse(e,t,s=()=>{}){this.decodeDracoFile(e,t,null,null,A.SRGBColorSpace,s).catch(s)}decodeDracoFile(e,t,s,n,i=A.LinearSRGBColorSpace,r=()=>{}){const o={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:i};return this.decodeGeometry(e,o).then(t).catch(r)}decodeGeometry(e,t){const s=JSON.stringify(t);if(Sn.has(e)){const c=Sn.get(e);if(c.key===s)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const i=this.workerNextTaskID++,r=e.byteLength,o=this._getWorker(i,r).then(c=>(n=c,new Promise((l,h)=>{n._callbacks[i]={resolve:l,reject:h},n.postMessage({type:"decode",id:i,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return o.catch(()=>!0).then(()=>{n&&i&&this._releaseTask(n,i)}),Sn.set(e,{key:s,promise:o}),o}_createGeometry(e){const t=new A.BufferGeometry;e.index&&t.setIndex(new A.BufferAttribute(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const n=e.attributes[s],i=n.name,r=n.array,o=n.itemSize,c=new A.BufferAttribute(r,o);i==="color"&&(this._assignVertexColorSpace(c,n.vertexColorSpace),c.normalized=!(r instanceof Float32Array)),t.setAttribute(i,c)}return t}_assignVertexColorSpace(e,t){if(t!==A.SRGBColorSpace)return;const s=new A.Color;for(let n=0,i=e.count;n<i;n++)s.fromBufferAttribute(e,n),A.ColorManagement.colorSpaceToWorking(s,A.SRGBColorSpace),e.setXYZ(n,s.r,s.g,s.b)}_loadLibrary(e,t){const s=new A.FileLoader(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((n,i)=>{s.load(e,n,void 0,i)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const n=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const i=VA.toString(),r=["/* draco decoder */",n,"","/* worker */",i.substring(i.indexOf("{")+1,i.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(i){const r=i.data;switch(r.type){case"decode":n._callbacks[r.id].resolve(r);break;case"error":n._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,i){return n._taskLoad>i._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function VA(){let a,e;onmessage=function(r){const o=r.data;switch(o.type){case"init":a=o.decoderConfig,e=new Promise(function(h){a.onModuleLoaded=function(u){h({draco:u})},DracoDecoderModule(a)});break;case"decode":const c=o.buffer,l=o.taskConfig;e.then(h=>{const u=h.draco,d=new u.Decoder;try{const f=t(u,d,new Int8Array(c),l),p=f.attributes.map(g=>g.array.buffer);f.index&&p.push(f.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:f},p)}catch(f){console.error(f),self.postMessage({type:"error",id:o.id,error:f.message})}finally{u.destroy(d)}});break}};function t(r,o,c,l){const h=l.attributeIDs,u=l.attributeTypes;let d,f;const p=o.GetEncodedGeometryType(c);if(p===r.TRIANGULAR_MESH)d=new r.Mesh,f=o.DecodeArrayToMesh(c,c.byteLength,d);else if(p===r.POINT_CLOUD)d=new r.PointCloud,f=o.DecodeArrayToPointCloud(c,c.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!f.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+f.error_msg());const g={index:null,attributes:[]};for(const m in h){const I=self[u[m]];let b,C;if(l.useUniqueIDs)C=h[m],b=o.GetAttributeByUniqueId(d,C);else{if(C=o.GetAttributeId(d,r[h[m]]),C===-1)continue;b=o.GetAttribute(d,C)}const y=n(r,o,d,m,I,b);m==="color"&&(y.vertexColorSpace=l.vertexColorSpace),g.attributes.push(y)}return p===r.TRIANGULAR_MESH&&(g.index=s(r,o,d)),r.destroy(d),g}function s(r,o,c){const h=c.num_faces()*3,u=h*4,d=r._malloc(u);o.GetTrianglesUInt32Array(c,u,d);const f=new Uint32Array(r.HEAPF32.buffer,d,h).slice();return r._free(d),{array:f,itemSize:1}}function n(r,o,c,l,h,u){const d=u.num_components(),p=c.num_points()*d,g=p*h.BYTES_PER_ELEMENT,m=i(r,h),I=r._malloc(g);o.GetAttributeDataArrayForAllPoints(c,u,m,g,I);const b=new h(r.HEAPF32.buffer,I,p).slice();return r._free(I),{name:l,array:b,itemSize:d}}function i(r,o){switch(o){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}class zA{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0,this.workerCreator=null}_initWorker(e){if(!this.workers[e]){const t=this.workerCreator();t.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=t}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,t){const s=this.workersResolve[e];if(s&&s(t),this.queue.length){const{resolve:n,msg:i,transfer:r}=this.queue.shift();this.workersResolve[e]=n,this.workers[e].postMessage(i,r)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,t){return new Promise(s=>{const n=this._getIdleWorker();n!==-1?(this._initWorker(n),this.workerStatus|=1<<n,this.workersResolve[n]=s,this.workers[n].postMessage(e,t)):this.queue.push({resolve:s,msg:e,transfer:t})})}dispose(){this.workers.forEach(e=>e.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const jA=0,Kr=2,qA=1,Jr=2,WA=0,KA=1,JA=10,YA=0,Yr=9,Xr=15,Zr=16,$r=22,Hr=37,ea=43,ta=76,sa=83,na=97,ia=100,ra=103,aa=109,XA=131,ZA=132,$A=133,HA=134,el=137,tl=138,sl=141,nl=142,il=145,rl=146,oa=148,ca=152,al=157,ol=158,Aa=165,la=166,Qn=1000066e3;class cl{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class Pt{constructor(e,t,s,n){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(e.buffer,e.byteOffset+t,s),this._littleEndian=n,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,e);return this._offset+=e,t}_skip(e){return this._offset+=e,this}_scan(e,t){t===void 0&&(t=0);const s=this._offset;let n=0;for(;this._dataView.getUint8(this._offset)!==t&&n<e;)n++,this._offset++;return n<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+s,n)}}const ue=[171,75,84,88,32,50,48,187,13,10,26,10];function ha(a){return new TextDecoder().decode(a)}function Al(a){const e=new Uint8Array(a.buffer,a.byteOffset,ue.length);if(e[0]!==ue[0]||e[1]!==ue[1]||e[2]!==ue[2]||e[3]!==ue[3]||e[4]!==ue[4]||e[5]!==ue[5]||e[6]!==ue[6]||e[7]!==ue[7]||e[8]!==ue[8]||e[9]!==ue[9]||e[10]!==ue[10]||e[11]!==ue[11])throw new Error("Missing KTX 2.0 identifier.");const t=new cl,s=17*Uint32Array.BYTES_PER_ELEMENT,n=new Pt(a,ue.length,s,!0);t.vkFormat=n._nextUint32(),t.typeSize=n._nextUint32(),t.pixelWidth=n._nextUint32(),t.pixelHeight=n._nextUint32(),t.pixelDepth=n._nextUint32(),t.layerCount=n._nextUint32(),t.faceCount=n._nextUint32();const i=n._nextUint32();t.supercompressionScheme=n._nextUint32();const r=n._nextUint32(),o=n._nextUint32(),c=n._nextUint32(),l=n._nextUint32(),h=n._nextUint64(),u=n._nextUint64(),d=new Pt(a,ue.length+s,3*i*8,!0);for(let M=0;M<i;M++)t.levels.push({levelData:new Uint8Array(a.buffer,a.byteOffset+d._nextUint64(),d._nextUint64()),uncompressedByteLength:d._nextUint64()});const f=new Pt(a,r,o,!0),p={vendorId:f._skip(4)._nextUint16(),descriptorType:f._nextUint16(),versionNumber:f._nextUint16(),descriptorBlockSize:f._nextUint16(),colorModel:f._nextUint8(),colorPrimaries:f._nextUint8(),transferFunction:f._nextUint8(),flags:f._nextUint8(),texelBlockDimension:[f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8()],bytesPlane:[f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8()],samples:[]},g=(p.descriptorBlockSize/4-6)/4;for(let M=0;M<g;M++){const j={bitOffset:f._nextUint16(),bitLength:f._nextUint8(),channelType:f._nextUint8(),samplePosition:[f._nextUint8(),f._nextUint8(),f._nextUint8(),f._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&j.channelType?(j.sampleLower=f._nextInt32(),j.sampleUpper=f._nextInt32()):(j.sampleLower=f._nextUint32(),j.sampleUpper=f._nextUint32()),p.samples[M]=j}t.dataFormatDescriptor.length=0,t.dataFormatDescriptor.push(p);const m=new Pt(a,c,l,!0);for(;m._offset<l;){const M=m._nextUint32(),j=m._scan(M),q=ha(j);if(t.keyValue[q]=m._nextUint8Array(M-j.byteLength-1),q.match(/^ktx/i)){const z=ha(t.keyValue[q]);t.keyValue[q]=z.substring(0,z.lastIndexOf("\0"))}m._skip(M%4?4-M%4:0)}if(u<=0)return t;const I=new Pt(a,h,u,!0),b=I._nextUint16(),C=I._nextUint16(),y=I._nextUint32(),B=I._nextUint32(),v=I._nextUint32(),_=I._nextUint32(),x=[];for(let M=0;M<i;M++)x.push({imageFlags:I._nextUint32(),rgbSliceByteOffset:I._nextUint32(),rgbSliceByteLength:I._nextUint32(),alphaSliceByteOffset:I._nextUint32(),alphaSliceByteLength:I._nextUint32()});const w=h+I._offset,S=w+y,Q=S+B,E=Q+v,N=new Uint8Array(a.buffer,a.byteOffset+w,y),k=new Uint8Array(a.buffer,a.byteOffset+S,B),O=new Uint8Array(a.buffer,a.byteOffset+Q,v),P=new Uint8Array(a.buffer,a.byteOffset+E,_);return t.globalData={endpointCount:b,selectorCount:C,imageDescs:x,endpointsData:N,selectorsData:k,tablesData:O,extendedData:P},t}let Mn,Re,Dn;const Ln={env:{emscripten_notify_memory_growth:function(a){Dn=new Uint8Array(Re.exports.memory.buffer)}}};class ll{init(){return Mn||(Mn=typeof fetch<"u"?fetch("data:application/wasm;base64,"+ua).then(e=>e.arrayBuffer()).then(e=>WebAssembly.instantiate(e,Ln)).then(this._init):WebAssembly.instantiate(Buffer.from(ua,"base64"),Ln).then(this._init),Mn)}_init(e){Re=e.instance,Ln.env.emscripten_notify_memory_growth(0)}decode(e,t=0){if(!Re)throw new Error("ZSTDDecoder: Await .init() before decoding.");const s=e.byteLength,n=Re.exports.malloc(s);Dn.set(e,n),t=t||Number(Re.exports.ZSTD_findDecompressedSize(n,s));const i=Re.exports.malloc(t),r=Re.exports.ZSTD_decompress(i,t,n,s),o=Dn.slice(i,i+r);return Re.exports.free(n),Re.exports.free(i),o}}const ua="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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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",hl="display-p3",ul="display-p3-linear",En=new WeakMap;let Fn=0,Tn;class Ie extends A.Loader{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new zA,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}async detectSupportAsync(e){return this.workerConfig={astcSupported:await e.hasFeatureAsync("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:await e.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await e.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await e.hasFeatureAsync("texture-compression-bc"),bptcSupported:await e.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await e.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(e){return e.isWebGPURenderer===!0?this.workerConfig={astcSupported:e.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:e.hasFeature("texture-compression-etc1"),etc2Supported:e.hasFeature("texture-compression-etc2"),dxtSupported:e.hasFeature("texture-compression-bc"),bptcSupported:e.hasFeature("texture-compression-bptc"),pvrtcSupported:e.hasFeature("texture-compression-pvrtc")}:this.workerConfig={astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:e.extensions.has("WEBGL_compressed_texture_astc")&&e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const e=new A.FileLoader(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const t=e.loadAsync("basis_transcoder.js"),s=new A.FileLoader(this.manager);s.setPath(this.transcoderPath),s.setResponseType("arraybuffer"),s.setWithCredentials(this.withCredentials);const n=s.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([t,n]).then(([i,r])=>{const o=Ie.BasisWorker.toString(),c=["/* constants */","let _EngineFormat = "+JSON.stringify(Ie.EngineFormat),"let _EngineType = "+JSON.stringify(Ie.EngineType),"let _TranscoderFormat = "+JSON.stringify(Ie.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(Ie.BasisFormat),"/* basis_transcoder.js */",i,"/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([c])),this.transcoderBinary=r,this.workerPool.setWorkerCreator(()=>{const l=new Worker(this.workerSourceURL),h=this.transcoderBinary.slice(0);return l.postMessage({type:"init",config:this.workerConfig,transcoderBinary:h},[h]),l})}),Fn>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),Fn++}return this.transcoderPending}load(e,t,s,n){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const i=new A.FileLoader(this.manager);i.setPath(this.path),i.setCrossOrigin(this.crossOrigin),i.setWithCredentials(this.withCredentials),i.setResponseType("arraybuffer"),i.load(e,r=>{this.parse(r,t,n)},s,n)}parse(e,t,s){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(En.has(e))return En.get(e).promise.then(t).catch(s);this._createTexture(e).then(n=>t?t(n):null).catch(s)}_createTextureFrom(e,t){const{type:s,error:n,data:{faces:i,width:r,height:o,format:c,type:l,dfdFlags:h}}=e;if(s==="error")return Promise.reject(n);let u;if(t.faceCount===6)u=new A.CompressedCubeTexture(i,c,l);else{const d=i[0].mipmaps;u=t.layerCount>1?new A.CompressedArrayTexture(d,r,o,t.layerCount,c,l):new A.CompressedTexture(d,r,o,c,l)}return u.minFilter=i[0].mipmaps.length===1?A.LinearFilter:A.LinearMipmapLinearFilter,u.magFilter=A.LinearFilter,u.generateMipmaps=!1,u.needsUpdate=!0,u.colorSpace=da(t),u.premultiplyAlpha=!!(h&qA),u}async _createTexture(e,t={}){const s=Al(new Uint8Array(e)),n=s.vkFormat===Qn&&s.dataFormatDescriptor[0].colorModel===167;if(!(s.vkFormat===YA||n&&!this.workerConfig.astcHDRSupported))return fl(s);const r=t,o=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffer:e,taskConfig:r},[e])).then(c=>this._createTextureFrom(c.data,s));return En.set(e,{promise:o}),o}dispose(){this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),Fn--}}Ie.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2},Ie.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25},Ie.EngineFormat={RGBAFormat:A.RGBAFormat,RGBA_ASTC_4x4_Format:A.RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format:A.RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format:A.RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:A.RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:A.RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:A.RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:A.RGB_ETC1_Format,RGB_ETC2_Format:A.RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:A.RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:A.RGBA_S3TC_DXT1_Format},Ie.EngineType={UnsignedByteType:A.UnsignedByteType,HalfFloatType:A.HalfFloatType,FloatType:A.FloatType},Ie.BasisWorker=function(){let a,e,t;const s=_EngineFormat,n=_EngineType,i=_TranscoderFormat,r=_BasisFormat;self.addEventListener("message",function(p){const g=p.data;switch(g.type){case"init":a=g.config,o(g.transcoderBinary);break;case"transcode":e.then(()=>{try{const{faces:m,buffers:I,width:b,height:C,hasAlpha:y,format:B,type:v,dfdFlags:_}=c(g.buffer);self.postMessage({type:"transcode",id:g.id,data:{faces:m,width:b,height:C,hasAlpha:y,format:B,type:v,dfdFlags:_}},I)}catch(m){console.error(m),self.postMessage({type:"error",id:g.id,error:m.message})}});break}});function o(p){e=new Promise(g=>{t={wasmBinary:p,onRuntimeInitialized:g},BASIS(t)}).then(()=>{t.initializeBasis(),t.KTX2File===void 0&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")})}function c(p){const g=new t.KTX2File(new Uint8Array(p));function m(){g.close(),g.delete()}if(!g.isValid())throw m(),new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");let I;if(g.isUASTC())I=r.UASTC;else if(g.isETC1S())I=r.ETC1S;else if(g.isHDR())I=r.UASTC_HDR;else throw new Error("THREE.KTX2Loader: Unknown Basis encoding");const b=g.getWidth(),C=g.getHeight(),y=g.getLayers()||1,B=g.getLevels(),v=g.getFaces(),_=g.getHasAlpha(),x=g.getDFDFlags(),{transcoderFormat:w,engineFormat:S,engineType:Q}=u(I,b,C,_);if(!b||!C||!B)throw m(),new Error("THREE.KTX2Loader:	Invalid texture");if(!g.startTranscoding())throw m(),new Error("THREE.KTX2Loader: .startTranscoding failed");const E=[],N=[];for(let k=0;k<v;k++){const O=[];for(let P=0;P<B;P++){const M=[];let j,q;for(let Z=0;Z<y;Z++){const X=g.getImageLevelInfo(P,Z,k);k===0&&P===0&&Z===0&&(X.origWidth%4!==0||X.origHeight%4!==0)&&console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),B>1?(j=X.origWidth,q=X.origHeight):(j=X.width,q=X.height);let $=new Uint8Array(g.getImageTranscodedSizeInBytes(P,Z,0,w));const de=g.transcodeImage($,P,Z,k,w,0,-1,-1);if(Q===n.HalfFloatType&&($=new Uint16Array($.buffer,$.byteOffset,$.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!de)throw m(),new Error("THREE.KTX2Loader: .transcodeImage failed.");M.push($)}const z=f(M);O.push({data:z,width:j,height:q}),N.push(z.buffer)}E.push({mipmaps:O,width:b,height:C,format:S,type:Q})}return m(),{faces:E,buffers:N,width:b,height:C,hasAlpha:_,dfdFlags:x,format:S,type:Q}}const l=[{if:"astcSupported",basisFormat:[r.UASTC],transcoderFormat:[i.ASTC_4x4,i.ASTC_4x4],engineFormat:[s.RGBA_ASTC_4x4_Format,s.RGBA_ASTC_4x4_Format],engineType:[n.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.BC7_M5,i.BC7_M5],engineFormat:[s.RGBA_BPTC_Format,s.RGBA_BPTC_Format],engineType:[n.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.BC1,i.BC3],engineFormat:[s.RGBA_S3TC_DXT1_Format,s.RGBA_S3TC_DXT5_Format],engineType:[n.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.ETC1,i.ETC2],engineFormat:[s.RGB_ETC2_Format,s.RGBA_ETC2_EAC_Format],engineType:[n.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.ETC1],engineFormat:[s.RGB_ETC1_Format],engineType:[n.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.PVRTC1_4_RGB,i.PVRTC1_4_RGBA],engineFormat:[s.RGB_PVRTC_4BPPV1_Format,s.RGBA_PVRTC_4BPPV1_Format],engineType:[n.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[r.UASTC_HDR],transcoderFormat:[i.BC6H],engineFormat:[s.RGB_BPTC_UNSIGNED_Format],engineType:[n.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[r.ETC1S,r.UASTC],transcoderFormat:[i.RGBA32,i.RGBA32],engineFormat:[s.RGBAFormat,s.RGBAFormat],engineType:[n.UnsignedByteType,n.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[r.UASTC_HDR],transcoderFormat:[i.RGBA_HALF],engineFormat:[s.RGBAFormat],engineType:[n.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],h={[r.ETC1S]:l.filter(p=>p.basisFormat.includes(r.ETC1S)).sort((p,g)=>p.priorityUASTC-g.priorityUASTC),[r.UASTC]:l.filter(p=>p.basisFormat.includes(r.UASTC)).sort((p,g)=>p.priorityUASTC-g.priorityUASTC),[r.UASTC_HDR]:l.filter(p=>p.basisFormat.includes(r.UASTC_HDR)).sort((p,g)=>p.priorityHDR-g.priorityHDR)};function u(p,g,m,I){const b=h[p];for(let C=0;C<b.length;C++){const y=b[C];if(y.if&&!a[y.if]||!y.basisFormat.includes(p)||I&&y.transcoderFormat.length<2||y.needsPowerOfTwo&&!(d(g)&&d(m)))continue;const B=y.transcoderFormat[I?1:0],v=y.engineFormat[I?1:0],_=y.engineType[0];return{transcoderFormat:B,engineFormat:v,engineType:_}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")}function d(p){return p<=2?!0:(p&p-1)===0&&p!==0}function f(p){if(p.length===1)return p[0];let g=0;for(let b=0;b<p.length;b++){const C=p[b];g+=C.byteLength}const m=new Uint8Array(g);let I=0;for(let b=0;b<p.length;b++){const C=p[b];m.set(C,I),I+=C.byteLength}return m}};const dl=new Set([A.RGBAFormat,A.RGFormat,A.RedFormat]),kn={[aa]:A.RGBAFormat,[na]:A.RGBAFormat,[Hr]:A.RGBAFormat,[ea]:A.RGBAFormat,[ra]:A.RGFormat,[sa]:A.RGFormat,[Zr]:A.RGFormat,[$r]:A.RGFormat,[ia]:A.RedFormat,[ta]:A.RedFormat,[Xr]:A.RedFormat,[Yr]:A.RedFormat,[oa]:A.RGB_ETC2_Format,[ca]:A.RGBA_ETC2_EAC_Format,[Qn]:A.RGBA_ASTC_4x4_Format,[ol]:A.RGBA_ASTC_4x4_Format,[al]:A.RGBA_ASTC_4x4_Format,[la]:A.RGBA_ASTC_6x6_Format,[Aa]:A.RGBA_ASTC_6x6_Format,[$A]:A.RGBA_S3TC_DXT1_Format,[HA]:A.RGBA_S3TC_DXT1_Format,[XA]:A.RGB_S3TC_DXT1_Format,[ZA]:A.RGB_S3TC_DXT1_Format,[tl]:A.RGBA_S3TC_DXT3_Format,[el]:A.RGBA_S3TC_DXT3_Format,[nl]:A.RGBA_S3TC_DXT5_Format,[sl]:A.RGBA_S3TC_DXT5_Format,[rl]:A.RGBA_BPTC_Format,[il]:A.RGBA_BPTC_Format},Gn={[aa]:A.FloatType,[na]:A.HalfFloatType,[Hr]:A.UnsignedByteType,[ea]:A.UnsignedByteType,[ra]:A.FloatType,[sa]:A.HalfFloatType,[Zr]:A.UnsignedByteType,[$r]:A.UnsignedByteType,[ia]:A.FloatType,[ta]:A.HalfFloatType,[Xr]:A.UnsignedByteType,[Yr]:A.UnsignedByteType,[oa]:A.UnsignedByteType,[ca]:A.UnsignedByteType,[Qn]:A.HalfFloatType,[la]:A.UnsignedByteType,[Aa]:A.UnsignedByteType};async function fl(a){const{vkFormat:e}=a;if(kn[e]===void 0)throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let t;a.supercompressionScheme===Kr&&(Tn||(Tn=new Promise(async i=>{const r=new ll;await r.init(),i(r)})),t=await Tn);const s=[];for(let i=0;i<a.levels.length;i++){const r=Math.max(1,a.pixelWidth>>i),o=Math.max(1,a.pixelHeight>>i),c=a.pixelDepth?Math.max(1,a.pixelDepth>>i):0,l=a.levels[i];let h;if(a.supercompressionScheme===jA)h=l.levelData;else if(a.supercompressionScheme===Kr)h=t.decode(l.levelData,l.uncompressedByteLength);else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");let u;Gn[e]===A.FloatType?u=new Float32Array(h.buffer,h.byteOffset,h.byteLength/Float32Array.BYTES_PER_ELEMENT):Gn[e]===A.HalfFloatType?u=new Uint16Array(h.buffer,h.byteOffset,h.byteLength/Uint16Array.BYTES_PER_ELEMENT):u=h,s.push({data:u,width:r,height:o,depth:c})}let n;if(dl.has(kn[e]))n=a.pixelDepth===0?new A.DataTexture(s[0].data,a.pixelWidth,a.pixelHeight):new A.Data3DTexture(s[0].data,a.pixelWidth,a.pixelHeight,a.pixelDepth);else{if(a.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");n=new A.CompressedTexture(s,a.pixelWidth,a.pixelHeight),n.minFilter=s.length===1?A.LinearFilter:A.LinearMipmapLinearFilter,n.magFilter=A.LinearFilter}return n.mipmaps=s,n.type=Gn[e],n.format=kn[e],n.colorSpace=da(a),n.needsUpdate=!0,Promise.resolve(n)}function da(a){const e=a.dataFormatDescriptor[0];return e.colorPrimaries===KA?e.transferFunction===Jr?A.SRGBColorSpace:A.LinearSRGBColorSpace:e.colorPrimaries===JA?e.transferFunction===Jr?hl:ul:(e.colorPrimaries===WA||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`),A.NoColorSpace)}var fa=function(){var a="b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",e="b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb",t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),s=new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);if(typeof WebAssembly!="object")return{supported:!1};var n=WebAssembly.validate(t)?e:a,i,r=WebAssembly.instantiate(o(n),{}).then(function(I){i=I.instance,i.exports.__wasm_call_ctors()});function o(I){for(var b=new Uint8Array(I.length),C=0;C<I.length;++C){var y=I.charCodeAt(C);b[C]=y>96?y-97:y>64?y-39:y+4}for(var B=0,C=0;C<I.length;++C)b[B++]=b[C]<60?s[b[C]]:(b[C]-60)*64+b[++C];return b.buffer.slice(0,B)}function c(I,b,C,y,B,v){var _=i.exports.sbrk,x=C+3&-4,w=_(x*y),S=_(B.length),Q=new Uint8Array(i.exports.memory.buffer);Q.set(B,S);var E=I(w,C,y,S,B.length);if(E==0&&v&&v(w,x,y),b.set(Q.subarray(w,w+C*y)),_(w-_(0)),E!=0)throw new Error("Malformed buffer data: "+E)}var l={NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},h={ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"},u=[],d=0;function f(I){var b={object:new Worker(I),pending:0,requests:{}};return b.object.onmessage=function(C){var y=C.data;b.pending-=y.count,b.requests[y.id][y.action](y.value),delete b.requests[y.id]},b}function p(I){for(var b="var instance; var ready = WebAssembly.instantiate(new Uint8Array(["+new Uint8Array(o(n))+"]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;"+c.toString()+m.toString(),C=new Blob([b],{type:"text/javascript"}),y=URL.createObjectURL(C),B=0;B<I;++B)u[B]=f(y);URL.revokeObjectURL(y)}function g(I,b,C,y,B){for(var v=u[0],_=1;_<u.length;++_)u[_].pending<v.pending&&(v=u[_]);return new Promise(function(x,w){var S=new Uint8Array(C),Q=d++;v.pending+=I,v.requests[Q]={resolve:x,reject:w},v.object.postMessage({id:Q,count:I,size:b,source:S,mode:y,filter:B},[S.buffer])})}function m(I){r.then(function(){var b=I.data;try{var C=new Uint8Array(b.count*b.size);c(i.exports[b.mode],C,b.count,b.size,b.source,i.exports[b.filter]),self.postMessage({id:b.id,count:b.count,action:"resolve",value:C},[C.buffer])}catch(y){self.postMessage({id:b.id,count:b.count,action:"reject",value:y})}})}return{ready:r,supported:!0,useWorkers:function(I){p(I)},decodeVertexBuffer:function(I,b,C,y,B){c(i.exports.meshopt_decodeVertexBuffer,I,b,C,y,i.exports[l[B]])},decodeIndexBuffer:function(I,b,C,y){c(i.exports.meshopt_decodeIndexBuffer,I,b,C,y)},decodeIndexSequence:function(I,b,C,y){c(i.exports.meshopt_decodeIndexSequence,I,b,C,y)},decodeGltfBuffer:function(I,b,C,y,B,v){c(i.exports[h[B]],I,b,C,y,i.exports[l[v]])},decodeGltfBufferAsync:function(I,b,C,y,B){return u.length>0?g(I,b,C,h[y],l[B]):r.then(function(){var v=new Uint8Array(I*b);return c(i.exports[h[y]],v,I,b,C,i.exports[l[B]]),v})}}}();const Ts=class Ts{static getDracoLoader(e){if(!this._dracoLoader){e=e||"https://unpkg.com/three@0.173.0/examples/jsm/libs/draco/gltf/";const t=new RA;t.setDecoderPath(e),this._dracoLoader=t}return this._dracoLoader}static getKtxLoader(e){if(!this._ktx2Loader){e=e||"https://unpkg.com/three@0.173.0/examples/jsm/libs/basis/";const t=new Ie;t.setTranscoderPath(e),this._ktx2Loader=t}return this._ktx2Loader}static getMeshoptDecoder(e){return e||fa}};Ts._dracoLoader=null,Ts._ktx2Loader=null;let it=Ts;class Xe extends A.Object3D{constructor(){super(),this._scene=void 0,this._parentObjectName="unknown";const e=this;this.onSceneUpdate=function(s){e.updateSceneTime(s.time,s.delta)},this.onSceneRecenter=function(s){e.updateSceneTransform()}}getOrAddParentObject(){const e=this._scene.getSceneRoot();return this._parentObject=e.getObjectByName(this._parentObjectName),this._parentObject||(this._parentObject=new A.Group,this._parentObject.name=this._parentObjectName,e.add(this._parentObject)),this._parentObject}addToScene(e){return this._scene=e,this._scene.addEventListener(ht,this.onSceneUpdate),this._scene.addEventListener(Kt,this.onSceneRecenter),this.getOrAddParentObject().add(this),this.updateSceneTransform(),this}removeFromScene(){return this._scene===void 0?this:(this.getOrAddParentObject().remove(this),this._scene.removeEventListener(Kt,this.onSceneRecenter),this._scene.removeEventListener(ht,this.onSceneUpdate),this._scene=void 0,this)}updateSceneTime(e,t){}updateSceneTransform(){}remove(...e){return this._scene!==void 0&&(e===void 0||e.length===0)?(this.removeFromScene(),this):super.remove(...e)}}const Wt=class Wt extends A.Object3D{constructor(){super(...arguments),this.isGaussianSplattingScene=!0,this.lineStart=0,this.lineCount=0,this.lineWidth=1,this.vertexCount=0,this.splatPositions=null,this.splatCovA=null,this.splatCovB=null,this.splatColors=null,this.needSort=!1,this.needRemove=!1,this.readyToRender=!1,this.geometry=null}};Wt.useRGBACovariants=!0,Wt.covBSItemSize=Wt.useRGBACovariants?4:2;let Se=Wt;const pa="KHR_gaussian_splatting",pl={POSITION:"position",COLOR_0:"color",_SCALE:"scale",_ROTATION:"rotation",_OPACITY:"opacity"},ga={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};let gl=class{constructor(e,t){this.parser=e,this.camera=t,this.name=pa}loadMesh(e){const t=this.parser;this.camera;const s=t.json.extensionsUsed;if(!s||!s.includes(pa))return;const r=t.json.meshes[e].primitives,o=[];return o.push(this.loadGeometries(r)),Promise.all(o).then(function(c){const l=c[c.length-1],h=[];function u(d,f){const p=new Se;return p.geometry=d,new Promise(g=>{g(p)})}for(let d=0,f=l.length;d<f;d++){const p=l[d];h.push(u(p))}return Promise.all(h).then(d=>{const f=new A.Group;for(let p=0,g=d.length;p<g;p++){const m=d[p];f.add(m)}return t.associations.set(f,{meshes:e}),f})})}loadGeometries(e){const t=this.parser,s=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];let o=this.addPrimitiveAttributes(new A.BufferGeometry,r,t);s.push(o)}return Promise.all(s)}addPrimitiveAttributes(e,t,s){const n=t.attributes,i=[];function r(o,c){return s.getDependency("accessor",o).then(function(l){e.setAttribute(c,l)})}for(const o in n){const c=pl[o]||o.toLowerCase();c in e.attributes||i.push(r(n[o],c))}if(t.indices!==void 0&&!e.index){const o=s.getDependency("accessor",t.indices).then(function(c){e.setIndex(c)});i.push(o)}return ml(e,t,s),Promise.all(i).then(function(){return e})}};function ml(a,e,t){const s=e.attributes,n=new A.Box3;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(n.set(new A.Vector3(c[0],c[1],c[2]),new A.Vector3(l[0],l[1],l[2])),o.normalized){const h=ma(ga[o.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new A.Vector3,c=new A.Vector3;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],f=d.min,p=d.max;if(f!==void 0&&p!==void 0){if(c.setX(Math.max(Math.abs(f[0]),Math.abs(p[0]))),c.setY(Math.max(Math.abs(f[1]),Math.abs(p[1]))),c.setZ(Math.max(Math.abs(f[2]),Math.abs(p[2]))),d.normalized){const g=ma(ga[d.componentType]);c.multiplyScalar(g)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}a.boundingBox=n;const r=new A.Sphere;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,a.boundingSphere=r}function ma(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}let ba=class{static build(e=1,t=!1){const s=new A.BufferGeometry;if(t){s.setIndex([0,1,2,0,2,3]);const o=new Float32Array(4*3),c=new A.BufferAttribute(o,3);s.setAttribute("position",c),c.setXYZ(0,-2,-2,0),c.setXYZ(1,-2,2,0),c.setXYZ(2,2,2,0),c.setXYZ(3,2,-2,0),c.needsUpdate=!0}else{s.setIndex([0,1,2]);const o=new Float32Array(3*3),c=new A.BufferAttribute(o,3);s.setAttribute("position",c),c.setXYZ(0,-3,-2,0),c.setXYZ(1,3,-2,0),c.setXYZ(2,0,4,0),c.needsUpdate=!0}const n=new A.InstancedBufferGeometry().copy(s),i=new Float32Array(e);for(let o=0;o<e;o++)i[o]=o;const r=new A.InstancedBufferAttribute(i,1,!1);return r.setUsage(A.DynamicDrawUsage),n.setAttribute("splatIndex",r),n.instanceCount=0,n}};const bl=`
precision highp float;

#include <common>

// Attributes
attribute float splatIndex;
// attribute uint sceneIndex;

// Uniforms
uniform vec2 invViewport;
uniform vec2 dataTextureSize;
uniform vec2 focal;

uniform sampler2D covariancesATexture;
uniform sampler2D covariancesBTexture;
uniform sampler2D centersTexture;
uniform sampler2D colorsTexture;

#if SH_DEGREE > 0
uniform highp usampler2D shTexture0;
#endif
#if SH_DEGREE > 1
uniform highp usampler2D shTexture1;
#endif
#if SH_DEGREE > 2
uniform highp usampler2D shTexture2;
#endif

// Output
varying vec4 vColor;
varying vec2 vPosition;

mat3 transposeMatrix(mat3 matrix) {
    return mat3(matrix[0][0], matrix[1][0], matrix[2][0],
        matrix[0][1], matrix[1][1], matrix[2][1],
        matrix[0][2], matrix[1][2], matrix[2][2]);
}

vec2 getDataUV(float index, vec2 textureSize) {
    float y = floor(index / textureSize.x);
    float x = index - y * textureSize.x;
    return vec2((x + 0.5) / textureSize.x, (y + 0.5) / textureSize.y);
}

#if SH_DEGREE > 0
ivec2 getDataUVint(float index, vec2 textureSize) {
    float y = floor(index / textureSize.x);
    float x = index - y * textureSize.x;
    return ivec2(uint(x + 0.5), uint(y + 0.5));
}
#endif

struct Splat {
    vec4 center;
    vec4 color;
    vec4 covA;
    vec4 covB;
#if SH_DEGREE > 0
    uvec4 sh0; // 4 * 32bits uint
#endif
#if SH_DEGREE > 1
    uvec4 sh1;
#endif
#if SH_DEGREE > 2
    uvec4 sh2;
#endif
};

Splat readSplat(float splatIndex)
{
    Splat splat;
    vec2 splatUV = getDataUV(splatIndex, dataTextureSize);
    splat.center = texture2D(centersTexture, splatUV);
    splat.color = texture2D(colorsTexture, splatUV);
    splat.covA = texture2D(covariancesATexture, splatUV) * splat.center.w;
    splat.covB = texture2D(covariancesBTexture, splatUV) * splat.center.w;
#if SH_DEGREE > 0
    ivec2 splatUVint = getDataUVint(splatIndex, dataTextureSize);
    splat.sh0 = texelFetch(shTexture0, splatUVint, 0);
#endif
#if SH_DEGREE > 1
    splat.sh1 = texelFetch(shTexture1, splatUVint, 0);
#endif
#if SH_DEGREE > 2
    splat.sh2 = texelFetch(shTexture2, splatUVint, 0);
#endif

    return splat;
}
    
// no SH for GS and WebGL1
// dir = normalized(splat pos - cam pos)
vec3 computeColorFromSHDegree(vec3 dir, const vec3 sh[16])
{
    const float SH_C0 = 0.28209479;
    const float SH_C1 = 0.48860251;
    float SH_C2[5];
    SH_C2[0] = 1.092548430;
    SH_C2[1] = -1.09254843;
    SH_C2[2] = 0.315391565;
    SH_C2[3] = -1.09254843;
    SH_C2[4] = 0.546274215;
    
    float SH_C3[7];
    SH_C3[0] = -0.59004358;
    SH_C3[1] = 2.890611442;
    SH_C3[2] = -0.45704579;
    SH_C3[3] = 0.373176332;
    SH_C3[4] = -0.45704579;
    SH_C3[5] = 1.445305721;
    SH_C3[6] = -0.59004358;

	vec3 result = /*SH_C0 * */sh[0];

#if SH_DEGREE > 0
    float x = dir.x;
    float y = dir.y;
    float z = dir.z;
    result += - SH_C1 * y * sh[1] + SH_C1 * z * sh[2] - SH_C1 * x * sh[3];

#if SH_DEGREE > 1
    float xx = x * x, yy = y * y, zz = z * z;
    float xy = x * y, yz = y * z, xz = x * z;
    result += 
        SH_C2[0] * xy * sh[4] +
        SH_C2[1] * yz * sh[5] +
        SH_C2[2] * (2.0f * zz - xx - yy) * sh[6] +
        SH_C2[3] * xz * sh[7] +
        SH_C2[4] * (xx - yy) * sh[8];

#if SH_DEGREE > 2
    result += 
        SH_C3[0] * y * (3.0f * xx - yy) * sh[9] +
        SH_C3[1] * xy * z * sh[10] +
        SH_C3[2] * y * (4.0f * zz - xx - yy) * sh[11] +
        SH_C3[3] * z * (2.0f * zz - 3.0f * xx - 3.0f * yy) * sh[12] +
        SH_C3[4] * x * (4.0f * zz - xx - yy) * sh[13] +
        SH_C3[5] * z * (xx - yy) * sh[14] +
        SH_C3[6] * x * (xx - 3.0f * yy) * sh[15];
#endif
#endif
#endif

    return result;
}

vec4 decompose(uint value)
{
    vec4 components = vec4(
                        float((value            ) & 255u),
                        float((value >> uint( 8)) & 255u),
                        float((value >> uint(16)) & 255u),
                        float((value >> uint(24)) & 255u));

    return components * vec4(2./255.) - vec4(1.);
}

vec3 computeSH(Splat splat, vec3 color, vec3 dir)
{
    vec3 sh[16];
    
    sh[0] = color;

#if SH_DEGREE > 0
    vec4 sh00 = decompose(splat.sh0.x);
    vec4 sh01 = decompose(splat.sh0.y);
    vec4 sh02 = decompose(splat.sh0.z);

    sh[1] = vec3(sh00.x, sh00.y, sh00.z);
    sh[2] = vec3(sh00.w, sh01.x, sh01.y);
    sh[3] = vec3(sh01.z, sh01.w, sh02.x);
#endif
#if SH_DEGREE > 1
    vec4 sh03 = decompose(splat.sh0.w);
    vec4 sh04 = decompose(splat.sh1.x);
    vec4 sh05 = decompose(splat.sh1.y);

    sh[4] = vec3(sh02.y, sh02.z, sh02.w);
    sh[5] = vec3(sh03.x, sh03.y, sh03.z);
    sh[6] = vec3(sh03.w, sh04.x, sh04.y);
    sh[7] = vec3(sh04.z, sh04.w, sh05.x);
    sh[8] = vec3(sh05.y, sh05.z, sh05.w);
#endif
#if SH_DEGREE > 2
    vec4 sh06 = decompose(splat.sh1.z);
    vec4 sh07 = decompose(splat.sh1.w);
    vec4 sh08 = decompose(splat.sh2.x);
    vec4 sh09 = decompose(splat.sh2.y);
    vec4 sh10 = decompose(splat.sh2.z);
    vec4 sh11 = decompose(splat.sh2.w);

    sh[9] = vec3(sh06.x, sh06.y, sh06.z);
    sh[10] = vec3(sh06.w, sh07.x, sh07.y);
    sh[11] = vec3(sh07.z, sh07.w, sh08.x);
    sh[12] = vec3(sh08.y, sh08.z, sh08.w);
    sh[13] = vec3(sh09.x, sh09.y, sh09.z);
    sh[14] = vec3(sh09.w, sh10.x, sh10.y);
    sh[15] = vec3(sh10.z, sh10.w, sh11.x);    
#endif

    return computeColorFromSHDegree(dir, sh);
}

vec4 gaussianSplatting(vec2 meshPos, vec3 worldPos, vec2 scale, vec3 covA, vec3 covB, mat4 worldMatrix, mat4 viewMatrix, mat4 projectionMatrix)
{
    mat4 modelView = viewMatrix * worldMatrix;
    vec4 camspace = viewMatrix * vec4(worldPos,1.);
    vec4 pos2d = projectionMatrix * camspace;

    float bounds = 1.2 * pos2d.w;
    if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds
        || pos2d.y < -bounds || pos2d.y > bounds) {
        return vec4(0.0, 0.0, 2.0, 1.0);
    }

    mat3 Vrk = mat3(
        covA.x, covA.y, covA.z, 
        covA.y, covB.x, covB.y,
        covA.z, covB.y, covB.z
    );

    mat3 J = mat3(
        focal.x / camspace.z, 0., -(focal.x * camspace.x) / (camspace.z * camspace.z), 
        0., focal.y / camspace.z, -(focal.y * camspace.y) / (camspace.z * camspace.z), 
        0., 0., 0.
    );

    mat3 T = transpose(mat3(modelView)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if (lambda2 < 0.0)
    {
        return vec4(0.0, 0.0, 2.0, 1.0);
    }

    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    vec2 vCenter = vec2(pos2d);
    return vec4(
        vCenter 
        + ((meshPos.x * majorAxis
        + meshPos.y * minorAxis) * invViewport * pos2d.w) * scale, pos2d.zw);
}

void main () {
    Splat splat = readSplat(splatIndex);
    vec3 covA = splat.covA.xyz;
    vec3 covB = vec3(splat.covA.w, splat.covB.xy);

    vec4 worldPos = modelMatrix * vec4(splat.center.xyz, 1.0);

    vColor = splat.color;
    vPosition = position.xy;

    gl_Position = gaussianSplatting(vPosition, worldPos.xyz, vec2(1.,1.), covA, covB, modelMatrix, viewMatrix, projectionMatrix);

}

`,Cl=`

precision highp float;
#include <common>

varying vec4 vColor;
varying vec2 vPosition;

vec4 gaussianColor(vec4 inColor)
{
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    float B = exp(A) * inColor.a;

    vec3 color = inColor.rgb;

    return vec4(color, B);
}


void main () { 

    gl_FragColor = gaussianColor(vColor);
}
`;let Ca=class{static build(e=0){const t={SH_DEGREE:e},s={invViewport:{type:"v2",value:new A.Vector2},dataTextureSize:{type:"v2",value:new A.Vector2},focal:{type:"v2",value:new A.Vector2},covariancesATexture:{type:"t",value:null},covariancesBTexture:{type:"t",value:null},centersTexture:{type:"t",value:null},colorsTexture:{type:"t",value:null},shTexture0:{type:"t",value:null},shTexture1:{type:"t",value:null},shTexture2:{type:"t",value:null}};return new A.ShaderMaterial({uniforms:s,defines:t,vertexShader:bl,fragmentShader:Cl,transparent:!0,alphaTest:1,blending:A.NormalBlending,depthTest:!0,depthWrite:!1,side:A.DoubleSide})}static updateUniforms(e,t,s){var u;if(!s.material||!(s.material instanceof A.ShaderMaterial)){console.warn("GaussianSplattingMaterial: No material found on mesh");return}const n=s.material,i=n.uniforms,r=new A.Vector2;e.getSize(r);const o=r.x,c=r.y;if(i.invViewport.value.set(1/(o/1),1/c),t){const d=t.projectionMatrix.elements[0]*.5*o,f=t.projectionMatrix.elements[5]*.5*c;i.focal.value.set(d,f)}const h=s;if(h.covariancesATexture){const d=h.covariancesATexture.image.width,f=h.covariancesATexture.image.height;if(i.dataTextureSize.value.set(d,f),i.covariancesATexture.value=h.covariancesATexture,i.covariancesBTexture.value=h.covariancesBTexture,i.centersTexture.value=h.centersTexture,i.colorsTexture.value=h.colorsTexture,h.shTextures)for(let p=0;p<((u=h.shTextures)==null?void 0:u.length);p++)i[`shTexture${p}`].value=h.shTextures[p]}n.uniformsNeedUpdate=!0}},Il=(ot=class{constructor(e){this._cameraPositionLast=new A.Vector3,this._cameraDirectionLast=new A.Vector3,this.splatMesh=e;const t=`(${ot._CreateWorker.toString()})(self)`,s=URL.createObjectURL(new Blob([t],{type:"application/javascript"}));this.worker=new Worker(new URL(s)),this.worker.onmessage=n=>{n.data}}async sortSplatMesh(e,t,s=!1){if(e.length===0)return new Promise(f=>{f({visibleScenes:[],splatIndex:null,updateStart:0,updateCount:0,vertexCount:0})});const n=new A.Vector3,i=new A.Vector3;t.getWorldPosition(n);const r=new A.Matrix4;r.multiplyMatrices(t.matrixWorldInverse,this.splatMesh.matrixWorld),i.set(r.elements[2],r.elements[6],r.elements[10]).normalize();let o=!1,c=0;const l=new A.Box3;for(let f=0;f<e.length;f++){const p=e[f];c+=p.vertexCount,f===0?l.copy(p.boundingBox):l.union(p.boundingBox),p.needSort&&(o=!0)}const h=.001;if(!o&&!s&&this._cameraPositionLast.distanceTo(n)<h&&this._cameraDirectionLast.distanceTo(i)<h)return new Promise(f=>{f({visibleScenes:[],splatIndex:null,updateStart:0,updateCount:0,vertexCount:c})});this._cameraPositionLast.copy(n),this._cameraDirectionLast.copy(i);const u={visibleScenes:e.map(f=>({lineStart:f.lineStart,lineCount:f.lineCount,lineWidth:f.lineWidth,splatPositions:f.splatPositions,vertexCount:f.vertexCount})),cameraPosition:{x:n.x,y:n.y,z:n.z},cameraDirection:{x:i.x,y:i.y,z:i.z},boundMin:{x:l.min.x,y:l.min.y,z:l.min.z},boundMax:{x:l.max.x,y:l.max.y,z:l.max.z}},d=[];return e.forEach(f=>{d.push(f.splatPositions.buffer)}),new Promise((f,p)=>{const g=this.worker,m=b=>{g.removeEventListener("error",m),g.removeEventListener("message",I),p(b)},I=b=>{g.removeEventListener("error",m),g.removeEventListener("message",I),b.data.visibleScenes.forEach((C,y)=>{e[y].splatPositions=C.splatPositions,e[y].needSort=!1}),f(b.data)};g.addEventListener("error",m),g.addEventListener("message",I),g.postMessage(u,d)})}},ot._CreateWorker=function(e){e.onmessage=t=>{const{visibleScenes:s,cameraPosition:n,cameraDirection:i,boundMin:r,boundMax:o}=t.data,c=[];if(s.forEach(_=>{c.push(_.splatPositions.buffer)}),s.length===0){e.postMessage({visibleScenes:s,splatIndex:null,updateStart:0,updateCount:0,vertexCount:0},c);return}const l=i.x,h=i.y,u=i.z;let d=0;for(let _=0;_<s.length;_++){const w=s[_].vertexCount;d+=w}let f,p;for(let _=0;_<8;++_){const x=_&1?r.x:o.x,w=_&2?r.y:o.y,S=_&4?r.z:o.z,Q=x*l+w*h+S*u;_===0?f=p=Q:(f=Math.min(f,Q),p=Math.max(p,Q))}if(p-f<1e-6){e.postMessage({visibleScenes:s,splatIndex:null,updateStart:0,updateCount:0,vertexCount:0},c);return}const m=new Int32Array(d),I=new Uint32Array(d),b=new Int32Array(d),C=new Uint32Array(d);let y=0;for(let _=0;_<s.length;_++){const x=s[_],w=x.vertexCount,S=x.lineStart*x.lineWidth;for(let Q=0;Q<w;++Q){const E=x.splatPositions[Q*4+0],N=x.splatPositions[Q*4+1],k=x.splatPositions[Q*4+2],O=E*l+N*h+k*u-f;m[y]=Math.floor(O*4096),I[y]=S+Q,y++}}y=d;const B=new Uint32Array(256);for(let _=0;_<32;_+=8){B.fill(0);for(let w=0;w<y;w++){const S=m[w]>>_&255;B[S]+=1}let x=0;for(let w=0;w<B.length;w++){const S=B[w];B[w]=x,x+=S}for(let w=0;w<y;w++){const S=m[w]>>_&255,Q=B[S];B[S]+=1,b[Q]=m[w],C[Q]=I[w]}m.set(b),I.set(C)}const v=new Float32Array(d);for(let _=0;_<d;_++)v[_]=I[_];c.push(v.buffer),e.postMessage({visibleScenes:s,splatIndex:v,updateStart:0,updateCount:d,vertexCount:d},c)}},ot),yl=class extends A.Mesh{constructor(e,t,s){super(),this._sorter=null,this._centersData=null,this._covariancesAData=null,this._covariancesBData=null,this._colorsData=null,this.covariancesATexture=null,this.covariancesBTexture=null,this.centersTexture=null,this.colorsTexture=null,this.shTextures=null,this.scenes=[],this.sortingScenes=[],this.renderingScenes=[],this.removeingScenes=[],this.sortRunning=!1,this.isGaussianSplattingMesh=!0,this.renderer=e,this.camera=t,this._textureSize=s,this._maxVertexCount=this._textureSize.x*this._textureSize.y,this.geometry=ba.build(this._maxVertexCount),this.material=Ca.build(),this._sorter=new Il(this),this._initTextures(!1)}async dispose(){}resizeTextures(e){if(this._textureSize.equals(e))return;const t=this._colorsData;this._centersData;const s=this._covariancesAData,n=this._covariancesBData;this._textureSize.copy(e),this._initTextures(!0);const i=Se.covBSItemSize;Se.useRGBACovariants;const r=this.scenes;this.scenes=[];for(const l of r){const h=l.vertexCount;l.splatCovA=new Uint16Array(s.buffer,l.lineStart*l.lineWidth*4,l.vertexCount),l.splatCovB=new Uint16Array(n.buffer,l.lineStart*l.lineWidth*i,l.vertexCount),l.splatColors=new Uint8Array(t.buffer,l.lineStart*l.lineWidth*4,l.vertexCount),this._updateSceneTextureLines(l);const u=l.lineStart,d=l.lineCount,f=l.lineWidth;this._copyData(this._centersData,l.splatPositions,f,4,h,u,d),this._copyData(this._covariancesAData,l.splatCovA,f,4,h,u,d),this._copyData(this._covariancesBData,l.splatCovB,f,i,h,u,d),this._copyData(this._colorsData,l.splatColors,f,4,h,u,d),l.splatCovA=null,l.splatCovB=null,l.splatColors=null,l.needSort=!0,l.readyToRender=!0,this.scenes.push(l)}this.covariancesATexture.needsUpdate=!0,this.covariancesBTexture.needsUpdate=!0,this.centersTexture.needsUpdate=!0,this.colorsTexture.needsUpdate=!0,this._maxVertexCount=this._textureSize.x*this._textureSize.y;const o=this.geometry.attributes.splatIndex.array,c=this.geometry.instanceCount;this.geometry=ba.build(this._maxVertexCount);for(let l=0;l<c;l++)this.geometry.attributes.splatIndex.array[l]=o[l];this.geometry.attributes.splatIndex.needsUpdate=!0}updateSceneTexture(e){return new Promise((t,s)=>{if(!this._updateSceneTextureLines(e))return s("Failed to add new scene");this._updateSceneTexture(e),t()})}addSplatScene(e){this.scenes.push(e)}removeSplatScene(e){const t=this.scenes.indexOf(e);if(t!==-1){if(this.sortingScenes.includes(e)||this.renderingScenes.includes(e)){this.removeingScenes.push(e);return}this.scenes.splice(t,1)}}async runSplatSort(e){if(this.removeingScenes.length>0)for(let t=this.removeingScenes.length-1;t>=0;t--){const s=this.removeingScenes[t];if(!this.renderingScenes.includes(s)&&!this.sortingScenes.includes(s)){const n=this.scenes.indexOf(s);this.scenes.splice(n,1),this.removeingScenes.splice(t,1)}}this.sortRunning||(this.sortRunning=!0,this.sortingScenes=e,this._sorter.sortSplatMesh(e,this.camera).then(t=>{if(t.updateCount>0){for(let s=t.updateStart;s<t.updateCount;s++)this.geometry.attributes.splatIndex.array[s]=t.splatIndex[s];this.geometry.attributes.splatIndex.addUpdateRange(t.updateStart,t.updateCount),this.geometry.attributes.splatIndex.needsUpdate=!0}this.geometry.instanceCount=t.vertexCount,this.renderingScenes=this.sortingScenes}).finally(()=>{this.sortingScenes=[],this.sortRunning=!1}))}_updateSceneTextureLines(e){const t=this._textureSize.x,s=this._textureSize.y,n=e.vertexCount,i=Math.ceil(n/t),r=this._findBestLineStart(s,this.scenes,i);return r===null?(console.error("No space available to add new line"),!1):(e.lineCount=i,e.lineStart=r,e.lineWidth=t,e.readyToRender=!1,!0)}_findBestLineStart(e,t,s){if(t.length===0)return s<=e?0:null;if(t.sort((i,r)=>i.lineStart-r.lineStart),t[0].lineStart>=s)return 0;for(let i=0;i<t.length-1;i++){const r=t[i].lineStart+t[i].lineCount;if(t[i+1].lineStart-r>=s)return r}const n=t[t.length-1].lineStart+t[t.length-1].lineCount;return e-n>=s?n:null}_initTextures(e){const t=(c,l,h,u)=>{const d=new A.DataTexture(c,l,h,u,A.FloatType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return d.generateMipmaps=!1,d.needsUpdate=!0,d},s=(c,l,h,u)=>{const d=new A.DataTexture(c,l,h,u,A.UnsignedByteType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return d.generateMipmaps=!1,d.needsUpdate=!0,d},n=(c,l,h,u)=>{const d=new A.DataTexture(c,l,h,u,A.HalfFloatType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return d.generateMipmaps=!1,d.needsUpdate=!0,d},i=this._textureSize,r=Se.covBSItemSize,o=Se.useRGBACovariants;this._centersData=new Float32Array(i.x*i.y*4),this._covariancesAData=new Uint16Array(i.x*i.y*4),this._covariancesBData=new Uint16Array(i.x*i.y*r),this._colorsData=new Uint8Array(i.x*i.y*4),this.covariancesATexture=n(e?this._covariancesAData:null,i.x,i.y,A.RGBAFormat),this.covariancesBTexture=n(e?this._covariancesBData:null,i.x,i.y,o?A.RGBAFormat:A.RGFormat),this.centersTexture=t(e?this._centersData:null,i.x,i.y,A.RGBAFormat),this.colorsTexture=s(e?this._colorsData:null,i.x,i.y,A.RGBAFormat)}_convert(e,t){return t===A.UnsignedByteType?e.UNSIGNED_BYTE:t===A.UnsignedShort4444Type?e.UNSIGNED_SHORT_4_4_4_4:t===A.UnsignedShort5551Type?e.UNSIGNED_SHORT_5_5_5_1:t===A.UnsignedInt5999Type?e.UNSIGNED_INT_5_9_9_9_REV:t===A.ByteType?e.BYTE:t===A.ShortType?e.SHORT:t===A.UnsignedShortType?e.UNSIGNED_SHORT:t===A.IntType?e.INT:t===A.UnsignedIntType?e.UNSIGNED_INT:t===A.FloatType?e.FLOAT:t===A.HalfFloatType?e.HALF_FLOAT:t===A.AlphaFormat?e.ALPHA:t===A.RGBFormat?e.RGB:t===A.RGBAFormat?e.RGBA:t===A.DepthFormat?e.DEPTH_COMPONENT:t===A.DepthStencilFormat?e.DEPTH_STENCIL:t===A.RedFormat?e.RED:t===A.RedIntegerFormat?e.RED_INTEGER:t===A.RGFormat?e.RG:t===A.RGIntegerFormat?e.RG_INTEGER:t===A.RGBAIntegerFormat?e.RGBA_INTEGER:t===A.UnsignedInt248Type?e.UNSIGNED_INT_24_8:e[t]!==void 0?e[t]:null}_copyData(e,t,s,n,i,r,o){const c=r*s*n;for(let l=0;l<i;l++){const h=l*n,u=l*n+c;for(let d=0;d<n;d++)e[u+d]=t[h+d]}}_updateSceneTexture(e){const t=(p,g,m,I,b)=>{const C=this.renderer.getContext(),y=this._textureSize,B=this.renderer?this.renderer.properties.get(p):null;if(!B||!B.__webglTexture)p.needsUpdate=!0;else{const v=this._convert(C,p.type),_=this._convert(C,p.format),x=C.getParameter(C.TEXTURE_BINDING_2D);C.bindTexture(C.TEXTURE_2D,B.__webglTexture),C.texSubImage2D(C.TEXTURE_2D,0,0,I,y.x,b,_,v,g),C.bindTexture(C.TEXTURE_2D,x)}},s=e.lineStart,n=e.lineCount,i=e.lineWidth,r=e.vertexCount,o=Se.covBSItemSize;this._copyData(this._centersData,e.splatPositions,i,4,r,s,n),this._copyData(this._covariancesAData,e.splatCovA,i,4,r,s,n),this._copyData(this._covariancesBData,e.splatCovB,i,o,r,s,n),this._copyData(this._colorsData,e.splatColors,i,4,r,s,n),e.splatCovA=null,e.splatCovB=null,e.splatColors=null;const c=s*i,l=n*i,h=new Uint16Array(this._covariancesAData.buffer,c*4*Uint16Array.BYTES_PER_ELEMENT,l*4),u=new Uint16Array(this._covariancesBData.buffer,c*o*Uint16Array.BYTES_PER_ELEMENT,l*o),d=new Uint8Array(this._colorsData.buffer,c*4,l*4),f=new Float32Array(this._centersData.buffer,c*4*Float32Array.BYTES_PER_ELEMENT,l*4);t(this.covariancesATexture,h,i,s,n),t(this.covariancesBTexture,u,i,s,n),t(this.centersTexture,f,i,s,n),t(this.colorsTexture,d,i,s,n),e.readyToRender=!0}onBeforeRender(e,t,s,n,i,r){this.updateWorldMatrix(!0,!1),Ca.updateUniforms(e,s,this),super.onBeforeRender(e,t,s,n,i,r)}};function Ut(a){const e=a.array,t=a.itemSize,s=a.count,n=a.normalized;return{array:e,itemSize:t,count:s,normalized:n}}const ks=class ks{initialize(e=1){const t=`(${ks._CreateWorker.toString()})(self)`,s=URL.createObjectURL(new Blob([t],{type:"application/javascript"}));this._WorkerPool=new Gt(e,()=>{const n=new Worker(s);return Promise.resolve(n)})}updateDataFromGeometryAsync(e){const t=e.geometry;return t?new Promise((s,n)=>{const i=Ut(t.attributes.position),r=Ut(t.attributes.scale),o=Ut(t.attributes.rotation),c=Ut(t.attributes.color),l=t.attributes.opacity?Ut(t.attributes.opacity):null,h=t.attributes.position.count;this._WorkerPool.push((u,d)=>{const f=g=>{u.removeEventListener("error",f),u.removeEventListener("message",p),n(g),d()},p=g=>{u.removeEventListener("error",f),u.removeEventListener("message",p);try{const{vertexCount:m,splatPositions:I,splatCovA:b,splatCovB:C,splatColors:y,boundingBox:B,boundingSphere:v}=g.data;e.vertexCount=m,e.splatPositions=I,e.splatCovA=b,e.splatCovB=C,e.splatColors=y,e.boundingBox=new A.Box3(new A.Vector3(B.min[0],B.min[1],B.min[2]),new A.Vector3(B.max[0],B.max[1],B.max[2])),e.boundingSphere=new A.Sphere(new A.Vector3(v.center[0],v.center[1],v.center[2]),v.radius),e.needSort=!0,e.geometry.dispose(),e.geometry=null,s()}catch(m){n({message:m})}d()};u.addEventListener("error",f),u.addEventListener("message",p),u.postMessage({positionBuffer:i,scaleBuffer:r,rotationBuffer:o,colorBuffer:c,opacityBuffer:l,vertexCount:h,useRGBACovariants:Se.useRGBACovariants,covBSItemSize:Se.covBSItemSize},[i.array.buffer,r.array.buffer,o.array.buffer,c.array.buffer,...l?[l.array.buffer]:[]])})}):Promise.reject("No geometry found.")}};ks._CreateWorker=function(e){const t=n();function s(h,u,d){return Math.max(u,Math.min(d,h))}function n(){const h=new ArrayBuffer(4),u=new Float32Array(h),d=new Uint32Array(h),f=new Uint32Array(512),p=new Uint32Array(512);for(let b=0;b<256;++b){const C=b-127;C<-27?(f[b]=0,f[b|256]=32768,p[b]=24,p[b|256]=24):C<-14?(f[b]=1024>>-C-14,f[b|256]=1024>>-C-14|32768,p[b]=-C-1,p[b|256]=-C-1):C<=15?(f[b]=C+15<<10,f[b|256]=C+15<<10|32768,p[b]=13,p[b|256]=13):C<128?(f[b]=31744,f[b|256]=64512,p[b]=24,p[b|256]=24):(f[b]=31744,f[b|256]=64512,p[b]=13,p[b|256]=13)}const g=new Uint32Array(2048),m=new Uint32Array(64),I=new Uint32Array(64);for(let b=1;b<1024;++b){let C=b<<13,y=0;for(;(C&8388608)===0;)C<<=1,y-=8388608;C&=-8388609,y+=947912704,g[b]=C|y}for(let b=1024;b<2048;++b)g[b]=939524096+(b-1024<<13);for(let b=1;b<31;++b)m[b]=b<<23;m[31]=1199570944,m[32]=2147483648;for(let b=33;b<63;++b)m[b]=2147483648+(b-32<<23);m[63]=3347054592;for(let b=1;b<64;++b)b!==32&&(I[b]=1024);return{floatView:u,uint32View:d,baseTable:f,shiftTable:p,mantissaTable:g,exponentTable:m,offsetTable:I}}function i(h){Math.abs(h)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),h=s(h,-65504,65504),t.floatView[0]=h;const u=t.uint32View[0],d=u>>23&511;return t.baseTable[d]+((u&8388607)>>t.shiftTable[d])}function r(h,u){switch(u.constructor){case Float32Array:return h;case Uint32Array:return h/4294967295;case Uint16Array:return h/65535;case Uint8Array:return h/255;case Int32Array:return Math.max(h/2147483647,-1);case Int16Array:return Math.max(h/32767,-1);case Int8Array:return Math.max(h/127,-1);default:throw new Error("Invalid component type.")}}function o(h,u,d){let f=h.array[u*h.itemSize+d];return h.normalized&&(f=r(f,h.array)),f}function c(h,u,d){const f=[d];for(let p=0;p<d;p++)f[p]=o(h,u,p);return f}function l(h){let u=h[0]*h[0]+h[1]*h[1]+h[2]*h[2]+h[3]*h[3];if(u===0){h[0]=0,h[1]=0,h[2]=0,h[3]=1;return}let d=1/Math.sqrt(u);h[0]*=d,h[1]*=d,h[2]*=d,h[3]*=d}e.onmessage=async h=>{const{positionBuffer:u,scaleBuffer:d,rotationBuffer:f,colorBuffer:p,opacityBuffer:g,vertexCount:m,useRGBACovariants:I,covBSItemSize:b}=h.data,C=255,y=new Float32Array(4*m),B=new Uint16Array(m*4),v=new Uint16Array(m*b),_=new Uint8Array(m*4);let x=[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],w=[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE];for(let E=0;E<m;E++){const N=c(u,E,3),k=c(d,E,3),O=c(f,E,4),P=g?[...c(p,E,3),...c(g,E,1)]:c(p,E,4);l(O);for(let te=0;te<3;te++)N[te]<x[te]&&(x[te]=N[te]),N[te]>w[te]&&(w[te]=N[te]);const M=O[0],j=O[1],q=O[2],z=-O[3],Z=M+M,X=j+j,$=q+q,de=M*Z,ct=M*X,$e=M*$,fe=j*X,Fe=j*$,At=q*$,se=z*Z,le=z*X,D=z*$,F=k[0]*2,G=k[1]*2,R=k[2]*2,L=Array(12);L[0]=(1-(fe+At))*F,L[1]=(ct+D)*G,L[2]=($e-le)*R,L[4]=(ct-D)*F,L[5]=(1-(de+At))*G,L[6]=(Fe+se)*R,L[8]=($e+le)*F,L[9]=(Fe-se)*G,L[10]=(1-(de+fe))*R;const T=L,V=Array(6);V[0]=T[0]*T[0]+T[1]*T[1]+T[2]*T[2],V[1]=T[0]*T[4]+T[1]*T[5]+T[2]*T[6],V[2]=T[0]*T[8]+T[1]*T[9]+T[2]*T[10],V[3]=T[4]*T[4]+T[5]*T[5]+T[6]*T[6],V[4]=T[4]*T[8]+T[5]*T[9]+T[6]*T[10],V[5]=T[8]*T[8]+T[9]*T[9]+T[10]*T[10];let J=-1e4;for(let te=0;te<6;te++)J=Math.max(J,Math.abs(V[te]));const ne=E,H=ne*4,Te=ne*b;y[4*E+0]=N[0],y[4*E+1]=N[1],y[4*E+2]=N[2],y[4*E+3]=J,B[H+0]=i(V[0]/J),B[H+1]=i(V[1]/J),B[H+2]=i(V[2]/J),B[H+3]=i(V[3]/J),v[Te+0]=i(V[4]/J),v[Te+1]=i(V[5]/J),_[4*E+0]=P[0]*C,_[4*E+1]=P[1]*C,_[4*E+2]=P[2]*C,_[4*E+3]=P[3]*C}const S=[(x[0]+w[0])/2,(x[1]+w[1])/2,(x[2]+w[2])/2],Q=Math.max(w[0]-x[0],w[1]-x[1],w[2]-x[2])/2;e.postMessage({vertexCount:m,splatPositions:y,splatCovA:B,splatCovB:v,splatColors:_,boundingBox:{min:x,max:w},boundingSphere:{center:S,radius:Q}},[y.buffer,B.buffer,v.buffer,_.buffer])}};let Pn=ks;class Bl{constructor(e,t,s){this.tiles=null,this.renderer=e,this.camera=t,this.textureSize=new A.Vector2(8196,4096),s&&(this.textureSize.y=Math.ceil(s/8196)),this.maxGaussianSplatingCount=this.textureSize.x*this.textureSize.y,this._onLoadModel=({tile:n,scene:i})=>{this.onLoadModel(n,i)},this._onDisposeModel=({tile:n,scene:i})=>{this.onDisposeModel(n,i)},this._onUpdateBefore=()=>{this.onUpdateBefore()},this._onUpdateAfter=()=>{this.onUpdateAfter()},this._onLoadTileSet=(n,i)=>{this.onLoadTileSet(n,i)},this._onTileVisibilityChange=({scene:n,tile:i,visible:r})=>{this.onTileVisibilityChange(n,i,r)}}init(e){this.tiles=e,e.addEventListener("load-tile-set",this._onLoadTileSet),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange),e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),this.bufferWorker=new Pn,this.bufferWorker.initialize(e.parseQueue.maxJobs)}dispose(){const e=this.tiles;e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("load-tile-set",this._onLoadTileSet),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange)}onLoadTileSet(e,t){const s=this.tiles,n=new A.Box3,i=new A.Sphere;if("sphere"in s.root.boundingVolume){const{x:r,y:o,z:c,radius:l}=s.root.boundingVolume.sphere;i.center.set(r,o,c),i.radius=l,i.getBoundingBox(n)}else if("box"in s.root.boundingVolume){const r=s.root.boundingVolume.box;n.min.set(r[0]-r[3],r[1]-r[7],r[2]-r[11]),n.max.set(r[0]+r[3],r[1]+r[7],r[2]+r[11]),n.getBoundingSphere(i)}else{const r=s.root.cached.transform,o=s.root.cached.boundingVolume,c=new A.Matrix4().copy(r).invert();o.getAABB(n),n.applyMatrix4(c),n.getBoundingSphere(i)}this.splatMesh=new yl(this.renderer,this.camera,this.textureSize),this.splatMesh.frustumCulled=!1,this.splatMesh.matrix=s.root.cached.transform,this.splatMesh.matrixAutoUpdate=!1,s.group.add(this.splatMesh),this.splatMesh.matrixWorldAutoUpdate=!0,this.splatMesh.boundingBox=n,this.splatMesh.boundingSphere=i}processTileModel(e,t){const s=[];return e.traverse(n=>{const i=n;if(i&&i.isGaussianSplattingScene){const r=this.bufferWorker.updateDataFromGeometryAsync(i).then(()=>{var o;(o=this.splatMesh)==null||o.updateSceneTexture(i).catch(c=>{throw new Error(`Failed to updateSceneTexture, try more maxGaussianSplatingCount: ${this.maxGaussianSplatingCount}`)})});s.push(r)}}),Promise.all(s)}onTileVisibilityChange(e,t,s){e.traverse(n=>{const i=n;i&&i.isGaussianSplattingScene&&(i.visible=s)})}onDisposeModel(e,t){t.traverse(s=>{var i;const n=s;n&&n.isGaussianSplattingScene&&(n.visible=!1,(i=this.splatMesh)==null||i.removeSplatScene(n))})}onLoadModel(e,t){t.traverse(s=>{var i;const n=s;n&&n.isGaussianSplattingScene&&(n.visible=!1,(i=this.splatMesh)==null||i.addSplatScene(n))})}onUpdateBefore(){}onUpdateAfter(){var n;const e=this.tiles,t=this.camera;if(!e||!t)return;let s=[];e.forEachLoadedModel((i,r)=>{i&&i.traverse(o=>{const c=o;c&&c.isGaussianSplattingScene&&c.visible&&(c.readyToRender||console.log("splatScene not ready to render"),s.push(c))})}),(n=this.splatMesh)==null||n.runSplatSort(s)}}let Ia=1;const Un=(a,e)=>Math.abs(a.__depthFromRenderedParent-e.__depthFromRenderedParent)>Ia?a.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:a.__error!==e.__error?a.__error>e.__error?1:-1:a.__distanceFromCamera!==e.__distanceFromCamera?a.__distanceFromCamera>e.__distanceFromCamera?-1:1:a.__inFrustum!==e.__inFrustum?a.__inFrustum?1:-1:a.__used!==e.__used?a.__used?1:-1:a.__depthFromRenderedParent!==e.__depthFromRenderedParent?a.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:0;class xl{constructor(e={depthLevel:1}){this.depthLevel=e.depthLevel}set depthLevel(e){Ia=e}init(e){e.downloadQueue.priorityCallback=Un,e.parseQueue.priorityCallback=Un,e.processNodeQueue.priorityCallback=Un}}const _l=Object.freeze({NONE:0,SCREEN_ERROR:1,GEOMETRIC_ERROR:2,DISTANCE:3,DEPTH:4,RELATIVE_DEPTH:5,IS_LEAF:6,RANDOM_COLOR:7,RANDOM_NODE_COLOR:8,CUSTOM_COLOR:9,LOAD_ORDER:10});class ya extends Xe{static getColorModes(){return _l}constructor(e){super(),this.options=e,this.group=void 0,this.tiles=void 0,this.centerLngLat=void 0}addToScene(e){const t=e.getWebGLRenderer(),s=e.getCamera(),n=new A.Group;this.add(n);const i=it.getDracoLoader(this.options.dracoLoaderPath),r=it.getKtxLoader(this.options.ktx2LoaderPath),o=it.getMeshoptDecoder(this.options.meshoptDecoder);r.detectSupport(t);const c=new Bc(this.options.url);this.options.downloadMaxJobs&&(c.downloadQueue.maxJobs=this.options.downloadMaxJobs),this.options.parseMaxJobs&&(c.parseQueue.maxJobs=this.options.parseMaxJobs),c.registerPlugin(new Gc),c.registerPlugin(new Dc),c.registerPlugin(new NA),c.registerPlugin(new OA),c.registerPlugin(new vn),c.registerPlugin(new xl),c.registerPlugin(new wc);let l=[];return this.options.isGaussianSplatting&&(c.registerPlugin(new Bl(t,s,this.options.maxGaussianSplatingCount)),l.push(h=>new gl(h,s))),c.registerPlugin(new UA({rtc:!0,autoDispose:!1,dracoLoader:i,ktxLoader:r,meshoptDecoder:o,plugins:l})),c.fetchOptions.mode="cors",c.autoDisableRendererCulling=!0,c.setCamera(s),c.setResolutionFromRenderer(s,t),n.add(c.group),this.centerLngLat=void 0,c.addEventListener("load-tile-set",()=>{this.updateTilesetTransform();const{onLoadTileset:h}=this.options;h&&h(this)}),this.tiles=c,this.group=n,this.options.debug&&this.setDebugParams(this.options.debug),this.options.display&&this.setDisplayParams(this.options.display),super.addToScene(e)}removeFromScene(){return this.group&&this.tiles&&(this.group.remove(this.tiles.group),this.tiles.dispose(),this.remove(this.group)),this.group=void 0,this.tiles=void 0,super.removeFromScene()}updateSceneTime(e,t){const s=this.tiles;s&&(s.group.updateMatrixWorld(!0),s.update())}getCenterLngLat(){return this.centerLngLat||{lat:0,lon:0}}updateTilesetTransform(){const e=this.group,t=this.tiles;if(!e||!t||!t.root)return;this._scene.getRefCenter();let s={lat:0,lon:0,height:0};const n=t.root.transform;if(n){const l=new A.Vector3(n[12],n[13],n[14]);t.ellipsoid.getPositionToCartographic(l,s)}else{let l=new A.Box3,h=new A.Sphere,u=new A.Vector3;if(t.getBoundingBox(l))l.getCenter(u);else if(t.getBoundingSphere(h))u=h.center;else return;t.ellipsoid.getPositionToCartographic(u,s)}const i=[A.MathUtils.radToDeg(s.lon),A.MathUtils.radToDeg(s.lat)],r=this._scene.toScenePosition(i);e.position.set(r.x,r.y,r.z);const c=t.ellipsoid.getObjectFrame(s.lat,s.lon,s.height,0,0,0,new A.Matrix4,0).clone().invert();c.decompose(t.group.position,t.group.quaternion,t.group.scale),t.group.matrix.copy(c),this.centerLngLat={lon:A.MathUtils.radToDeg(s.lon),lat:A.MathUtils.radToDeg(s.lat)}}setDebugParams(e){if(!this.tiles)return;const t=this.tiles.getPluginByName("DEBUG_TILES_PLUGIN");if(!t)return;const s={...this.options.debug,...e};s.enableDebug!==void 0&&(t.enabled=e.enableDebug),s.displayBoxBounds!==void 0&&(t.displayBoxBounds=e.displayBoxBounds),s.displaySphereBounds!==void 0&&(t.displaySphereBounds=e.displaySphereBounds),s.displayRegionBounds!==void 0&&(t.displayRegionBounds=e.displayRegionBounds),s.colorMode!==void 0&&(t.colorMode=e.colorMode),this.options.debug=s}setDisplayParams(e){if(!this.tiles)return;const t=this.tiles,s={...this.options.display,...e};s.errorTarget!==void 0&&(t.errorTarget=s.errorTarget),s.displayActiveTiles!==void 0&&(t.displayActiveTiles=s.displayActiveTiles),s.autoDisableRendererCulling!==void 0&&(t.autoDisableRendererCulling=s.autoDisableRendererCulling),s.maxDepth!==void 0&&(t.maxDepth=s.maxDepth),s.optimizeRaycast!==void 0&&(t.optimizeRaycast=s.optimizeRaycast),this.options.display=s}}class Nn{static build(e=1,t=!1){const s=new A.BufferGeometry;if(t){s.setIndex([0,1,2,0,2,3]);const o=new Float32Array(4*3),c=new A.BufferAttribute(o,3);s.setAttribute("position",c),c.setXYZ(0,-2,-2,0),c.setXYZ(1,-2,2,0),c.setXYZ(2,2,2,0),c.setXYZ(3,2,-2,0),c.needsUpdate=!0}else{s.setIndex([0,1,2]);const o=new Float32Array(3*3),c=new A.BufferAttribute(o,3);s.setAttribute("position",c),c.setXYZ(0,-3,-2,0),c.setXYZ(1,3,-2,0),c.setXYZ(2,0,4,0),c.needsUpdate=!0}const n=new A.InstancedBufferGeometry().copy(s),i=new Float32Array(e),r=new A.InstancedBufferAttribute(i,1,!1);return r.setUsage(A.DynamicDrawUsage),n.setAttribute("splatIndex",r),n.instanceCount=0,n}}const wl=`
precision highp float;

#include <common>

// Attributes
attribute float splatIndex;

// Uniforms
uniform vec2 invViewport;
uniform vec2 dataTextureSize;
uniform vec2 focal;

uniform sampler2D covariancesATexture;
uniform sampler2D covariancesBTexture;
uniform sampler2D centersTexture;
uniform sampler2D colorsTexture;

#if SH_DEGREE > 0
uniform highp usampler2D shTexture0;
#endif
#if SH_DEGREE > 1
uniform highp usampler2D shTexture1;
#endif
#if SH_DEGREE > 2
uniform highp usampler2D shTexture2;
#endif

// Output
varying vec4 vColor;
varying vec2 vPosition;

mat3 transposeMatrix(mat3 matrix) {
    return mat3(matrix[0][0], matrix[1][0], matrix[2][0],
        matrix[0][1], matrix[1][1], matrix[2][1],
        matrix[0][2], matrix[1][2], matrix[2][2]);
}

vec2 getDataUV(float index, vec2 textureSize) {
    float y = floor(index / textureSize.x);
    float x = index - y * textureSize.x;
    return vec2((x + 0.5) / textureSize.x, (y + 0.5) / textureSize.y);
}

#if SH_DEGREE > 0
ivec2 getDataUVint(float index, vec2 textureSize) {
    float y = floor(index / textureSize.x);
    float x = index - y * textureSize.x;
    return ivec2(uint(x + 0.5), uint(y + 0.5));
}
#endif

struct Splat {
    vec4 center;
    vec4 color;
    vec4 covA;
    vec4 covB;
#if SH_DEGREE > 0
    uvec4 sh0; // 4 * 32bits uint
#endif
#if SH_DEGREE > 1
    uvec4 sh1;
#endif
#if SH_DEGREE > 2
    uvec4 sh2;
#endif
};

Splat readSplat(float splatIndex)
{
    Splat splat;
    vec2 splatUV = getDataUV(splatIndex, dataTextureSize);
    splat.center = texture2D(centersTexture, splatUV);
    splat.color = texture2D(colorsTexture, splatUV);
    splat.covA = texture2D(covariancesATexture, splatUV) * splat.center.w;
    splat.covB = texture2D(covariancesBTexture, splatUV) * splat.center.w;
#if SH_DEGREE > 0
    ivec2 splatUVint = getDataUVint(splatIndex, dataTextureSize);
    splat.sh0 = texelFetch(shTexture0, splatUVint, 0);
#endif
#if SH_DEGREE > 1
    splat.sh1 = texelFetch(shTexture1, splatUVint, 0);
#endif
#if SH_DEGREE > 2
    splat.sh2 = texelFetch(shTexture2, splatUVint, 0);
#endif

    return splat;
}
    
// no SH for GS and WebGL1
// dir = normalized(splat pos - cam pos)
vec3 computeColorFromSHDegree(vec3 dir, const vec3 sh[16])
{
    const float SH_C0 = 0.28209479;
    const float SH_C1 = 0.48860251;
    float SH_C2[5];
    SH_C2[0] = 1.092548430;
    SH_C2[1] = -1.09254843;
    SH_C2[2] = 0.315391565;
    SH_C2[3] = -1.09254843;
    SH_C2[4] = 0.546274215;
    
    float SH_C3[7];
    SH_C3[0] = -0.59004358;
    SH_C3[1] = 2.890611442;
    SH_C3[2] = -0.45704579;
    SH_C3[3] = 0.373176332;
    SH_C3[4] = -0.45704579;
    SH_C3[5] = 1.445305721;
    SH_C3[6] = -0.59004358;

	vec3 result = /*SH_C0 * */sh[0];

#if SH_DEGREE > 0
    float x = dir.x;
    float y = dir.y;
    float z = dir.z;
    result += - SH_C1 * y * sh[1] + SH_C1 * z * sh[2] - SH_C1 * x * sh[3];

#if SH_DEGREE > 1
    float xx = x * x, yy = y * y, zz = z * z;
    float xy = x * y, yz = y * z, xz = x * z;
    result += 
        SH_C2[0] * xy * sh[4] +
        SH_C2[1] * yz * sh[5] +
        SH_C2[2] * (2.0f * zz - xx - yy) * sh[6] +
        SH_C2[3] * xz * sh[7] +
        SH_C2[4] * (xx - yy) * sh[8];

#if SH_DEGREE > 2
    result += 
        SH_C3[0] * y * (3.0f * xx - yy) * sh[9] +
        SH_C3[1] * xy * z * sh[10] +
        SH_C3[2] * y * (4.0f * zz - xx - yy) * sh[11] +
        SH_C3[3] * z * (2.0f * zz - 3.0f * xx - 3.0f * yy) * sh[12] +
        SH_C3[4] * x * (4.0f * zz - xx - yy) * sh[13] +
        SH_C3[5] * z * (xx - yy) * sh[14] +
        SH_C3[6] * x * (xx - 3.0f * yy) * sh[15];
#endif
#endif
#endif

    return result;
}

vec4 decompose(uint value)
{
    vec4 components = vec4(
                        float((value            ) & 255u),
                        float((value >> uint( 8)) & 255u),
                        float((value >> uint(16)) & 255u),
                        float((value >> uint(24)) & 255u));

    return components * vec4(2./255.) - vec4(1.);
}

vec3 computeSH(Splat splat, vec3 color, vec3 dir)
{
    vec3 sh[16];
    
    sh[0] = color;

#if SH_DEGREE > 0
    vec4 sh00 = decompose(splat.sh0.x);
    vec4 sh01 = decompose(splat.sh0.y);
    vec4 sh02 = decompose(splat.sh0.z);

    sh[1] = vec3(sh00.x, sh00.y, sh00.z);
    sh[2] = vec3(sh00.w, sh01.x, sh01.y);
    sh[3] = vec3(sh01.z, sh01.w, sh02.x);
#endif
#if SH_DEGREE > 1
    vec4 sh03 = decompose(splat.sh0.w);
    vec4 sh04 = decompose(splat.sh1.x);
    vec4 sh05 = decompose(splat.sh1.y);

    sh[4] = vec3(sh02.y, sh02.z, sh02.w);
    sh[5] = vec3(sh03.x, sh03.y, sh03.z);
    sh[6] = vec3(sh03.w, sh04.x, sh04.y);
    sh[7] = vec3(sh04.z, sh04.w, sh05.x);
    sh[8] = vec3(sh05.y, sh05.z, sh05.w);
#endif
#if SH_DEGREE > 2
    vec4 sh06 = decompose(splat.sh1.z);
    vec4 sh07 = decompose(splat.sh1.w);
    vec4 sh08 = decompose(splat.sh2.x);
    vec4 sh09 = decompose(splat.sh2.y);
    vec4 sh10 = decompose(splat.sh2.z);
    vec4 sh11 = decompose(splat.sh2.w);

    sh[9] = vec3(sh06.x, sh06.y, sh06.z);
    sh[10] = vec3(sh06.w, sh07.x, sh07.y);
    sh[11] = vec3(sh07.z, sh07.w, sh08.x);
    sh[12] = vec3(sh08.y, sh08.z, sh08.w);
    sh[13] = vec3(sh09.x, sh09.y, sh09.z);
    sh[14] = vec3(sh09.w, sh10.x, sh10.y);
    sh[15] = vec3(sh10.z, sh10.w, sh11.x);    
#endif

    return computeColorFromSHDegree(dir, sh);
}

vec4 gaussianSplatting(vec2 meshPos, vec3 worldPos, vec2 scale, vec3 covA, vec3 covB, mat4 worldMatrix, mat4 viewMatrix, mat4 projectionMatrix)
{
    mat4 modelView = viewMatrix * worldMatrix;
    vec4 camspace = viewMatrix * vec4(worldPos,1.);
    vec4 pos2d = projectionMatrix * camspace;

    float bounds = 1.2 * pos2d.w;
    if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds
        || pos2d.y < -bounds || pos2d.y > bounds) {
        return vec4(0.0, 0.0, 2.0, 1.0);
    }

    mat3 Vrk = mat3(
        covA.x, covA.y, covA.z, 
        covA.y, covB.x, covB.y,
        covA.z, covB.y, covB.z
    );

    mat3 J = mat3(
        focal.x / camspace.z, 0., -(focal.x * camspace.x) / (camspace.z * camspace.z), 
        0., focal.y / camspace.z, -(focal.y * camspace.y) / (camspace.z * camspace.z), 
        0., 0., 0.
    );

    mat3 T = transpose(mat3(modelView)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if (lambda2 < 0.0)
    {
        return vec4(0.0, 0.0, 2.0, 1.0);
    }

    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    vec2 vCenter = vec2(pos2d);
    return vec4(
        vCenter 
        + ((meshPos.x * majorAxis
        + meshPos.y * minorAxis) * invViewport * pos2d.w) * scale, pos2d.zw);
}

void main () {
    Splat splat = readSplat(splatIndex);
    vec3 covA = splat.covA.xyz;
    vec3 covB = vec3(splat.covA.w, splat.covB.xy);

    vec4 worldPos = modelMatrix * vec4(splat.center.xyz, 1.0);

    vColor = splat.color;
    vPosition = position.xy;

    gl_Position = gaussianSplatting(vPosition, worldPos.xyz, vec2(1.,1.), covA, covB, modelMatrix, viewMatrix, projectionMatrix);

}

`,vl=`

precision highp float;
#include <common>

varying vec4 vColor;
varying vec2 vPosition;

vec4 gaussianColor(vec4 inColor)
{
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    float B = exp(A) * inColor.a;

    vec3 color = inColor.rgb;

    return vec4(color, B);
}


void main () { 

    gl_FragColor = gaussianColor(vColor);
}
`;class Cs{static build(e=0){const t={SH_DEGREE:e},s={invViewport:{type:"v2",value:new A.Vector2},dataTextureSize:{type:"v2",value:new A.Vector2},focal:{type:"v2",value:new A.Vector2},covariancesATexture:{type:"t",value:null},covariancesBTexture:{type:"t",value:null},centersTexture:{type:"t",value:null},colorsTexture:{type:"t",value:null},shTexture0:{type:"t",value:null},shTexture1:{type:"t",value:null},shTexture2:{type:"t",value:null}};return new A.ShaderMaterial({uniforms:s,defines:t,vertexShader:wl,fragmentShader:vl,transparent:!0,alphaTest:1,blending:A.NormalBlending,depthTest:!0,depthWrite:!1,side:A.DoubleSide})}static updateUniforms(e,t,s){var u;if(!s.material||!(s.material instanceof A.ShaderMaterial)){console.warn("GaussianSplattingMaterial: No material found on mesh");return}const n=s.material,i=n.uniforms,r=new A.Vector2;e.getSize(r);const o=r.x,c=r.y;if(i.invViewport.value.set(1/(o/1),1/c),t){const d=t.projectionMatrix.elements[0]*.5*o,f=t.projectionMatrix.elements[5]*.5*c;i.focal.value.set(d,f)}const h=s;if(h.covariancesATexture){const d=h.covariancesATexture.image.width,f=h.covariancesATexture.image.height;if(i.dataTextureSize.value.set(d,f),i.covariancesATexture.value=h.covariancesATexture,i.covariancesBTexture.value=h.covariancesBTexture,i.centersTexture.value=h.centersTexture,i.colorsTexture.value=h.colorsTexture,h.shTextures)for(let p=0;p<((u=h.shTextures)==null?void 0:u.length);p++)i[`shTexture${p}`].value=h.shTextures[p]}n.uniformsNeedUpdate=!0}}function On(a,e,t){try{const s=a.next();s.done?e(s):s.value?s.value.then(()=>{s.value=void 0,e(s)},t):e(s)}catch(s){t(s)}}function Is(a=25){let e;return(t,s,n)=>{const i=performance.now();e===void 0||i-e>a?(e=i,setTimeout(()=>{On(t,s,n)},0)):On(t,s,n)}}function Ba(a,e,t,s,n){const i=()=>{let r;const o=c=>{c.done?t(c.value):r===void 0?r=!0:i()};do r=void 0,!n||!n.aborted?e(a,o,s):s(new Error("Aborted")),r===void 0&&(r=!1);while(r)};i()}function xa(a,e){let t;return Ba(a,On,s=>t=s,s=>{throw s},e),t}function ys(a,e,t){return new Promise((s,n)=>{Ba(a,e,s,n,t)})}const ye=class ye{constructor(){this.vertexCount=0,this.hasInit=!1,this.abortController=null,this.onmessage=null}terminate(){this.abortController&&(this.abortController.abort(),this.abortController=null),this.vertexCount=0,this.positions=null,this.splatIndex=null,this.onmessage=null}_initSortData(){if(this.hasInit)return;const e=this.vertexCount;e<0||(this.depthValues=new Int32Array(e),this.splatIndex=new Uint32Array(e),this.tempDepths=new Int32Array(e),this.tempIndices=new Uint32Array(e),this.hasInit=!0)}*_sortData(e,t){this.hasInit||this._initSortData();const s=this.positions,n=this.vertexCount,i=this.depthValues,r=this.splatIndex,o=this.tempDepths,c=this.tempIndices;let l=1/0;for(let d=0;d<n;d++){r[d]=d;const f=e[2]*s[4*d]+e[6]*s[4*d+1]+e[10]*s[4*d+2],p=Math.floor(f*4096);i[d]=p,l=Math.min(l,p)}t&&(ye._iWorkCount+=n,ye._iWorkCount>ye._SplatBatchSize&&(ye._iWorkCount=0,yield));const h=-l;for(let d=0;d<n;d++)i[d]+=h;const u=new Uint32Array(256);for(let d=0;d<32;d+=8){u.fill(0);for(let p=0;p<n;p++){const g=i[p]>>d&255;u[g]+=1}let f=0;for(let p=0;p<u.length;p++){const g=u[p];u[p]=f,f+=g}for(let p=0;p<n;p++){const g=i[p]>>d&255,m=u[g];u[g]+=1,o[m]=i[p],c[m]=r[p]}i.set(o),r.set(c),t&&(ye._iWorkCount+=n,ye._iWorkCount>ye._SplatBatchSize&&(ye._iWorkCount=0,yield))}}init(e,t){this.positions=e,this.vertexCount=t,this._initSortData()}async sortDataAsync(e){this.abortController=new AbortController;const t=this.abortController.signal;return ys(this._sortData(e,!0),Is(),t).then(()=>{this.onmessage&&this.onmessage(this.splatIndex)}).catch(s=>{console.error(s)}).finally(()=>{this.abortController=null})}};ye._SplatBatchSize=327680,ye._iWorkCount=0;let Rn=ye;function mt(a){return A.DataUtils.toHalfFloat(a)}const Ee=class Ee extends A.Mesh{constructor(){super(),this._vertexCount=0,this._worker=null,this._frameIdLastUpdate=-1,this._frameIdThisUpdate=0,this._cameraMatrix=null,this._modelViewMatrix=null,this._canPostToWorker=!1,this._readyToDisplay=!1,this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._splatPositions=null,this._splatPositions2=null,this._splatIndex=null,this._splatIndex2=null,this._shTextures=null,this._splatsData=null,this._sh=null,this._keepInRam=!1,this._oldDirection=new A.Vector3,this._useRGBACovariants=!1,this._tmpCovariances=[0,0,0,0,0,0],this._sortIsDirty=!1,this._shDegree=0,this.isGaussianSplattingMesh=!0,this._tempQuaternion=new A.Quaternion,this._tempPosition=new A.Vector3,this._tempScale=new A.Vector3,this._tempColor=new Uint8Array(4),this._tempMatrix=new A.Matrix4,this.geometry=Nn.build(),this.material=Cs.build(),this.setEnabled(!1),this._useRGBACovariants=!0}get shDegree(){return this._shDegree}get splatsData(){return this._splatsData}get covariancesATexture(){return this._covariancesATexture}get covariancesBTexture(){return this._covariancesBTexture}get centersTexture(){return this._centersTexture}get colorsTexture(){return this._colorsTexture}get shTextures(){return this._shTextures}setEnabled(e){this.visible=e}_postToWorker(e=!1){const t=this._frameIdThisUpdate;if((e||t!==this._frameIdLastUpdate)&&this._worker&&this._cameraMatrix&&this._canPostToWorker){const s=this._cameraMatrix;this._modelViewMatrix=new A.Matrix4().multiplyMatrices(s,this.matrixWorld);let n=s.clone().invert(),i=new A.Matrix4().multiplyMatrices(n,this.matrixWorld);const r=new A.Vector3(0,0,1).transformDirection(i),o=r.dot(this._oldDirection);if(e||Math.abs(o-1)>=.01)return this._oldDirection.copy(r),this._frameIdLastUpdate=t,this._canPostToWorker=!1,this._worker.sortDataAsync(this._modelViewMatrix.elements)}}onBeforeRender(e,t,s,n,i,r){this._frameIdThisUpdate=e.info.render.frame,this.sortDataAsync(s),Cs.updateUniforms(e,s,this),super.onBeforeRender(e,t,s,n,i,r)}loadDataAsync(e){return this.updateDataAsync(e)}dispose(){var e,t,s,n,i;(e=this._covariancesATexture)==null||e.dispose(),(t=this._covariancesBTexture)==null||t.dispose(),(s=this._centersTexture)==null||s.dispose(),(n=this._colorsTexture)==null||n.dispose(),this._shTextures&&this._shTextures.forEach(r=>{r.dispose()}),this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._shTextures=null,(i=this._worker)==null||i.terminate(),this._worker=null}_copyTextures(e){var t,s,n,i;this._covariancesATexture=(t=e.covariancesATexture)==null?void 0:t.clone(),this._covariancesBTexture=(s=e.covariancesBTexture)==null?void 0:s.clone(),this._centersTexture=(n=e.centersTexture)==null?void 0:n.clone(),this._colorsTexture=(i=e.colorsTexture)==null?void 0:i.clone(),e._shTextures&&(this._shTextures=[],this._shTextures.forEach(r=>{var o;(o=this._shTextures)==null||o.push(r.clone())}))}clone(e){const t=new Ee;return t.geometry=this.geometry.clone(),t.material=this.material.clone(),t._vertexCount=this._vertexCount,t._copyTextures(this),t._splatPositions=this._splatPositions,t._readyToDisplay=!1,t._instanciateWorker(),t._vertexCount=t._vertexCount,t}_makeSplatFromComonents(e,t,s,n,i,r,o,c,l,h,u){i.w=-i.w,n=n.multiplyScalar(2);const d=this._tempMatrix.elements,f=this._useRGBACovariants?4:2;this._splatPositions[4*e+0]=s.x,this._splatPositions[4*e+1]=s.y,this._splatPositions[4*e+2]=s.z,this._splatPositions2[4*e+0]=s.x,this._splatPositions2[4*e+1]=s.y,this._splatPositions2[4*e+2]=s.z,h.min(s),u.max(s);const p=i.x,g=i.y,m=i.z,I=i.w,b=p+p,C=g+g,y=m+m,B=p*b,v=p*C,_=p*y,x=g*C,w=g*y,S=m*y,Q=I*b,E=I*C,N=I*y,k=n.x,O=n.y,P=n.z;d[0]=(1-(x+S))*k,d[1]=(v+N)*O,d[2]=(_-E)*P,d[4]=(v-N)*k,d[5]=(1-(B+S))*O,d[6]=(w+Q)*P,d[8]=(_+E)*k,d[9]=(w-Q)*O,d[10]=(1-(B+x))*P;const M=d,j=this._tmpCovariances;j[0]=M[0]*M[0]+M[1]*M[1]+M[2]*M[2],j[1]=M[0]*M[4]+M[1]*M[5]+M[2]*M[6],j[2]=M[0]*M[8]+M[1]*M[9]+M[2]*M[10],j[3]=M[4]*M[4]+M[5]*M[5]+M[6]*M[6],j[4]=M[4]*M[8]+M[5]*M[9]+M[6]*M[10],j[5]=M[8]*M[8]+M[9]*M[9]+M[10]*M[10];let q=-1e4;for(let Z=0;Z<6;Z++)q=Math.max(q,Math.abs(j[Z]));this._splatPositions[4*e+3]=q,this._splatPositions2[4*e+3]=q;const z=q;o[t*4+0]=mt(j[0]/z),o[t*4+1]=mt(j[1]/z),o[t*4+2]=mt(j[2]/z),o[t*4+3]=mt(j[3]/z),c[t*f+0]=mt(j[4]/z),c[t*f+1]=mt(j[5]/z),l[t*4+0]=r[0],l[t*4+1]=r[1],l[t*4+2]=r[2],l[t*4+3]=r[3]}_makeSplatFromAttribute(e,t,s,n,i,r,o,c,l,h,u,d,f=!1){const p=e,g=this._tempPosition,m=this._tempQuaternion,I=this._tempScale,b=this._tempColor,C=f?255:1;g.x=s.getX(p),g.y=s.getY(p),g.z=s.getZ(p),I.x=n.getX(p),I.y=n.getY(p),I.z=n.getZ(p),m.x=i.getX(p),m.y=i.getY(p),m.z=i.getZ(p),m.w=i.getW(p),m.normalize(),b[0]=r.getX(p)*C,b[1]=r.getY(p)*C,b[2]=r.getZ(p)*C,b[3]=(o?o.getX(p):r.getW(p))*C,this._makeSplatFromComonents(e,t,g,I,m,b,c,l,h,u,d)}_makeSplatFromBuffer(e,t,s,n,i,r,o,c,l){const h=this._tempPosition,u=this._tempQuaternion,d=this._tempScale,f=this._tempColor;h.x=s[8*e+0],h.y=s[8*e+1],h.z=s[8*e+2],d.x=s[8*e+3+0],d.y=s[8*e+3+1],d.z=s[8*e+3+2],u.x=(n[32*e+28+1]-127.5)/127.5,u.y=(n[32*e+28+2]-127.5)/127.5,u.z=(n[32*e+28+3]-127.5)/127.5,u.w=(n[32*e+28+0]-127.5)/127.5,u.normalize(),f[0]=n[32*e+24+0],f[1]=n[32*e+24+1],f[2]=n[32*e+24+2],f[3]=n[32*e+24+3],this._makeSplatFromComonents(e,t,h,d,u,f,i,r,o,c,l)}_updateTextures(e,t,s,n){const i=this._getTextureSize(this._vertexCount),r=(h,u,d,f)=>{const p=new A.DataTexture(h,u,d,f,A.FloatType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return p.generateMipmaps=!1,p.needsUpdate=!0,p},o=(h,u,d,f)=>{const p=new A.DataTexture(h,u,d,f,A.UnsignedByteType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return p.generateMipmaps=!1,p.needsUpdate=!0,p},c=(h,u,d,f)=>{const p=new A.DataTexture(h,u,d,f,A.UnsignedIntType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.NearestFilter,A.NearestFilter);return p.generateMipmaps=!1,p.needsUpdate=!0,p},l=(h,u,d,f)=>{const p=new A.DataTexture(h,u,d,f,A.HalfFloatType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return p.generateMipmaps=!1,p.needsUpdate=!0,p};this._covariancesATexture=l(e,i.x,i.y,A.RGBAFormat),this._covariancesBTexture=l(t,i.x,i.y,this._useRGBACovariants?A.RGBAFormat:A.RGFormat),this._centersTexture=r(this._splatPositions,i.x,i.y,A.RGBAFormat),this._colorsTexture=o(s,i.x,i.y,A.RGBAFormat),n&&(this._shTextures=[],n.forEach(h=>{const u=new Uint32Array(h.buffer),d=c(u,i.x,i.y,A.RGBAIntegerFormat);d.wrapS=A.ClampToEdgeWrapping,d.wrapT=A.ClampToEdgeWrapping,this._shTextures.push(d)})),this._instanciateWorker()}_updateBoundingInfo(e,t){this.boundingBox=new A.Box3(e,t),this.boundingSphere=this.boundingBox.getBoundingSphere(new A.Sphere)}*_updateData(e,t,s){this._covariancesATexture||(this._readyToDisplay=!1);const n=new Uint8Array(e),i=new Float32Array(n.buffer);this._keepInRam&&(this._splatsData=e,s&&(this._sh=s)),this._shDegree=s?s.length:0;const r=n.length/Ee._RowOutputLength;r!=this._vertexCount&&(this._vertexCount=r,this.geometry=Nn.build(this._vertexCount),this.material=Cs.build(this._shDegree),this._updateSplatIndexBuffer(this._vertexCount));const o=this._getTextureSize(r),c=o.x*o.y,l=o.y;o.x*l,this._splatPositions=new Float32Array(4*c),this._splatPositions2=new Float32Array(4*r);const h=new Uint16Array(c*4),u=new Uint16Array((this._useRGBACovariants?4:2)*c),d=new Uint8Array(c*4),f=new A.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),p=new A.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);{for(let g=0;g<r;g++)this._makeSplatFromBuffer(g,g,i,n,h,u,d,f,p),t&&g%Ee._SplatBatchSize===0&&(yield);this._updateTextures(h,u,d,s),this._updateBoundingInfo(f,p),this.setEnabled(!0)}this._postToWorker(!0)}async updateDataAsync(e,t){return ys(this._updateData(e,!0,t),Is())}updateData(e,t){xa(this._updateData(e,!1,t))}*_updateDataFromGeometry(e,t){this._covariancesATexture||(this._readyToDisplay=!1);const s=e.getAttribute("position"),n=e.getAttribute("scale"),i=e.getAttribute("color"),r=e.getAttribute("opacity"),o=e.getAttribute("rotation");let c=i.array instanceof Float32Array,l=i.normalized;i.normalized=!1,this._shDegree=0;const h=s.count;h!=this._vertexCount&&(this._vertexCount=h,this.geometry=Nn.build(this._vertexCount),this.material=Cs.build(this._shDegree),this._updateSplatIndexBuffer(this._vertexCount));const u=this._getTextureSize(h),d=u.x*u.y,f=u.y;u.x*f,this._splatPositions=new Float32Array(4*d),this._splatPositions2=new Float32Array(4*h);const p=new Uint16Array(d*4),g=new Uint16Array((this._useRGBACovariants?4:2)*d),m=new Uint8Array(d*4),I=new A.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),b=new A.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);{for(let C=0;C<h;C++)this._makeSplatFromAttribute(C,C,s,n,o,i,r,p,g,m,I,b,c),t&&C%Ee._SplatBatchSize===0&&(yield);this._updateTextures(p,g,m),this._updateBoundingInfo(I,b),this.setEnabled(!0)}i.normalized=l,this._postToWorker(!0)}updateDataFromGeometryAsync(e){return ys(this._updateDataFromGeometry(e,!0),Is())}sortDataAsync(e,t=!1){if(!this._worker||!e)return Promise.resolve();this._cameraMatrix=e.matrixWorldInverse;const s=this._postToWorker(t);return s||Promise.resolve()}updateDataFromGeometry(e){xa(this._updateDataFromGeometry(e,!1))}_updateSplatIndexBuffer(e){if(!this._splatIndex||e>this._splatIndex.length){this._splatIndex=new Float32Array(e);for(let t=0;t<e;t++)this._splatIndex[t]=t;this.geometry.attributes.splatIndex.set(this._splatIndex),this.geometry.attributes.splatIndex.needsUpdate=!0}this.geometry.instanceCount=e}_instanciateWorker(){var s;if(!this._vertexCount)return;this._updateSplatIndexBuffer(this._vertexCount),(s=this._worker)==null||s.terminate(),this._worker=new Rn;const e=this._splatPositions2,t=this._vertexCount;this._worker.init(e,t),this._canPostToWorker=!0,this._worker.onmessage=n=>{if(this._splatIndex&&n){for(let i=0;i<this._vertexCount;i++)this._splatIndex[i]=n[i];this.geometry.attributes.splatIndex.set(this._splatIndex)}this.geometry.attributes.splatIndex.needsUpdate=!0,this._canPostToWorker=!0,this._readyToDisplay=!0,this._sortIsDirty&&(this._postToWorker(!0),this._sortIsDirty=!1)}}_getTextureSize(e){let n=1;for(;4096*n<e;)n*=2;return n>4096&&(console.error("GaussianSplatting texture size: (4096, "+n+"), maxTextureSize: 4096"),n=4096),new A.Vector2(4096,n)}};Ee._RowOutputLength=3*4+3*4+4+4,Ee._SH_C0=.28209479177387814,Ee._SplatBatchSize=327680,Ee._PlyConversionBatchSize=32768;let Nt=Ee;class Sl extends A.Loader{constructor(e){super(e)}load(e,t,s,n){const i=new A.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,r=>{this.parse(r,t,n)},s,n)}parse(e,t,s){const n=new Nt;n.loadDataAsync(e).then(()=>{t(n)}).catch(i=>{s?s(i):console.error(i)})}}const Qe=(a,e)=>{const t=(1<<e)-1;return(a&t)/t},_a=(a,e)=>{e.x=Qe(a>>>21,11),e.y=Qe(a>>>11,10),e.z=Qe(a,11)},Ql=(a,e)=>{e[0]=Qe(a>>>24,8)*255,e[1]=Qe(a>>>16,8)*255,e[2]=Qe(a>>>8,8)*255,e[3]=Qe(a,8)*255},Ml=(a,e)=>{const t=1/(Math.sqrt(2)*.5),s=(Qe(a>>>20,10)-.5)*t,n=(Qe(a>>>10,10)-.5)*t,i=(Qe(a,10)-.5)*t,r=Math.sqrt(1-(s*s+n*n+i*i));switch(a>>>30){case 0:e.set(r,s,n,i);break;case 1:e.set(s,r,n,i);break;case 2:e.set(s,n,r,i);break;case 3:e.set(s,n,i,r);break}},ie=class ie extends A.Loader{constructor(e){super(e)}load(e,t,s,n){const i=new A.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,r=>{this.parse(r,t,n)},s,n)}parse(e,t,s){ie.ConvertPLYToSplatAsync(e).then(n=>{const i=new Nt;i.loadDataAsync(n).then(()=>{t(i)})}).catch(n=>{s?s(n):console.error(n)})}static async ConvertPLYToSplatAsync(e){return ys(ie.ConvertPLYToSplat(e,!0),Is())}static*ConvertPLYToSplat(e,t=!1){const s=ie.ParseHeader(e);if(!s)return e;const n={value:0},i=ie._GetCompressedChunks(s,n);for(let r=0;r<s.vertexCount;r++)ie._GetSplat(s,r,i,n),r%ie._PlyConversionBatchSize===0&&t&&(yield);return s.buffer}static _GetCompressedChunks(e,t){if(!e.chunkCount)return null;const s=e.dataView,n=new Array(e.chunkCount);for(let i=0;i<e.chunkCount;i++){const r={min:new A.Vector3,max:new A.Vector3,minScale:new A.Vector3,maxScale:new A.Vector3};n[i]=r;for(let o=0;o<e.chunkProperties.length;o++){const c=e.chunkProperties[o];let l;switch(c.type){case 0:l=s.getFloat32(c.offset+t.value,!0);break;default:continue}switch(c.value){case 0:r.min.x=l;break;case 1:r.min.y=l;break;case 2:r.min.z=l;break;case 3:r.max.x=l;break;case 4:r.max.y=l;break;case 5:r.max.z=l;break;case 6:r.minScale.x=l;break;case 7:r.minScale.y=l;break;case 8:r.minScale.z=l;break;case 9:r.maxScale.x=l;break;case 10:r.maxScale.y=l;break;case 11:r.maxScale.z=l;break}}t.value+=e.rowChunkLength}return n}static _GetSplat(e,t,s,n){const i=new A.Quaternion,r=new A.Vector3,o=ie._RowOutputLength,c=e.buffer,l=e.dataView,h=new Float32Array(c,t*o,3),u=new Float32Array(c,t*o+12,3),d=new Uint8ClampedArray(c,t*o+24,4),f=new Uint8ClampedArray(c,t*o+28,4),p=t>>8;let g=255,m=0,I=0,b=0;for(let C=0;C<e.vertexProperties.length;C++){const y=e.vertexProperties[C];let B;switch(y.type){case 0:B=l.getFloat32(n.value+y.offset,!0);break;case 1:B=l.getInt32(n.value+y.offset,!0);break;case 2:B=l.getUint32(n.value+y.offset,!0);break;case 3:B=l.getFloat64(n.value+y.offset,!0);break;case 4:B=l.getUint8(n.value+y.offset);break;default:continue}switch(y.value){case 12:{const v=s[p];_a(B,r),h[0]=A.MathUtils.lerp(v.min.x,v.max.x,r.x),h[1]=-A.MathUtils.lerp(v.min.y,v.max.y,r.y),h[2]=A.MathUtils.lerp(v.min.z,v.max.z,r.z)}break;case 13:Ml(B,i),g=i.w,m=i.z,I=i.y,b=i.x;break;case 14:{const v=s[p];_a(B,r),u[0]=Math.exp(A.MathUtils.lerp(v.minScale.x,v.maxScale.x,r.x)),u[1]=Math.exp(A.MathUtils.lerp(v.minScale.y,v.maxScale.y,r.y)),u[2]=Math.exp(A.MathUtils.lerp(v.minScale.z,v.maxScale.z,r.z))}break;case 15:Ql(B,d);break;case 16:h[0]=B;break;case 17:h[1]=B;break;case 18:h[2]=B;break;case 19:u[0]=Math.exp(B);break;case 20:u[1]=Math.exp(B);break;case 21:u[2]=Math.exp(B);break;case 22:d[0]=B;break;case 23:d[1]=B;break;case 24:d[2]=B;break;case 26:d[0]=(.5+ie._SH_C0*B)*255;break;case 27:d[1]=(.5+ie._SH_C0*B)*255;break;case 28:d[2]=(.5+ie._SH_C0*B)*255;break;case 29:d[3]=(.5+ie._SH_C0*B)*255;break;case 25:d[3]=1/(1+Math.exp(-B))*255;break;case 30:g=B;break;case 31:m=B;break;case 32:I=B;break;case 33:b=B;break}}i.set(m,I,b,g),i.normalize(),f[0]=i.w*128+128,f[1]=i.x*128+128,f[2]=i.y*128+128,f[3]=i.z*128+128,n.value+=e.rowVertexLength}static _TypeNameToEnum(e){switch(e){case"float":return 0;case"int":return 1;case"uint":return 2;case"double":return 3;case"uchar":return 4}return 5}static _ValueNameToEnum(e){switch(e){case"min_x":return 0;case"min_y":return 1;case"min_z":return 2;case"max_x":return 3;case"max_y":return 4;case"max_z":return 5;case"min_scale_x":return 6;case"min_scale_y":return 7;case"min_scale_z":return 8;case"max_scale_x":return 9;case"max_scale_y":return 10;case"max_scale_z":return 11;case"packed_position":return 12;case"packed_rotation":return 13;case"packed_scale":return 14;case"packed_color":return 15;case"x":return 16;case"y":return 17;case"z":return 18;case"scale_0":return 19;case"scale_1":return 20;case"scale_2":return 21;case"diffuse_red":case"red":return 22;case"diffuse_green":case"green":return 23;case"diffuse_blue":case"blue":return 24;case"f_dc_0":return 26;case"f_dc_1":return 27;case"f_dc_2":return 28;case"f_dc_3":return 29;case"opacity":return 25;case"rot_0":return 30;case"rot_1":return 31;case"rot_2":return 32;case"rot_3":return 33}return 34}static ParseHeader(e){const t=new Uint8Array(e),s=new TextDecoder().decode(t.slice(0,1024*10)),n=`end_header
`,i=s.indexOf(n);if(i<0||!s)return null;const r=parseInt(/element vertex (\d+)\n/.exec(s)[1]),o=/element chunk (\d+)\n/.exec(s);let c=0;o&&(c=parseInt(o[1]));let l=0,h=0;const u={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let d;(C=>{C[C.Vertex=0]="Vertex",C[C.Chunk=1]="Chunk"})(d||(d={}));let f=1;const p=[],g=[],m=s.slice(0,i).split(`
`);for(const C of m)if(C.startsWith("property ")){const[,y,B]=C.split(" "),v=ie._ValueNameToEnum(B),_=ie._TypeNameToEnum(y);f==1?(g.push({value:v,type:_,offset:h}),h+=u[y]):f==0&&(p.push({value:v,type:_,offset:l}),l+=u[y])}else if(C.startsWith("element ")){const[,y]=C.split(" ");y=="chunk"?f=1:y=="vertex"&&(f=0)}const I=new DataView(e,i+n.length),b=new ArrayBuffer(ie._RowOutputLength*r);return{vertexCount:r,chunkCount:c,rowVertexLength:l,rowChunkLength:h,vertexProperties:p,chunkProperties:g,dataView:I,buffer:b}}};ie._RowOutputLength=3*4+3*4+4+4,ie._SH_C0=.28209479177387814,ie._SplatBatchSize=327680,ie._PlyConversionBatchSize=32768;let Vn=ie;const wa="KHR_gaussian_splatting",Dl={POSITION:"position",COLOR_0:"color",_SCALE:"scale",_ROTATION:"rotation",_OPACITY:"opacity"},va={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};class Ll{constructor(e,t){this.parser=e,this.camera=t,this.name=wa}loadMesh(e){const t=this.parser,s=this.camera,n=t.json.extensionsUsed;if(!n||!n.includes(wa))return;const o=t.json.meshes[e].primitives,c=[];return c.push(this.loadGeometries(o)),Promise.all(c).then(function(l){const h=l[l.length-1],u=[];function d(f,p){const g=new Nt;return g.updateDataFromGeometryAsync(f).then(()=>(f.dispose(),g.sortDataAsync(s))).then(()=>g)}for(let f=0,p=h.length;f<p;f++){const g=h[f];u.push(d(g))}return Promise.all(u).then(f=>{const p=new A.Group;for(let g=0,m=f.length;g<m;g++){const I=f[g];p.add(I)}return t.associations.set(p,{meshes:e}),p})})}loadGeometries(e){const t=this.parser,s=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];let o=this.addPrimitiveAttributes(new A.BufferGeometry,r,t);s.push(o)}return Promise.all(s)}addPrimitiveAttributes(e,t,s){const n=t.attributes,i=[];function r(o,c){return s.getDependency("accessor",o).then(function(l){e.setAttribute(c,l)})}for(const o in n){const c=Dl[o]||o.toLowerCase();c in e.attributes||i.push(r(n[o],c))}if(t.indices!==void 0&&!e.index){const o=s.getDependency("accessor",t.indices).then(function(c){e.setIndex(c)});i.push(o)}return El(e,t,s),Promise.all(i).then(function(){return e})}}function El(a,e,t){const s=e.attributes,n=new A.Box3;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(n.set(new A.Vector3(c[0],c[1],c[2]),new A.Vector3(l[0],l[1],l[2])),o.normalized){const h=Sa(va[o.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new A.Vector3,c=new A.Vector3;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],f=d.min,p=d.max;if(f!==void 0&&p!==void 0){if(c.setX(Math.max(Math.abs(f[0]),Math.abs(p[0]))),c.setY(Math.max(Math.abs(f[1]),Math.abs(p[1]))),c.setZ(Math.max(Math.abs(f[2]),Math.abs(p[2]))),d.normalized){const g=Sa(va[d.componentType]);c.multiplyScalar(g)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}a.boundingBox=n;const r=new A.Sphere;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,a.boundingSphere=r}function Sa(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class Qa extends Xe{constructor(e){super(),this._options=e,this._animGroup=void 0}addToScene(e){this._scene=e,this.name=this._options.id+"-root";const t=new A.Group;t.name=this.id+"-anim",this.add(t),this._animGroup=t;const{rootUrl:s,fileName:n,fileNames:i,callback:r}=this._options;return n?this.loadAssetContainer(s,n,r):Array.isArray(i)?i.forEach(o=>{this.loadAssetContainer(s,o,r)}):typeof i=="string"?this.loadAssetContainer(s,i,r):i==null&&this.loadAssetContainer(s,"",r),super.addToScene(e)}removeFromScene(){return this._animGroup&&(this._animGroup.clear(),this.remove(this._animGroup),this._animGroup=void 0),super.removeFromScene()}async onLoadModel(e,t){await this._scene.compileAsync(e),this._animGroup.add(e),this.updateModelTransform(e),t&&t(this._animGroup)}async loadAssetContainer(e,t,s){if(e=e||"",!t||t===""){const r=e.lastIndexOf("/");t=e.substring(r+1),e=e.substring(0,r+1)}const n=(t||e).split(".").pop(),i=this;switch(n){case"ifc":break;case"ply":{const r=new Vn;r.setPath(e),r.load(t,async o=>{i.onLoadModel(o,s)})}break;case"splat":{const r=new Sl;r.setPath(e),r.load(t,async o=>{i.onLoadModel(o,s)})}break;case"gltf":case"glb":{const r=it.getDracoLoader(this._options.dracoLoaderPath),o=it.getKtxLoader(this._options.ktx2LoaderPath);o.detectSupport(this._scene.getWebGLRenderer());const c=new Zt;c.setDRACOLoader(r),c.setKTX2Loader(o),c.setMeshoptDecoder(fa),c.register(l=>new Ll(l)),c.setPath(e),c.load(t,async l=>{const h=l.scene;i.onLoadModel(h,s)})}break;case"obj":case"fbx":default:{n&&n!==""&&console.warn("Unsupported file type: "+n);const r=new A.Group;i.onLoadModel(r,s)}return}}updateSceneTransform(){let e=this._options.position;if(!e||!this._scene)return;const t=this._scene.toScenePosition(e);this.position.set(t.x,t.y,t.z),this.updateMatrixWorld(!0)}setPosition(e){(this._options.position[0]!==e[0]||this._options.position[1]!==e[1])&&(this._options.position=e,this.updateSceneTransform())}updateModelTransform(e){let t=this._options.offset||[0,0,0],s=this._options.rotation||[0,0,0],n=this._options.scale||1;e.position.set(t[0],t[1],t[2]),e.rotation.set(_e.degToRad(s[0]),_e.degToRad(s[1]),_e.degToRad(s[2])),e.scale.set(n,n,n),e.updateMatrixWorld(!0)}}function Fl(a){if(Array.isArray(a))return a;switch(a.type){case"Feature":return[a];case"FeatureCollection":return a.features;default:return[{geometry:a}]}}function Tl(a,e,t={}){const s={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:n=0,endRow:i=a.length}=t;for(let r=n;r<i;r++){const o=a[r],{geometry:c}=o;if(c)if(c.type==="GeometryCollection"){const{geometries:l}=c;for(let h=0;h<l.length;h++){const u=l[h];Da(u,s,e,o,r)}}else Da(c,s,e,o,r)}return s}function Ma(a){if(a.length>2){const e=a[0],t=a[a.length-1];(t[0]!==e[0]||t[1]!==e[1])&&a.push(e)}}function Da(a,e,t,s,n){const{type:i,coordinates:r}=a,{pointFeatures:o,lineFeatures:c,polygonFeatures:l,polygonOutlineFeatures:h}=e;if(Gl(i,r))switch(i){case"Point":o.push(t({geometry:a},s,n));break;case"MultiPoint":r.forEach(u=>{o.push(t({geometry:{type:"Point",coordinates:u}},s,n))});break;case"LineString":c.push(t({geometry:a},s,n));break;case"MultiLineString":r.forEach(u=>{c.push(t({geometry:{type:"LineString",coordinates:u}},s,n))});break;case"Polygon":l.push(t({geometry:a},s,n)),r.forEach(u=>{Ma(u),h.push(t({geometry:{type:"LineString",coordinates:u}},s,n))});break;case"MultiPolygon":r.forEach(u=>{l.push(t({geometry:{type:"Polygon",coordinates:u}},s,n)),u.forEach(d=>{Ma(d),h.push(t({geometry:{type:"LineString",coordinates:d}},s,n))})});break}}const kl={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function Gl(a,e){let t=kl[a];for(;e&&--t>0;)e=e[0];return e&&Number.isFinite(e[0])}function Ot(a,e){const t=a.type;if(t==="Point")e(a.coordinates);else if(t==="MultiPoint"||t==="LineString")for(let s=0;s<a.coordinates.length;s++)e(a.coordinates[s]);else if(t==="MultiLineString"||t==="Polygon")for(let s=0;s<a.coordinates.length;s++)for(let n=0;n<a.coordinates[s].length;n++)e(a.coordinates[s][n]);else if(t==="MultiPolygon")for(let s=0;s<a.coordinates.length;s++)for(let n=0;n<a.coordinates[s].length;n++)for(let i=0;i<a.coordinates[s][n].length;i++)e(a.coordinates[s][n][i]);else if(t==="GeometryCollection")for(let s=0;s<a.geometries.length;s++)Ot(a.geometries[s],e);else if(t==="Feature")Ot(a.geometry,e);else if(t==="FeatureCollection")for(let s=0;s<a.features.length;s++)Ot(a.features[s].geometry,e)}function Pl(a){let e=0,t=0,s=0,n=0;return Ot(a,function(i){e+=i[0],t+=i[1],s+=i.length>2?i[2]:0,n++}),[e/n,t/n,s/n]}function Ul(a){var e,t,s,n,i,r;return e=t=s=1/0,n=i=r=-1/0,Ot(a,function(o){const c=o.length>2?o[2]:0;o[0]<e&&(e=o[0]),o[1]<t&&(t=o[1]),c<s&&(s=c),o[0]>n&&(n=o[0]),o[1]>i&&(i=o[1]),c>r&&(r=c)}),[[e,t,s],[n,i,r]]}async function Nl(a){let e;if(typeof a=="string"){const o=await fetch(a);if(!o.ok)throw new Error(`HTTP error! status: ${o.status}`);e=await o.json()}else Array.isArray(a)?e={type:"GeometryCollection",geometries:a}:e=a;const t=(r,o,c)=>(r.__source={object:o,index:c},r),s=Fl(e),n=Tl(s,t),i=Pl(e);return{features:s,centroid:i,geometries:n}}function Bs(a,e){const[t,s,n]=a,[i,r,o]=_e.toScenePosition(e,[t,s],n||0).toArray();return[i,r,o]}function Ol(a,e){const s=_e.updateWorldMatrix(null,e).clone().invert(),{features:n,centroid:i,geometries:r}=a,{pointFeatures:o,lineFeatures:c,polygonFeatures:l,polygonOutlineFeatures:h}=r;return o.forEach(u=>{const{geometry:d}=u;d.coordinates=Bs(d.coordinates,s)}),c.forEach(u=>{const{geometry:d}=u,{coordinates:f}=d,p=f.map(g=>Bs(g,s));d.coordinates=p}),l.forEach(u=>{const{geometry:d}=u,{coordinates:f}=d,p=f.map(g=>g.map(I=>Bs(I,s)));d.coordinates=p}),h.forEach(u=>{const{geometry:d}=u,{coordinates:f}=d,p=f.map(g=>Bs(g,s));d.coordinates=p}),{features:n,centroid:i,geometries:r}}function bt(a,e){return typeof a=="function"&&e?a(e):a}A.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new A.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},A.ShaderLib.line={uniforms:A.UniformsUtils.merge([A.UniformsLib.common,A.UniformsLib.fog,A.UniformsLib.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			float alpha = opacity;
			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class La extends A.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:A.UniformsUtils.clone(A.ShaderLib.line.uniforms),vertexShader:A.ShaderLib.line.vertexShader,fragmentShader:A.ShaderLib.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){e===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){e===!0!==this.dashed&&(this.needsUpdate=!0),e===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(e===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),e===!0?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const Ea=new A.Box3,xs=new A.Vector3;class Fa extends A.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new A.Float32BufferAttribute(e,3)),this.setAttribute("uv",new A.Float32BufferAttribute(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),s.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const s=new A.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceStart",new A.InterleavedBufferAttribute(s,3,0)),this.setAttribute("instanceEnd",new A.InterleavedBufferAttribute(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const s=new A.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceColorStart",new A.InterleavedBufferAttribute(s,3,0)),this.setAttribute("instanceColorEnd",new A.InterleavedBufferAttribute(s,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new A.WireframeGeometry(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new A.Box3);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Ea.setFromBufferAttribute(t),this.boundingBox.union(Ea))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new A.Sphere),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let n=0;for(let i=0,r=e.count;i<r;i++)xs.fromBufferAttribute(e,i),n=Math.max(n,s.distanceToSquared(xs)),xs.fromBufferAttribute(t,i),n=Math.max(n,s.distanceToSquared(xs));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}const zn=new A.Vector4,Ta=new A.Vector3,ka=new A.Vector3,oe=new A.Vector4,ce=new A.Vector4,Me=new A.Vector4,jn=new A.Vector3,qn=new A.Matrix4,Ae=new A.Line3,Ga=new A.Vector3,_s=new A.Box3,ws=new A.Sphere,De=new A.Vector4;let Le,rt;function Pa(a,e,t){return De.set(0,0,-e,1).applyMatrix4(a.projectionMatrix),De.multiplyScalar(1/De.w),De.x=rt/t.width,De.y=rt/t.height,De.applyMatrix4(a.projectionMatrixInverse),De.multiplyScalar(1/De.w),Math.abs(Math.max(De.x,De.y))}function Rl(a,e){const t=a.matrixWorld,s=a.geometry,n=s.attributes.instanceStart,i=s.attributes.instanceEnd,r=Math.min(s.instanceCount,n.count);for(let o=0,c=r;o<c;o++){Ae.start.fromBufferAttribute(n,o),Ae.end.fromBufferAttribute(i,o),Ae.applyMatrix4(t);const l=new A.Vector3,h=new A.Vector3;Le.distanceSqToSegment(Ae.start,Ae.end,h,l),h.distanceTo(l)<rt*.5&&e.push({point:h,pointOnLine:l,distance:Le.origin.distanceTo(h),object:a,face:null,faceIndex:o,uv:null,uv1:null})}}function Vl(a,e,t){const s=e.projectionMatrix,i=a.material.resolution,r=a.matrixWorld,o=a.geometry,c=o.attributes.instanceStart,l=o.attributes.instanceEnd,h=Math.min(o.instanceCount,c.count),u=-e.near;Le.at(1,Me),Me.w=1,Me.applyMatrix4(e.matrixWorldInverse),Me.applyMatrix4(s),Me.multiplyScalar(1/Me.w),Me.x*=i.x/2,Me.y*=i.y/2,Me.z=0,jn.copy(Me),qn.multiplyMatrices(e.matrixWorldInverse,r);for(let d=0,f=h;d<f;d++){if(oe.fromBufferAttribute(c,d),ce.fromBufferAttribute(l,d),oe.w=1,ce.w=1,oe.applyMatrix4(qn),ce.applyMatrix4(qn),oe.z>u&&ce.z>u)continue;if(oe.z>u){const C=oe.z-ce.z,y=(oe.z-u)/C;oe.lerp(ce,y)}else if(ce.z>u){const C=ce.z-oe.z,y=(ce.z-u)/C;ce.lerp(oe,y)}oe.applyMatrix4(s),ce.applyMatrix4(s),oe.multiplyScalar(1/oe.w),ce.multiplyScalar(1/ce.w),oe.x*=i.x/2,oe.y*=i.y/2,ce.x*=i.x/2,ce.y*=i.y/2,Ae.start.copy(oe),Ae.start.z=0,Ae.end.copy(ce),Ae.end.z=0;const g=Ae.closestPointToPointParameter(jn,!0);Ae.at(g,Ga);const m=A.MathUtils.lerp(oe.z,ce.z,g),I=m>=-1&&m<=1,b=jn.distanceTo(Ga)<rt*.5;if(I&&b){Ae.start.fromBufferAttribute(c,d),Ae.end.fromBufferAttribute(l,d),Ae.start.applyMatrix4(r),Ae.end.applyMatrix4(r);const C=new A.Vector3,y=new A.Vector3;Le.distanceSqToSegment(Ae.start,Ae.end,y,C),t.push({point:y,pointOnLine:C,distance:Le.origin.distanceTo(y),object:a,face:null,faceIndex:d,uv:null,uv1:null})}}}class zl extends A.Mesh{constructor(e=new Fa,t=new La({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,s=e.attributes.instanceEnd,n=new Float32Array(2*t.count);for(let r=0,o=0,c=t.count;r<c;r++,o+=2)Ta.fromBufferAttribute(t,r),ka.fromBufferAttribute(s,r),n[o]=o===0?0:n[o-1],n[o+1]=n[o]+Ta.distanceTo(ka);const i=new A.InstancedInterleavedBuffer(n,2,1);return e.setAttribute("instanceDistanceStart",new A.InterleavedBufferAttribute(i,1,0)),e.setAttribute("instanceDistanceEnd",new A.InterleavedBufferAttribute(i,1,1)),this}raycast(e,t){const s=this.material.worldUnits,n=e.camera;n===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const i=e.params.Line2!==void 0&&e.params.Line2.threshold||0;Le=e.ray;const r=this.matrixWorld,o=this.geometry,c=this.material;rt=c.linewidth+i,o.boundingSphere===null&&o.computeBoundingSphere(),ws.copy(o.boundingSphere).applyMatrix4(r);let l;if(s)l=rt*.5;else{const u=Math.max(n.near,ws.distanceToPoint(Le.origin));l=Pa(n,u,c.resolution)}if(ws.radius+=l,Le.intersectsSphere(ws)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),_s.copy(o.boundingBox).applyMatrix4(r);let h;if(s)h=rt*.5;else{const u=Math.max(n.near,_s.distanceToPoint(Le.origin));h=Pa(n,u,c.resolution)}_s.expandByScalar(h),Le.intersectsBox(_s)!==!1&&(s?Rl(this,t):Vl(this,n,t))}onBeforeRender(e){const t=this.material.uniforms;t&&t.resolution&&(e.getViewport(zn),this.material.uniforms.resolution.value.set(zn.z,zn.w))}}function Rt(a,e=!1){const t=a[0].index!==null,s=new Set(Object.keys(a[0].attributes)),n=new Set(Object.keys(a[0].morphAttributes)),i={},r={},o=a[0].morphTargetsRelative,c=new A.BufferGeometry;let l=0;for(let h=0;h<a.length;++h){const u=a[h];let d=0;if(t!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const f in u.attributes){if(!s.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+f+'" attribute exists among all geometries, or in none of them.'),null;i[f]===void 0&&(i[f]=[]),i[f].push(u.attributes[f]),d++}if(d!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(o!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const f in u.morphAttributes){if(!n.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;r[f]===void 0&&(r[f]=[]),r[f].push(u.morphAttributes[f])}if(e){let f;if(t)f=u.index.count;else if(u.attributes.position!==void 0)f=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;c.addGroup(l,f,h),l+=f}}if(t){let h=0;const u=[];for(let d=0;d<a.length;++d){const f=a[d].index;for(let p=0;p<f.count;++p)u.push(f.getX(p)+h);h+=a[d].attributes.position.count}c.setIndex(u)}for(const h in i){const u=vs(i[h]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" attribute."),null;c.setAttribute(h,u)}for(const h in r){const u=r[h][0].length;if(u===0)break;c.morphAttributes=c.morphAttributes||{},c.morphAttributes[h]=[];for(let d=0;d<u;++d){const f=[];for(let g=0;g<r[h].length;++g)f.push(r[h][g][d]);const p=vs(f);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" morphAttribute."),null;c.morphAttributes[h].push(p)}}return c}function vs(a){let e,t,s,n=-1,i=0;for(let l=0;l<a.length;++l){const h=a[l];if(e===void 0&&(e=h.array.constructor),e!==h.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=h.itemSize),t!==h.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=h.normalized),s!==h.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(n===-1&&(n=h.gpuType),n!==h.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;i+=h.count*t}const r=new e(i),o=new A.BufferAttribute(r,t,s);let c=0;for(let l=0;l<a.length;++l){const h=a[l];if(h.isInterleavedBufferAttribute){const u=c/t;for(let d=0,f=h.count;d<f;d++)for(let p=0;p<t;p++){const g=h.getComponent(d,p);o.setComponent(d+u,p,g)}}else r.set(h.array,c);c+=h.count*t}return n!==void 0&&(o.gpuType=n),o}function jl(a){if(a.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),a;let e=a.groups;if(e=e.sort((r,o)=>r.materialIndex!==o.materialIndex?r.materialIndex-o.materialIndex:r.start-o.start),a.getIndex()===null){const r=a.getAttribute("position"),o=[];for(let c=0;c<r.count;c+=3)o.push(c,c+1,c+2);a.setIndex(o)}const t=a.getIndex(),s=[];for(let r=0;r<e.length;r++){const o=e[r],c=o.start,l=c+o.count;for(let h=c;h<l;h++)s.push(t.getX(h))}a.dispose(),a.setIndex(s);let n=0;for(let r=0;r<e.length;r++){const o=e[r];o.start=n,n+=o.count}let i=e[0];a.groups=[i];for(let r=1;r<e.length;r++){const o=e[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,a.groups.push(i))}return a}function ql(a){const e=a[0].index!==null,t=new Set(Object.keys(a[0].attributes)),s=new Set(Object.keys(a[0].morphAttributes)),n={},i={},r=a[0].morphTargetsRelative,o=new A.BufferGeometry;let c=0;for(let l=0;l<a.length;++l){const h=a[l];let u=0;if(e!==(h.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const d in h.attributes){if(!t.has(d))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+'. All geometries must have compatible attributes; make sure "'+d+'" attribute exists among all geometries, or in none of them.'),null;n[d]===void 0&&(n[d]=[]),n[d].push(h.attributes[d]),u++}if(u!==t.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+". Make sure all geometries have the same number of attributes."),null;if(r!==h.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const d in h.morphAttributes){if(!s.has(d))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+".  .morphAttributes must be consistent throughout all geometries."),null;i[d]===void 0&&(i[d]=[]),i[d].push(h.morphAttributes[d])}{let d;if(e)d=h.index.count;else if(h.attributes.position!==void 0)d=h.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+l+". The geometry must have either an index or a position attribute"),null;for(let f=0;f<a[l].groups.length;++f){const p=a[l].groups[f];o.addGroup(p.start+c,p.count,p.materialIndex)}c+=d}}if(e){let l=0;const h=[];for(let u=0;u<a.length;++u){const d=a[u].index;for(let f=0;f<d.count;++f)h.push(d.getX(f)+l);l+=a[u].attributes.position.count}o.setIndex(h)}for(const l in n){const h=vs(n[l]);if(!h)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+l+" attribute."),null;o.setAttribute(l,h)}for(const l in i){const h=i[l][0].length;if(h===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[l]=[];for(let u=0;u<h;++u){const d=[];for(let p=0;p<i[l].length;++p)d.push(i[l][p][u]);const f=vs(d);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+l+" morphAttribute."),null;o.morphAttributes[l].push(f)}}return o.groups.length===0?o:jl(o)}class Wn extends A.CurvePath{constructor(e){super(),this.type="Path3",this.currentPoint=new A.Vector3,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y,e[0].z);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y,e[t].z);return this}moveTo(e,t,s){return this.currentPoint.set(e,t,s),this}lineTo(e,t,s){const n=new A.LineCurve3(this.currentPoint.clone(),new A.Vector3(e,t,s));return this.curves.push(n),this.currentPoint.set(e,t,s),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Kn extends Wn{constructor(e){super(e),this.uuid=qr(),this.type="Shape3",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,n=this.holes.length;s<n;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const n=e.holes[t];this.holes.push(new Wn().fromJSON(n))}return this}}function Wl(a,e,t=2){const s=e&&e.length,n=s?e[0]*t:a.length;let i=Ua(a,0,n,t,!0);const r=[];if(!i||i.next===i.prev)return r;let o,c,l;if(s&&(i=Zl(a,e,i,t)),a.length>80*t){o=1/0,c=1/0;let h=-1/0,u=-1/0;for(let d=t;d<n;d+=t){const f=a[d],p=a[d+1];f<o&&(o=f),p<c&&(c=p),f>h&&(h=f),p>u&&(u=p)}l=Math.max(h-o,u-c),l=l!==0?32767/l:0}return Vt(i,r,t,o,c,l,0),r}function Ua(a,e,t,s,n){let i;if(n===ch(a,e,t,s)>0)for(let r=e;r<t;r+=s)i=Va(r/s|0,a[r],a[r+1],i);else for(let r=t-s;r>=e;r-=s)i=Va(r/s|0,a[r],a[r+1],i);return i&&Ct(i,i.next)&&(qt(i),i=i.next),i}function at(a,e){if(!a)return a;e||(e=a);let t=a,s;do if(s=!1,!t.steiner&&(Ct(t,t.next)||ee(t.prev,t,t.next)===0)){if(qt(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function Vt(a,e,t,s,n,i,r){if(!a)return;!r&&i&&sh(a,s,n,i);let o=a;for(;a.prev!==a.next;){const c=a.prev,l=a.next;if(i?Jl(a,s,n,i):Kl(a)){e.push(c.i,a.i,l.i),qt(a),a=l.next,o=l.next;continue}if(a=l,a===o){r?r===1?(a=Yl(at(a),e),Vt(a,e,t,s,n,i,2)):r===2&&Xl(a,e,t,s,n,i):Vt(at(a),e,t,s,n,i,1);break}}}function Kl(a){const e=a.prev,t=a,s=a.next;if(ee(e,t,s)>=0)return!1;const n=e.x,i=t.x,r=s.x,o=e.y,c=t.y,l=s.y,h=Math.min(n,i,r),u=Math.min(o,c,l),d=Math.max(n,i,r),f=Math.max(o,c,l);let p=s.next;for(;p!==e;){if(p.x>=h&&p.x<=d&&p.y>=u&&p.y<=f&&zt(n,o,i,c,r,l,p.x,p.y)&&ee(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function Jl(a,e,t,s){const n=a.prev,i=a,r=a.next;if(ee(n,i,r)>=0)return!1;const o=n.x,c=i.x,l=r.x,h=n.y,u=i.y,d=r.y,f=Math.min(o,c,l),p=Math.min(h,u,d),g=Math.max(o,c,l),m=Math.max(h,u,d),I=Jn(f,p,e,t,s),b=Jn(g,m,e,t,s);let C=a.prevZ,y=a.nextZ;for(;C&&C.z>=I&&y&&y.z<=b;){if(C.x>=f&&C.x<=g&&C.y>=p&&C.y<=m&&C!==n&&C!==r&&zt(o,h,c,u,l,d,C.x,C.y)&&ee(C.prev,C,C.next)>=0||(C=C.prevZ,y.x>=f&&y.x<=g&&y.y>=p&&y.y<=m&&y!==n&&y!==r&&zt(o,h,c,u,l,d,y.x,y.y)&&ee(y.prev,y,y.next)>=0))return!1;y=y.nextZ}for(;C&&C.z>=I;){if(C.x>=f&&C.x<=g&&C.y>=p&&C.y<=m&&C!==n&&C!==r&&zt(o,h,c,u,l,d,C.x,C.y)&&ee(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;y&&y.z<=b;){if(y.x>=f&&y.x<=g&&y.y>=p&&y.y<=m&&y!==n&&y!==r&&zt(o,h,c,u,l,d,y.x,y.y)&&ee(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function Yl(a,e){let t=a;do{const s=t.prev,n=t.next.next;!Ct(s,n)&&Oa(s,t,t.next,n)&&jt(s,n)&&jt(n,s)&&(e.push(s.i,t.i,n.i),qt(t),qt(t.next),t=a=n),t=t.next}while(t!==a);return at(t)}function Xl(a,e,t,s,n,i){let r=a;do{let o=r.next.next;for(;o!==r.prev;){if(r.i!==o.i&&rh(r,o)){let c=Ra(r,o);r=at(r,r.next),c=at(c,c.next),Vt(r,e,t,s,n,i,0),Vt(c,e,t,s,n,i,0);return}o=o.next}r=r.next}while(r!==a)}function Zl(a,e,t,s){const n=[];for(let i=0,r=e.length;i<r;i++){const o=e[i]*s,c=i<r-1?e[i+1]*s:a.length,l=Ua(a,o,c,s,!1);l===l.next&&(l.steiner=!0),n.push(ih(l))}n.sort($l);for(let i=0;i<n.length;i++)t=Hl(n[i],t);return t}function $l(a,e){let t=a.x-e.x;if(t===0&&(t=a.y-e.y,t===0)){const s=(a.next.y-a.y)/(a.next.x-a.x),n=(e.next.y-e.y)/(e.next.x-e.x);t=s-n}return t}function Hl(a,e){const t=eh(a,e);if(!t)return e;const s=Ra(t,a);return at(s,s.next),at(t,t.next)}function eh(a,e){let t=e;const s=a.x,n=a.y;let i=-1/0,r;if(Ct(a,t))return t;do{if(Ct(a,t.next))return t.next;if(n<=t.y&&n>=t.next.y&&t.next.y!==t.y){const u=t.x+(n-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(u<=s&&u>i&&(i=u,r=t.x<t.next.x?t:t.next,u===s))return r}t=t.next}while(t!==e);if(!r)return null;const o=r,c=r.x,l=r.y;let h=1/0;t=r;do{if(s>=t.x&&t.x>=c&&s!==t.x&&Na(n<l?s:i,n,c,l,n<l?i:s,n,t.x,t.y)){const u=Math.abs(n-t.y)/(s-t.x);jt(t,a)&&(u<h||u===h&&(t.x>r.x||t.x===r.x&&th(r,t)))&&(r=t,h=u)}t=t.next}while(t!==o);return r}function th(a,e){return ee(a.prev,a,e.prev)<0&&ee(e.next,a,a.next)<0}function sh(a,e,t,s){let n=a;do n.z===0&&(n.z=Jn(n.x,n.y,e,t,s)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==a);n.prevZ.nextZ=null,n.prevZ=null,nh(n)}function nh(a){let e,t=1;do{let s=a,n;a=null;let i=null;for(e=0;s;){e++;let r=s,o=0;for(let l=0;l<t&&(o++,r=r.nextZ,!!r);l++);let c=t;for(;o>0||c>0&&r;)o!==0&&(c===0||!r||s.z<=r.z)?(n=s,s=s.nextZ,o--):(n=r,r=r.nextZ,c--),i?i.nextZ=n:a=n,n.prevZ=i,i=n;s=r}i.nextZ=null,t*=2}while(e>1);return a}function Jn(a,e,t,s,n){return a=(a-t)*n|0,e=(e-s)*n|0,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,a|e<<1}function ih(a){let e=a,t=a;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==a);return t}function Na(a,e,t,s,n,i,r,o){return(n-r)*(e-o)>=(a-r)*(i-o)&&(a-r)*(s-o)>=(t-r)*(e-o)&&(t-r)*(i-o)>=(n-r)*(s-o)}function zt(a,e,t,s,n,i,r,o){return!(a===r&&e===o)&&Na(a,e,t,s,n,i,r,o)}function rh(a,e){return a.next.i!==e.i&&a.prev.i!==e.i&&!ah(a,e)&&(jt(a,e)&&jt(e,a)&&oh(a,e)&&(ee(a.prev,a,e.prev)||ee(a,e.prev,e))||Ct(a,e)&&ee(a.prev,a,a.next)>0&&ee(e.prev,e,e.next)>0)}function ee(a,e,t){return(e.y-a.y)*(t.x-e.x)-(e.x-a.x)*(t.y-e.y)}function Ct(a,e){return a.x===e.x&&a.y===e.y}function Oa(a,e,t,s){const n=Qs(ee(a,e,t)),i=Qs(ee(a,e,s)),r=Qs(ee(t,s,a)),o=Qs(ee(t,s,e));return!!(n!==i&&r!==o||n===0&&Ss(a,t,e)||i===0&&Ss(a,s,e)||r===0&&Ss(t,a,s)||o===0&&Ss(t,e,s))}function Ss(a,e,t){return e.x<=Math.max(a.x,t.x)&&e.x>=Math.min(a.x,t.x)&&e.y<=Math.max(a.y,t.y)&&e.y>=Math.min(a.y,t.y)}function Qs(a){return a>0?1:a<0?-1:0}function ah(a,e){let t=a;do{if(t.i!==a.i&&t.next.i!==a.i&&t.i!==e.i&&t.next.i!==e.i&&Oa(t,t.next,a,e))return!0;t=t.next}while(t!==a);return!1}function jt(a,e){return ee(a.prev,a,a.next)<0?ee(a,e,a.next)>=0&&ee(a,a.prev,e)>=0:ee(a,e,a.prev)<0||ee(a,a.next,e)<0}function oh(a,e){let t=a,s=!1;const n=(a.x+e.x)/2,i=(a.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&n<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==a);return s}function Ra(a,e){const t=Yn(a.i,a.x,a.y),s=Yn(e.i,e.x,e.y),n=a.next,i=e.prev;return a.next=e,e.prev=a,t.next=n,n.prev=t,s.next=t,t.prev=s,i.next=s,s.prev=i,s}function Va(a,e,t,s){const n=Yn(a,e,t);return s?(n.next=s.next,n.prev=s,s.next.prev=n,s.next=n):(n.prev=n,n.next=n),n}function qt(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function Yn(a,e,t){return{i:a,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function ch(a,e,t,s){let n=0;for(let i=e,r=t-s;i<t;i+=s)n+=(a[r]-a[i])*(a[i+1]+a[r+1]),r=i;return n}class Ze{static area(e){const t=e.length;let s=0;for(let n=t-1,i=0;i<t;n=i++)s+=e[n].x*e[i].y-e[i].x*e[n].y;return s*.5}static isClockWise(e){return Ze.area(e)<0}static triangulateShape(e,t){const s=[],n=[],i=[];za(e),ja(s,e);let r=e.length;t.forEach(za);for(let c=0;c<t.length;c++)n.push(r),r+=t[c].length,ja(s,t[c]);const o=Wl(s,n,3);for(let c=0;c<o.length;c+=3)i.push(o.slice(c,c+3));return i}}function za(a){const e=a.length;e>2&&a[e-1].equals(a[0])&&a.pop()}function ja(a,e){for(let t=0;t<e.length;t++)a.push(e[t].x),a.push(e[t].y),a.push(e[t].z)}class Xn extends A.BufferGeometry{constructor(e=new Kn([new A.Vector3(0,.5),new A.Vector3(-.5,-.5),new A.Vector3(.5,-.5)]),t=12){super(),this.type="Shape3Geometry",this.parameters={shapes:e,curveSegments:t};const s=[],n=[],i=[],r=[];let o=0,c=0;if(Array.isArray(e)===!1)l(e);else for(let h=0;h<e.length;h++)l(e[h]),this.addGroup(o,c,h),o+=c,c=0;this.setIndex(s),this.setAttribute("position",new A.Float32BufferAttribute(n,3)),this.setAttribute("normal",new A.Float32BufferAttribute(i,3)),this.setAttribute("uv",new A.Float32BufferAttribute(r,2));function l(h){const u=n.length/3,d=h.extractPoints(t);let f=d.shape;const p=d.holes;Ze.isClockWise(f)===!1&&(f=f.reverse());for(let m=0,I=p.length;m<I;m++){const b=p[m];Ze.isClockWise(b)===!0&&(p[m]=b.reverse())}const g=Ze.triangulateShape(f,p);for(let m=0,I=p.length;m<I;m++){const b=p[m];f=f.concat(b)}for(let m=0,I=f.length;m<I;m++){const b=f[m];n.push(b.x,b.y,b.z),i.push(0,0,1),r.push(b.x,b.y)}for(let m=0,I=g.length;m<I;m++){const b=g[m],C=b[0]+u,y=b[1]+u,B=b[2]+u;s.push(C,y,B),c+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return Ah(t,e)}static fromJSON(e,t){const s=[];for(let n=0,i=e.shapes.length;n<i;n++){const r=t[e.shapes[n]];s.push(r)}return new Xn(s,e.curveSegments)}}function Ah(a,e){if(e.shapes=[],Array.isArray(a))for(let t=0,s=a.length;t<s;t++){const n=a[t];e.shapes.push(n.uuid)}else e.shapes.push(a.uuid);return e}class lh extends A.BufferGeometry{constructor(e=new Kn([new A.Vector2(.5,.5),new A.Vector2(-.5,.5),new A.Vector2(-.5,-.5),new A.Vector2(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,n=[],i=[];for(let o=0,c=e.length;o<c;o++){const l=e[o];r(l)}this.setAttribute("position",new A.Float32BufferAttribute(n,3)),this.setAttribute("uv",new A.Float32BufferAttribute(i,2)),this.computeVertexNormals();function r(o){const c=[],l=t.curveSegments!==void 0?t.curveSegments:12,h=t.steps!==void 0?t.steps:1,u=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,p=t.bevelSize!==void 0?t.bevelSize:f-.1,g=t.bevelOffset!==void 0?t.bevelOffset:0,m=t.bevelSegments!==void 0?t.bevelSegments:3;const I=t.extrudePath,b=t.UVGenerator!==void 0?t.UVGenerator:hh;let C,y=!1,B,v,_,x;I&&(C=I.getSpacedPoints(h),y=!0,d=!1,B=I.computeFrenetFrames(h,!1),v=new A.Vector3,_=new A.Vector3,x=new A.Vector3),d||(m=0,f=0,p=0,g=0);const w=o.extractPoints(l);let S=w.shape;const Q=w.holes;if(!Ze.isClockWise(S)){S=S.reverse();for(let D=0,F=Q.length;D<F;D++){const G=Q[D];Ze.isClockWise(G)&&(Q[D]=G.reverse())}}const N=Ze.triangulateShape(S,Q),k=S;for(let D=0,F=Q.length;D<F;D++){const G=Q[D];S=S.concat(G)}function O(D,F,G){return F||console.error("THREE.ExtrudeGeometry: vec does not exist"),D.clone().addScaledVector(F,G)}const P=S.length,M=N.length;function j(D,F,G){let R,L,T;const V=D.x-F.x,J=D.y-F.y,ne=G.x-D.x,H=G.y-D.y,Te=V*V+J*J,te=V*H-J*ne;if(Math.abs(te)>Number.EPSILON){const xe=Math.sqrt(Te),$a=Math.sqrt(ne*ne+H*H),Ha=F.x-J/xe,eo=F.y+V/xe,xu=G.x-H/$a,_u=G.y+ne/$a,to=((xu-Ha)*H-(_u-eo)*ne)/(V*H-J*ne);R=Ha+V*to-D.x,L=eo+J*to-D.y;const so=R*R+L*L;if(so<=2)return new A.Vector2(R,L);T=Math.sqrt(so/2)}else{let xe=!1;V>Number.EPSILON?ne>Number.EPSILON&&(xe=!0):V<-Number.EPSILON?ne<-Number.EPSILON&&(xe=!0):Math.sign(J)===Math.sign(H)&&(xe=!0),xe?(R=-J,L=V,T=Math.sqrt(Te)):(R=V,L=J,T=Math.sqrt(Te/2))}return new A.Vector2(R/T,L/T)}const q=[];for(let D=0,F=k.length,G=F-1,R=D+1;D<F;D++,G++,R++)G===F&&(G=0),R===F&&(R=0),q[D]=j(k[D],k[G],k[R]);const z=[];let Z,X=q.concat();for(let D=0,F=Q.length;D<F;D++){const G=Q[D];Z=[];for(let R=0,L=G.length,T=L-1,V=R+1;R<L;R++,T++,V++)T===L&&(T=0),V===L&&(V=0),Z[R]=j(G[R],G[T],G[V]);z.push(Z),X=X.concat(Z)}for(let D=0;D<m;D++){const F=D/m,G=f*Math.cos(F*Math.PI/2),R=p*Math.sin(F*Math.PI/2)+g;for(let L=0,T=k.length;L<T;L++){const V=O(k[L],q[L],R);fe(V.x,V.y,-G)}for(let L=0,T=Q.length;L<T;L++){const V=Q[L];Z=z[L];for(let J=0,ne=V.length;J<ne;J++){const H=O(V[J],Z[J],R);fe(H.x,H.y,-G)}}}const $=p+g;for(let D=0;D<P;D++){const F=d?O(S[D],X[D],$):S[D];y?(_.copy(B.normals[0]).multiplyScalar(F.x),v.copy(B.binormals[0]).multiplyScalar(F.y),x.copy(C[0]).add(_).add(v),fe(x.x,x.y,x.z)):fe(F.x,F.y,0)}for(let D=1;D<=h;D++)for(let F=0;F<P;F++){const G=d?O(S[F],X[F],$):S[F];y?(_.copy(B.normals[D]).multiplyScalar(G.x),v.copy(B.binormals[D]).multiplyScalar(G.y),x.copy(C[D]).add(_).add(v),fe(x.x,x.y,x.z)):fe(G.x,G.y,u/h*D)}for(let D=m-1;D>=0;D--){const F=D/m,G=f*Math.cos(F*Math.PI/2),R=p*Math.sin(F*Math.PI/2)+g;for(let L=0,T=k.length;L<T;L++){const V=O(k[L],q[L],R);fe(V.x,V.y,u+G)}for(let L=0,T=Q.length;L<T;L++){const V=Q[L];Z=z[L];for(let J=0,ne=V.length;J<ne;J++){const H=O(V[J],Z[J],R);y?fe(H.x,H.y+C[h-1].y,C[h-1].x+G):fe(H.x,H.y,u+G)}}}de(),ct();function de(){const D=n.length/3;if(d){let F=0,G=P*F;for(let R=0;R<M;R++){const L=N[R];Fe(L[2]+G,L[1]+G,L[0]+G)}F=h+m*2,G=P*F;for(let R=0;R<M;R++){const L=N[R];Fe(L[0]+G,L[1]+G,L[2]+G)}}else{for(let F=0;F<M;F++){const G=N[F];Fe(G[2],G[1],G[0])}for(let F=0;F<M;F++){const G=N[F];Fe(G[0]+P*h,G[1]+P*h,G[2]+P*h)}}s.addGroup(D,n.length/3-D,0)}function ct(){const D=n.length/3;let F=0;$e(k,F),F+=k.length;for(let G=0,R=Q.length;G<R;G++){const L=Q[G];$e(L,F),F+=L.length}s.addGroup(D,n.length/3-D,1)}function $e(D,F){let G=D.length;for(;--G>=0;){const R=G;let L=G-1;L<0&&(L=D.length-1);for(let T=0,V=h+m*2;T<V;T++){const J=P*T,ne=P*(T+1),H=F+R+J,Te=F+L+J,te=F+L+ne,xe=F+R+ne;At(H,Te,te,xe)}}}function fe(D,F,G){c.push(D),c.push(F),c.push(G)}function Fe(D,F,G){se(D),se(F),se(G);const R=n.length/3,L=b.generateTopUV(s,n,R-3,R-2,R-1);le(L[0]),le(L[1]),le(L[2])}function At(D,F,G,R){se(D),se(F),se(R),se(F),se(G),se(R);const L=n.length/3,T=b.generateSideWallUV(s,n,L-6,L-3,L-2,L-1);le(T[0]),le(T[1]),le(T[3]),le(T[1]),le(T[2]),le(T[3])}function se(D){n.push(c[D*3+0]),n.push(c[D*3+1]),n.push(c[D*3+2])}function le(D){i.push(D.x),i.push(D.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return uh(t,s,e)}static fromJSON(e,t){const s=[];for(let i=0,r=e.shapes.length;i<r;i++){const o=t[e.shapes[i]];s.push(o)}const n=e.options.extrudePath;return n!==void 0&&(e.options.extrudePath=new Curves[n.type]().fromJSON(n)),new ExtrudeGeometry(s,e.options)}}const hh={generateTopUV:function(a,e,t,s,n){const i=e[t*3],r=e[t*3+1],o=e[s*3],c=e[s*3+1],l=e[n*3],h=e[n*3+1];return[new A.Vector2(i,r),new A.Vector2(o,c),new A.Vector2(l,h)]},generateSideWallUV:function(a,e,t,s,n,i){const r=e[t*3],o=e[t*3+1],c=e[t*3+2],l=e[s*3],h=e[s*3+1],u=e[s*3+2],d=e[n*3],f=e[n*3+1],p=e[n*3+2],g=e[i*3],m=e[i*3+1],I=e[i*3+2];return Math.abs(o-h)<Math.abs(r-l)?[new A.Vector2(r,1-c),new A.Vector2(l,1-u),new A.Vector2(d,1-p),new A.Vector2(g,1-I)]:[new A.Vector2(o,1-c),new A.Vector2(h,1-u),new A.Vector2(f,1-p),new A.Vector2(m,1-I)]}};function uh(a,e,t){if(t.shapes=[],Array.isArray(a))for(let s=0,n=a.length;s<n;s++){const i=a[s];t.shapes.push(i.uuid)}else t.shapes.push(a.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}function qa(a,e=0){const t=new Kn,s=a.coordinates[0],n=[];s.forEach(i=>{n.push(new A.Vector3(i[0],i[1],(i[2]??0)+(e??0)))}),t.setFromPoints(n);for(let i=1;i<a.coordinates.length;i++){const r=a.coordinates[i],o=new Wn,c=[];r.forEach(l=>{c.push(new A.Vector3(l[0],l[1],(l[2]??0)+(e??0)))}),o.setFromPoints(c),t.holes.push(o)}return t}function dh(a,e,t=0){const s=qa(a,t);return new lh(s,{depth:e,bevelEnabled:!1})}function fh(a){const e=qa(a);return new Xn(e)}function Wa(a){const e=[];return a.forEach(s=>{const n=fh(s.geometry);e.push(n)}),Rt(e)}function ph(a,e){const{geometries:t}=a,s=Wa(t.polygonFeatures),n=new A.MeshBasicMaterial({color:e.color,opacity:e.opacity,transparent:e.opacity&&e.opacity<1});return new A.Mesh(s,n)}const gh=`
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump;
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`,mh=`

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        csm_Bump = vec3(0.0);
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`,bh=`
    varying mat4 csm_internal_vModelViewMatrix;
`,Ch=`
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,Ih=`
    varying mat4 csm_internal_vModelViewMatrix;
`,yh=`
    
`,U={diffuse:"csm_DiffuseColor",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",fragNormal:"csm_FragNormal",clearcoat:"csm_Clearcoat",clearcoatRoughness:"csm_ClearcoatRoughness",clearcoatNormal:"csm_ClearcoatNormal",transmission:"csm_Transmission",thickness:"csm_Thickness",iridescence:"csm_Iridescence",pointSize:"csm_PointSize",fragColor:"csm_FragColor",depthAlpha:"csm_DepthAlpha",unlitFac:"csm_UnlitFac",position:"csm_Position",positionRaw:"csm_PositionRaw",normal:"csm_Normal"},Bh={[`${U.position}`]:"*",[`${U.positionRaw}`]:"*",[`${U.normal}`]:"*",[`${U.depthAlpha}`]:"*",[`${U.pointSize}`]:["PointsMaterial"],[`${U.diffuse}`]:"*",[`${U.fragColor}`]:"*",[`${U.fragNormal}`]:"*",[`${U.unlitFac}`]:"*",[`${U.emissive}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${U.roughness}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${U.metalness}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${U.iridescence}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${U.ao}`]:["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"],[`${U.bump}`]:["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"],[`${U.clearcoat}`]:["MeshPhysicalMaterial"],[`${U.clearcoatRoughness}`]:["MeshPhysicalMaterial"],[`${U.clearcoatNormal}`]:["MeshPhysicalMaterial"],[`${U.transmission}`]:["MeshPhysicalMaterial"],[`${U.thickness}`]:["MeshPhysicalMaterial"]},xh={"*":{"#include <lights_physical_fragment>":Y.ShaderChunk.lights_physical_fragment,"#include <transmission_fragment>":Y.ShaderChunk.transmission_fragment},[`${U.normal}`]:{"#include <beginnormal_vertex>":`
    vec3 objectNormal = ${U.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `},[`${U.position}`]:{"#include <begin_vertex>":`
    vec3 transformed = ${U.position};
  `},[`${U.positionRaw}`]:{"#include <project_vertex>":`
    #include <project_vertex>
    gl_Position = ${U.positionRaw};
  `},[`${U.pointSize}`]:{"gl_PointSize = size;":`
    gl_PointSize = ${U.pointSize};
    `},[`${U.diffuse}`]:{"#include <color_fragment>":`
    #include <color_fragment>
    diffuseColor = ${U.diffuse};
  `},[`${U.fragColor}`]:{"#include <opaque_fragment>":`
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${U.fragColor}, ${U.unlitFac});
  `},[`${U.emissive}`]:{"vec3 totalEmissiveRadiance = emissive;":`
    vec3 totalEmissiveRadiance = ${U.emissive};
    `},[`${U.roughness}`]:{"#include <roughnessmap_fragment>":`
    #include <roughnessmap_fragment>
    roughnessFactor = ${U.roughness};
    `},[`${U.metalness}`]:{"#include <metalnessmap_fragment>":`
    #include <metalnessmap_fragment>
    metalnessFactor = ${U.metalness};
    `},[`${U.ao}`]:{"#include <aomap_fragment>":`
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${U.ao};
    `},[`${U.bump}`]:{"#include <normal_fragment_maps>":`
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = ${U.bump} - (dot(${U.bump}, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `},[`${U.fragNormal}`]:{"#include <normal_fragment_maps>":`
      #include <normal_fragment_maps>
      normal = ${U.fragNormal};
    `},[`${U.depthAlpha}`]:{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${U.depthAlpha} );
    `,"gl_FragColor = packDepthToRGBA( fragCoordZ );":`
      if(${U.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,"gl_FragColor = packDepthToRGBA( dist );":`
      if(${U.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `},[`${U.clearcoat}`]:{"material.clearcoat = clearcoat;":`material.clearcoat = ${U.clearcoat};`},[`${U.clearcoatRoughness}`]:{"material.clearcoatRoughness = clearcoatRoughness;":`material.clearcoatRoughness = ${U.clearcoatRoughness};`},[`${U.clearcoatNormal}`]:{"#include <clearcoat_normal_fragment_begin>":`
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `},[`${U.transmission}`]:{"material.transmission = transmission;":`
      material.transmission = ${U.transmission};
    `},[`${U.thickness}`]:{"material.thickness = thickness;":`
      material.thickness = ${U.thickness};
    `},[`${U.iridescence}`]:{"material.iridescence = iridescence;":`
      material.iridescence = ${U.iridescence};
    `}},_h={clearcoat:[U.clearcoat,U.clearcoatNormal,U.clearcoatRoughness],transmission:[U.transmission],iridescence:[U.iridescence]};function wh(a){let e=0;for(let s=0;s<a.length;s++)e=a.charCodeAt(s)+(e<<6)+(e<<16)-e;const t=e>>>0;return String(t)}function vh(a){try{new a}catch(e){if(e.message.indexOf("is not a constructor")>=0)return!1}return!0}function Ka(a){return a.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"")}class Ms extends Y.Material{constructor({baseMaterial:e,vertexShader:t,fragmentShader:s,uniforms:n,patchMap:i,cacheKey:r,...o}){if(!e)throw new Error("CustomShaderMaterial: baseMaterial is required.");let c;if(vh(e)){const d=Object.keys(o).length===0;c=new e(d?void 0:o)}else c=e,Object.assign(c,o);if(["ShaderMaterial","RawShaderMaterial"].includes(c.type))throw new Error(`CustomShaderMaterial does not support ${c.type} as a base material.`);super(),this.uniforms={},this.vertexShader="",this.fragmentShader="";const l=c;l.name=`CustomShaderMaterial<${c.name||c.type}>`,l.update=this.update,l.__csm={prevOnBeforeCompile:c.onBeforeCompile,baseMaterial:c,vertexShader:t,fragmentShader:s,uniforms:n,patchMap:i,cacheKey:r};const h={...l.uniforms||{},...n||{}};l.uniforms=this.uniforms=h,l.vertexShader=this.vertexShader=t||"",l.fragmentShader=this.fragmentShader=s||"",l.update({fragmentShader:l.fragmentShader,vertexShader:l.vertexShader,uniforms:l.uniforms,patchMap:i,cacheKey:r}),Object.assign(this,l);const u=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(l));for(const d in u){const f=u[d];(f.get||f.set)&&Object.defineProperty(this,d,f)}return Object.defineProperty(this,"type",{get(){return c.type},set(d){c.type=d}}),this}update({fragmentShader:e,vertexShader:t,uniforms:s,cacheKey:n,patchMap:i}){const r=Ka(t||""),o=Ka(e||""),c=this;s&&(c.uniforms=s),t&&(c.vertexShader=t),e&&(c.fragmentShader=e),Object.entries(_h).forEach(([d,f])=>{for(const p in f){const g=f[p];(o&&o.includes(g)||r&&r.includes(g))&&(c[d]||(c[d]=1))}});const l=c.__csm.prevOnBeforeCompile,h=(d,f,p)=>{let g,m="";if(f){const I=f.search(/void\s+main\s*\(\s*\)\s*{/);if(I!==-1){m=f.slice(0,I);let b=0,C=-1;for(let y=I;y<f.length;y++)if(f[y]==="{"&&b++,f[y]==="}"&&(b--,b===0)){C=y;break}if(C!==-1){const y=f.slice(I,C+1);g=y.slice(y.indexOf("{")+1,-1)}}else m=f}if(p&&f&&f.includes(U.fragColor)&&g&&(g=`csm_UnlitFac = 1.0;
`+g),d.includes("//~CSM_DEFAULTS")){d=d.replace("void main() {",`
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${m}
          
          void main() {
          `);const I=d.lastIndexOf("//~CSM_MAIN_END");if(I!==-1){const b=`
            ${g?`${g}`:""}
            //~CSM_MAIN_END
          `;d=d.slice(0,I)+b+d.slice(I)}}else{const I=/void\s*main\s*\(\s*\)\s*{/gm;d=d.replace(I,`
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${p?Ih:bh}
          ${gh}
  
          ${m}
          
          void main() {
            {
              ${mh}
            }
            ${p?yh:Ch}

            ${g?`${g}`:""}
            //~CSM_MAIN_END
          `)}return d};c.onBeforeCompile=(d,f)=>{l==null||l(d,f);const p=i||{},g=c.type,m=g?`#define IS_${g.toUpperCase()};
`:`#define IS_UNKNOWN;
`;d.vertexShader=m+`#define IS_VERTEX
`+d.vertexShader,d.fragmentShader=m+`#define IS_FRAGMENT
`+d.fragmentShader;const I=b=>{for(const C in b){const y=C==="*"||r&&r.includes(C);if(C==="*"||o&&o.includes(C)||y){const B=Bh[C];if(B&&B!=="*"&&(Array.isArray(B)?!B.includes(g):B!==g)){console.error(`CustomShaderMaterial: ${C} is not available in ${g}. Shader cannot compile.`);return}const v=b[C];for(const _ in v){const x=v[_];if(typeof x=="object"){const w=x.type,S=x.value;w==="fs"?d.fragmentShader=d.fragmentShader.replace(_,S):w==="vs"&&(d.vertexShader=d.vertexShader.replace(_,S))}else x&&(d.vertexShader=d.vertexShader.replace(_,x),d.fragmentShader=d.fragmentShader.replace(_,x))}}}};I(xh),I(p),d.vertexShader=h(d.vertexShader,r,!1),d.fragmentShader=h(d.fragmentShader,o,!0),s&&(d.uniforms={...d.uniforms,...c.uniforms}),c.uniforms=d.uniforms};const u=c.customProgramCacheKey;c.customProgramCacheKey=()=>((n==null?void 0:n())||wh((r||"")+(o||"")))+(u==null?void 0:u.call(c)),c.needsUpdate=!0}clone(){const e=this;return new e.constructor({baseMaterial:e.__csm.baseMaterial.clone(),vertexShader:e.__csm.vertexShader,fragmentShader:e.__csm.fragmentShader,uniforms:e.__csm.uniforms,patchMap:e.__csm.patchMap,cacheKey:e.__csm.cacheKey})}}class Sh{static getMeshMaterial(e){switch(e){case"basic":return A.MeshBasicMaterial;case"standard":return A.MeshStandardMaterial;case"lambert":return A.MeshLambertMaterial;case"phong":return A.MeshPhongMaterial;case"depth":return A.MeshDepthMaterial;case"distance":return A.MeshDistanceMaterial;case"toon":return A.MeshToonMaterial;case"physical":return A.MeshPhysicalMaterial;case"normal":return A.MeshNormalMaterial;case"matcap":return A.MeshMatcapMaterial;default:return A.MeshBasicMaterial}}static resetUV(e,t=!1){e.computeBoundingBox();const{max:s,min:n}=e.boundingBox;e.deleteAttribute("uv");const i=s.x-n.x,r=s.y-n.y,o=[];for(let l=0;l<e.attributes.position.count;l++)t?(o.push((e.attributes.position.getX(l)-(n.x+s.x)/2)/i),o.push((e.attributes.position.getY(l)-(n.y+s.y)/2)/r)):(o.push((e.attributes.position.getX(l)-n.x)/i),o.push((e.attributes.position.getY(l)-n.y)/r));const c=new Float32Array(o);e.setAttribute("uv",new A.BufferAttribute(c,2))}}function Qh(a){const{colors:e,resolution:t=256}=a,s=new Uint8Array(t*4);for(let i=0;i<t;i++){const r=i/(t-1)*(e.length-1),o=Math.floor(r),c=r-o,l=e[o],h=e[Math.min(o+1,e.length-1)],u=new A.Color().lerpColors(l,h,c);s[i*4]=u.r*255,s[i*4+1]=u.g*255,s[i*4+2]=u.b*255,s[i*4+3]=255}const n=new A.DataTexture(s,t,1,A.RGBAFormat,A.UnsignedByteType,A.UVMapping,A.ClampToEdgeWrapping,A.ClampToEdgeWrapping,A.LinearFilter,A.LinearFilter);return n.needsUpdate=!0,n}function Mh(a,e,t){const s=[];return a.forEach(i=>{const r=i.__source.object,o=bt(e,r),c=bt(t,r),l=dh(i.geometry,o,c);s.push(l)}),ql(s)}class Dh extends A.Mesh{constructor(e,t={}){var n,i,r,o,c,l,h,u,d,f,p,g,m,I,b,C,y,B,v,_,x,w,S,Q,E,N,k,O,P,M,j,q,z,Z,X,$,de,ct,$e,fe,Fe,At;super(e);const s=Sh.getMeshMaterial(t==null?void 0:t.baseMaterial);if(t!=null&&t.gradient){let se=[];if(Array.isArray(t==null?void 0:t.gradientColor))se=t.gradientColor.map(te=>new A.Color(te));else{const te=((i=(n=t==null?void 0:t.material)==null?void 0:n.wall)==null?void 0:i.color)||(t==null?void 0:t.color),xe=(t==null?void 0:t.gradientColor)||((o=(r=t==null?void 0:t.material)==null?void 0:r.top)==null?void 0:o.color)||(t==null?void 0:t.color);se.push(new A.Color(te)),se.push(new A.Color(xe))}const D=Qh({colors:se}),F=`
        varying float vHeight;
        void main() {
          vHeight = position.z;
        }
      `,G=`
        varying float vHeight;

        uniform float uTime;
        uniform float uLightCircleTime;
        uniform float uLightBorderWidth;
        uniform float uLightMixRate;
        uniform vec3 uLightColor;

        uniform float uGradientHeightMax;
        uniform float uGradientHeightMin;
				uniform sampler2D uGradientSampler;
        void main() {

          bool isLight = false;
          float refHeight = (vHeight - uGradientHeightMin) / (uGradientHeightMax - uGradientHeightMin);

          vec3 gradientColor = texture2D( uGradientSampler, vec2(refHeight, 0.5) ).xyz;
          
          if(uLightBorderWidth > 0.0 && uLightCircleTime > 0.0) {
            float sinRate = sin(uTime / uLightCircleTime * PI * 2.0);
            if ((refHeight > sinRate)  && 
              (refHeight < sinRate + uLightBorderWidth ) )
            {
              csm_DiffuseColor.xyz = mix(uLightColor, gradientColor, uLightMixRate);
              isLight = true;
            } 
          }
          
          if (!isLight) {
            csm_DiffuseColor.xyz = gradientColor;
          }

        }
      `,R=(t==null?void 0:t.gradientHeightMax)??100,L=(t==null?void 0:t.gradientHeightMin)??0,T=(t==null?void 0:t.lightBorderWidth)??.01,V=(t==null?void 0:t.lightCircleTime)??10,J=(t==null?void 0:t.lightColor)??16777215,ne=(t==null?void 0:t.lightMixRate)??0,H=new Ms({baseMaterial:s,vertexShader:F,fragmentShader:G,color:((l=(c=t==null?void 0:t.material)==null?void 0:c.top)==null?void 0:l.color)||(t==null?void 0:t.color),opacity:((u=(h=t==null?void 0:t.material)==null?void 0:h.top)==null?void 0:u.opacity)??(t==null?void 0:t.opacity)??1,map:((f=(d=t==null?void 0:t.material)==null?void 0:d.top)==null?void 0:f.texture)||null,transparent:((g=(p=t==null?void 0:t.material)==null?void 0:p.top)==null?void 0:g.transparent)||t.opacity&&t.opacity<1,uniforms:{uTime:{value:0},uLightCircleTime:{value:V},uLightBorderWidth:{value:T},uLightColor:{value:new A.Color(J)},uLightMixRate:{value:ne},uGradientHeightMax:{value:R},uGradientHeightMin:{value:L},uGradientSampler:{value:D}}}),Te=new Ms({baseMaterial:s,vertexShader:F,fragmentShader:G,color:((I=(m=t==null?void 0:t.material)==null?void 0:m.wall)==null?void 0:I.color)||(t==null?void 0:t.color),opacity:((C=(b=t==null?void 0:t.material)==null?void 0:b.wall)==null?void 0:C.opacity)??(t==null?void 0:t.opacity)??1,map:((B=(y=t==null?void 0:t.material)==null?void 0:y.wall)==null?void 0:B.texture)||null,transparent:((_=(v=t==null?void 0:t.material)==null?void 0:v.wall)==null?void 0:_.transparent)||t.opacity&&t.opacity<1,uniforms:{uTime:{value:0},uLightCircleTime:{value:V},uLightBorderWidth:{value:T},uLightColor:{value:new A.Color(J)},uLightMixRate:{value:ne},uGradientHeightMax:{value:R},uGradientHeightMin:{value:L},uGradientSampler:{value:D}}});this.material=[H,Te]}else{const se=new s({color:((w=(x=t==null?void 0:t.material)==null?void 0:x.top)==null?void 0:w.color)||(t==null?void 0:t.color),opacity:((Q=(S=t==null?void 0:t.material)==null?void 0:S.top)==null?void 0:Q.opacity)??(t==null?void 0:t.opacity)??1,map:((N=(E=t==null?void 0:t.material)==null?void 0:E.top)==null?void 0:N.texture)||null,transparent:((O=(k=t==null?void 0:t.material)==null?void 0:k.top)==null?void 0:O.transparent)||t.opacity&&t.opacity<1}),le=new s({color:((M=(P=t==null?void 0:t.material)==null?void 0:P.wall)==null?void 0:M.color)||(t==null?void 0:t.color),opacity:((q=(j=t==null?void 0:t.material)==null?void 0:j.wall)==null?void 0:q.opacity)??(t==null?void 0:t.opacity)??1,map:((Z=(z=t==null?void 0:t.material)==null?void 0:z.wall)==null?void 0:Z.texture)||null,transparent:(($=(X=t==null?void 0:t.material)==null?void 0:X.wall)==null?void 0:$.transparent)||t.opacity&&t.opacity<1});this.material=[se,le]}if(t!=null&&t.enableEdge){const se=((ct=(de=t==null?void 0:t.material)==null?void 0:de.edge)==null?void 0:ct.color)??(t==null?void 0:t.color),le=((fe=($e=t==null?void 0:t.material)==null?void 0:$e.edge)==null?void 0:fe.opacity)??(t==null?void 0:t.opacity)??1,D=((At=(Fe=t==null?void 0:t.material)==null?void 0:Fe.edge)==null?void 0:At.width)??1,F=new A.EdgesGeometry(e);let R=new Fa().fromEdgesGeometry(F),L=new La({color:se,linewidth:D,opacity:le,transparent:!0,depthWrite:!0,depthTest:!0});L.resolution.set(window.innerWidth,window.innerHeight);const T=new zl(R,L);T.name=this.name+"-edges",this.add(T)}this._startTime=0}updateSceneTime(e,t,s){this._startTime===0&&(this._startTime=e);const n=e-this._startTime;this.material instanceof Ms?this.material.uniforms.uTime.value=n/1e3:Array.isArray(this.material)&&this.material.forEach(i=>{i instanceof Ms&&(i.uniforms.uTime.value=n/1e3)})}}function Lh(a,e){const{geometries:t}=a,{getElevation:s,getElevationBase:n}=e,i=Mh(t.polygonFeatures,s,n);return new Dh(i,e)}class Ve extends Y.BufferGeometry{constructor(){super(),this.isMeshLine=!0,this.type="MeshLine",this.positions=[],this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[],this.counters=[],this._points=[],this._geom=null,this.widthCallback=null,this.matrixWorld=new Y.Matrix4,Object.defineProperties(this,{geometry:{enumerable:!0,get:function(){return this}},geom:{enumerable:!0,get:function(){return this._geom},set:function(e){this.setGeometry(e,this.widthCallback)}},points:{enumerable:!0,get:function(){return this._points},set:function(e){this.setPoints(e,this.widthCallback)}}})}}Ve.prototype.setMatrixWorld=function(a){this.matrixWorld=a},Ve.prototype.setGeometry=function(a,e){this._geometry=a,this.setPoints(a.getAttribute("position").array,e)},Ve.prototype.setPoints=function(a,e){if(!(a instanceof Float32Array)&&!(a instanceof Array)){console.error("ERROR: The BufferArray of points is not instancied correctly.");return}if(this._points=a,this.widthCallback=e,this.positions=[],a.length&&a[0]instanceof Y.Vector3)for(var n=0;n<a.length-1;n++){var t=a[n];this.positions.push(t.x,t.y,t.z),this.positions.push(t.x,t.y,t.z);var t=a[n+1];this.positions.push(t.x,t.y,t.z),this.positions.push(t.x,t.y,t.z)}else for(var n=0;n<a.length-3;n+=3)this.positions.push(a[n],a[n+1],a[n+2]),this.positions.push(a[n],a[n+1],a[n+2]),this.positions.push(a[n+3],a[n+4],a[n+5]),this.positions.push(a[n+3],a[n+4],a[n+5]);this.counters=[];var s=0,n=0;let i=new Y.Vector3(this.positions[n],this.positions[n+1],this.positions[n+2]);for(this.counters.push(s),this.counters.push(s),n=6;n<this.positions.length;n+=6){let o=new Y.Vector3(this.positions[n],this.positions[n+1],this.positions[n+2]);var r=o.distanceTo(i);i=o,s+=r,this.counters.push(s),this.counters.push(s)}this.process()};function Eh(a,e){var t=new Y.Matrix4,s=new Y.Ray,n=new Y.Sphere,i=new Y.Vector3,r=this.geometry;if(r.boundingSphere||r.computeBoundingSphere(),n.copy(r.boundingSphere),n.applyMatrix4(this.matrixWorld),a.ray.intersectSphere(n,i)!==!1){t.copy(this.matrixWorld).invert(),s.copy(a.ray).applyMatrix4(t);var o=new Y.Vector3,c=new Y.Vector3,l=new Y.Vector3,h=this instanceof Y.LineSegments?2:1,u=r.index,d=r.attributes;if(u!==null)for(var f=u.array,p=d.position.array,g=d.width.array,m=0,I=f.length-1;m<I;m+=h){var b=f[m],C=f[m+1];o.fromArray(p,b*3),c.fromArray(p,C*3);var y=g[Math.floor(m/3)]!==void 0?g[Math.floor(m/3)]:1,B=a.params.Line.threshold+this.material.lineWidth*y/2,v=B*B,_=s.distanceSqToSegment(o,c,i,l);if(!(_>v)){i.applyMatrix4(this.matrixWorld);var x=a.ray.origin.distanceTo(i);x<a.near||x>a.far||(e.push({distance:x,point:l.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this}),m=I)}}}}Ve.prototype.raycast=Eh,Ve.prototype.compareV3=function(a,e){var t=a*6,s=e*6;return this.positions[t]===this.positions[s]&&this.positions[t+1]===this.positions[s+1]&&this.positions[t+2]===this.positions[s+2]},Ve.prototype.copyV3=function(a){var e=a*6;return[this.positions[e],this.positions[e+1],this.positions[e+2]]},Ve.prototype.process=function(){var a=this.positions.length/6;this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[];var e,t;this.compareV3(0,a-1)?t=this.copyV3(a-2):t=this.copyV3(0),this.previous.push(t[0],t[1],t[2]),this.previous.push(t[0],t[1],t[2]);for(var s=0;s<a;s++){if(this.side.push(1),this.side.push(-1),this.widthCallback?e=this.widthCallback(s/(a-1)):e=1,this.width.push(e),this.width.push(e),this.uvs.push(s/(a-1),0),this.uvs.push(s/(a-1),1),s<a-1){t=this.copyV3(s),this.previous.push(t[0],t[1],t[2]),this.previous.push(t[0],t[1],t[2]);var n=s*2;this.indices_array.push(n,n+1,n+2),this.indices_array.push(n+2,n+1,n+3)}s>0&&(t=this.copyV3(s),this.next.push(t[0],t[1],t[2]),this.next.push(t[0],t[1],t[2]))}this.compareV3(a-1,0)?t=this.copyV3(1):t=this.copyV3(a-1),this.next.push(t[0],t[1],t[2]),this.next.push(t[0],t[1],t[2]),!this._attributes||this._attributes.position.count!==this.positions.length?this._attributes={position:new Y.BufferAttribute(new Float32Array(this.positions),3),previous:new Y.BufferAttribute(new Float32Array(this.previous),3),next:new Y.BufferAttribute(new Float32Array(this.next),3),side:new Y.BufferAttribute(new Float32Array(this.side),1),width:new Y.BufferAttribute(new Float32Array(this.width),1),uv:new Y.BufferAttribute(new Float32Array(this.uvs),2),index:new Y.BufferAttribute(new Uint16Array(this.indices_array),1),counters:new Y.BufferAttribute(new Float32Array(this.counters),1)}:(this._attributes.position.copyArray(new Float32Array(this.positions)),this._attributes.position.needsUpdate=!0,this._attributes.previous.copyArray(new Float32Array(this.previous)),this._attributes.previous.needsUpdate=!0,this._attributes.next.copyArray(new Float32Array(this.next)),this._attributes.next.needsUpdate=!0,this._attributes.side.copyArray(new Float32Array(this.side)),this._attributes.side.needsUpdate=!0,this._attributes.width.copyArray(new Float32Array(this.width)),this._attributes.width.needsUpdate=!0,this._attributes.uv.copyArray(new Float32Array(this.uvs)),this._attributes.uv.needsUpdate=!0,this._attributes.index.copyArray(new Uint16Array(this.indices_array)),this._attributes.index.needsUpdate=!0),this.setAttribute("position",this._attributes.position),this.setAttribute("previous",this._attributes.previous),this.setAttribute("next",this._attributes.next),this.setAttribute("side",this._attributes.side),this.setAttribute("width",this._attributes.width),this.setAttribute("uv",this._attributes.uv),this.setAttribute("counters",this._attributes.counters),this.setIndex(this._attributes.index),this.computeBoundingSphere(),this.computeBoundingBox(),this._geometry&&(this._geometry.attributes=this.attributes,this._geometry.index=this.index,this._geometry.computeBoundingSphere(),this._geometry.computeBoundingBox())};function Zn(a,e,t,s,n){var i;if(a=a.subarray||a.slice?a:a.buffer,t=t.subarray||t.slice?t:t.buffer,a=e?a.subarray?a.subarray(e,n&&e+n):a.slice(e,n&&e+n):a,t.set)t.set(a,s);else for(i=0;i<a.length;i++)t[i+s]=a[i];return t}Ve.prototype.advance=function(a){var e=this._attributes.position.array,t=this._attributes.previous.array,s=this._attributes.next.array,n=e.length;Zn(e,0,t,0,n),Zn(e,6,e,0,n-6),e[n-6]=a.x,e[n-5]=a.y,e[n-4]=a.z,e[n-3]=a.x,e[n-2]=a.y,e[n-1]=a.z,Zn(e,6,s,0,n-6),s[n-6]=a.x,s[n-5]=a.y,s[n-4]=a.z,s[n-3]=a.x,s[n-2]=a.y,s[n-1]=a.z,this._attributes.position.needsUpdate=!0,this._attributes.previous.needsUpdate=!0,this._attributes.next.needsUpdate=!0};const Ja={vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float near;
    uniform float far;
    uniform float worldUnits;
    uniform vec2 offset;
    uniform float time;
    uniform float speed;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

		void trimSegment( const in vec4 start, inout vec4 end ) {
			// trim end segment so it terminates between the camera plane and the near plane
			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );
			end.xyz = mix( start.xyz, end.xyz, alpha );
		}

    vec2 fix( vec4 i, float aspect ) {
      vec2 res = i.xy / i.w;
      res.x *= aspect;
      return res;
    }

    void main() {
      float w = lineWidth * width;

      float uvOffsetX = time * speed;

      vUV = offset + vec2(counters / w - uvOffsetX, uv.y);
      vColor = vec4( color, opacity );
      vCounters = counters;

      if(worldUnits == 1.0){            
        vec3 dir;
        if( next == position ) dir = normalize( position - previous );
        else if( previous == position ) dir = normalize( next - position );
        else {
          vec3 dir1 = normalize( position - previous );
          vec3 dir2 = normalize( next - position );
          dir = normalize( dir1 + dir2 );
        }
        vec3 normal = normalize(vec3( -dir.y, dir.x, 0 ));
        normal *= .5 * w;
        
        vec3 finalPosition = position + normal * side;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPosition, 1.0 );
      }else{
        float aspect = resolution.x / resolution.y;
    
        vec4 currentPosEye = modelViewMatrix * vec4( position, 1.0 );
        vec4 prevPosEye = modelViewMatrix * vec4( previous, 1.0 );
        vec4 nextPosEye = modelViewMatrix * vec4( next, 1.0 );

        // special case for perspective projection, and segments that terminate either in, or behind, the camera plane
        // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
        // but we need to perform ndc-space calculations in the shader, so we must address this issue directly
        // perhaps there is a more elegant solution -- WestLangley
  
        bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column
        if ( perspective ) {  
          if ( currentPosEye.z < 0.0 && prevPosEye.z >= 0.0 ) {  
            trimSegment( currentPosEye, prevPosEye );  
          } else if ( prevPosEye.z < 0.0 && currentPosEye.z >= 0.0 ) {  
            trimSegment( prevPosEye, currentPosEye );  
          }  
            
          if ( currentPosEye.z < 0.0 && nextPosEye.z >= 0.0 ) {  
            trimSegment( currentPosEye, nextPosEye );  
          } else if ( nextPosEye.z < 0.0 && currentPosEye.z >= 0.0 ) {  
            trimSegment( nextPosEye, currentPosEye );  
          }  
        }


        vec4 finalPosition = projectionMatrix * currentPosEye;
        vec4 prevPos = projectionMatrix * prevPosEye;
        vec4 nextPos = projectionMatrix * nextPosEye;

        vec2 currentP = fix( finalPosition, aspect );
        vec2 prevP = fix( prevPos, aspect );
        vec2 nextP = fix( nextPos, aspect );
        
        vec2 dir;
        if( nextP == currentP ) dir = normalize( currentP - prevP );
        else if( prevP == currentP ) dir = normalize( nextP - currentP );
        else {
          vec2 dir1 = normalize( currentP - prevP );
          vec2 dir2 = normalize( nextP - currentP );
          dir = normalize( dir1 + dir2 );
        }

        vec2 normal = vec2( -dir.y, dir.x );
        normal.x /= aspect;
        normal *= w;
				// adjust for clip-space to screen-space conversion
				normal /= resolution.y;
				// back to clip space
				normal *= finalPosition.w;

        finalPosition.xy += normal * side;
        gl_Position = finalPosition;
      }

      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      
      #include <logdepthbuf_vertex>
      #include <clipping_planes_vertex>
      #include <fog_vertex>
    }
    `,fragmentShader:`

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>


    uniform sampler2D map;
    uniform sampler2D alphaMap;
    uniform float useMap;
    uniform float useAlphaMap;
    uniform float useDash;
    uniform float dashArray;
    uniform float dashOffset;
    uniform float dashRatio;
    uniform float alphaTest;
    uniform vec2 repeat;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    void main() {

			#include <logdepthbuf_fragment>

      vec4 c = vColor;
      if( useMap == 1. ) c *= texture2D( map, vUV * repeat );
      if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;
      if( c.a < alphaTest ) discard;
      if( useDash == 1. ){
          c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
      }
      gl_FragColor = c;

			#include <fog_fragment>
    }
		`};class Ds extends Y.ShaderMaterial{constructor(e){super({uniforms:Object.assign({},Y.UniformsLib.fog,{lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},color:{value:new Y.Color(16777215)},opacity:{value:1},resolution:{value:new Y.Vector2(1,1)},worldUnits:{value:1},dashArray:{value:0},dashOffset:{value:0},dashRatio:{value:.5},useDash:{value:0},alphaTest:{value:0},repeat:{value:new Y.Vector2(1,1)},offset:{value:new Y.Vector2(1,1)},time:{value:0},speed:{value:1}}),transparent:!0,vertexShader:Ja.vertexShader,fragmentShader:Ja.fragmentShader}),this.isMeshLineMaterial=!0,this.type="MeshLineMaterial",Object.defineProperties(this,{lineWidth:{enumerable:!0,get:function(){return this.uniforms.lineWidth.value},set:function(t){this.uniforms.lineWidth.value=t}},map:{enumerable:!0,get:function(){return this.uniforms.map.value},set:function(t){this.uniforms.map.value=t}},useMap:{enumerable:!0,get:function(){return this.uniforms.useMap.value},set:function(t){this.uniforms.useMap.value=t}},alphaMap:{enumerable:!0,get:function(){return this.uniforms.alphaMap.value},set:function(t){this.uniforms.alphaMap.value=t}},useAlphaMap:{enumerable:!0,get:function(){return this.uniforms.useAlphaMap.value},set:function(t){this.uniforms.useAlphaMap.value=t}},color:{enumerable:!0,get:function(){return this.uniforms.color.value},set:function(t){this.uniforms.color.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},worldUnits:{enumerable:!0,get:function(){return this.uniforms.worldUnits.value},set:function(t){this.uniforms.worldUnits.value=t}},dashArray:{enumerable:!0,get:function(){return this.uniforms.dashArray.value},set:function(t){this.uniforms.dashArray.value=t,this.useDash=t!==0?1:0}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},dashRatio:{enumerable:!0,get:function(){return this.uniforms.dashRatio.value},set:function(t){this.uniforms.dashRatio.value=t}},useDash:{enumerable:!0,get:function(){return this.uniforms.useDash.value},set:function(t){this.uniforms.useDash.value=t}},alphaTest:{enumerable:!0,get:function(){return this.uniforms.alphaTest.value},set:function(t){this.uniforms.alphaTest.value=t}},repeat:{enumerable:!0,get:function(){return this.uniforms.repeat.value},set:function(t){this.uniforms.repeat.value.copy(t)}},offset:{enumerable:!0,get:function(){return this.uniforms.offset.value},set:function(t){this.uniforms.offset.value.copy(t)}},time:{enumerable:!0,get:function(){return this.uniforms.time.value},set:function(t){this.uniforms.time.value=t}},speed:{enumerable:!0,get:function(){return this.uniforms.speed.value},set:function(t){this.uniforms.speed.value=t}}}),this.setValues(e)}}Ds.prototype.copy=function(a){return Y.ShaderMaterial.prototype.copy.call(this,a),this.lineWidth=a.lineWidth,this.map=a.map,this.useMap=a.useMap,this.alphaMap=a.alphaMap,this.useAlphaMap=a.useAlphaMap,this.color.copy(a.color),this.opacity=a.opacity,this.resolution.copy(a.resolution),this.worldUnits=a.worldUnits,this.dashArray.copy(a.dashArray),this.dashOffset.copy(a.dashOffset),this.dashRatio.copy(a.dashRatio),this.useDash=a.useDash,this.alphaTest=a.alphaTest,this.repeat.copy(a.repeat),this.time=a.time,this.speed=a.speed,this};function Fh(a,e){const t=new Ve,s=a.coordinates,n=[];return s.forEach(i=>{const r=new A.Vector3(i[0],i[1],i.length>2?i[2]:0);n.push(r.x,r.y,r.z)}),t.setPoints(n,e?i=>e:void 0),t}function Th(a,e){const t=[];return a.forEach(n=>{const i=n.__source.object,r=bt(e,i),o=Fh(n.geometry,r);t.push(o)}),Rt(t)}class kh extends A.Mesh{constructor(e,t={}){super(e);let s=new Ds(t);this.material=s,this._startTime=0}updateSceneTime(e,t,s){this._startTime===0&&(this._startTime=e);const n=e-this._startTime;this.material instanceof Ds&&(this.material.uniforms.time.value=n/1e3)}onBeforeRender(e,t,s,n,i,r){if(this.material instanceof Ds){const o=this.material.uniforms;if(o&&o.resolution){const c=new A.Vector4;e.getViewport(c);const l=c.z,h=c.w;o.resolution.value.set(l,h)}}}}function Gh(a,e){const{geometries:t}=a,{getLineWidth:s,...n}=e,i=t.lineFeatures.length>0?t.lineFeatures:t.polygonOutlineFeatures.length>0?t.polygonOutlineFeatures:[],r=Th(i,s);return new kh(r,n)}class Ph extends A.Mesh{constructor(e,t={}){super(e),this.isWater=!0;const s=this,n=t.textureWidth!==void 0?t.textureWidth:512,i=t.textureHeight!==void 0?t.textureHeight:512,r=t.clipBias!==void 0?t.clipBias:0,o=t.alpha!==void 0?t.alpha:1,c=t.time!==void 0?t.time:0,l=t.waterNormals!==void 0?t.waterNormals:null,h=t.sunDirection!==void 0?t.sunDirection:new A.Vector3(.70707,.70707,0),u=new A.Color(t.sunColor!==void 0?t.sunColor:16777215),d=new A.Color(t.waterColor!==void 0?t.waterColor:8355711),f=t.eye!==void 0?t.eye:new A.Vector3(0,0,0),p=t.distortionScale!==void 0?t.distortionScale:20,g=t.side!==void 0?t.side:A.FrontSide,m=t.fog!==void 0?t.fog:!1,I=t.up!==void 0?t.up:new A.Vector3(0,1,0),b=new A.Plane,C=new A.Vector3,y=new A.Vector3,B=new A.Vector3,v=new A.Matrix4,_=new A.Vector3,x=new A.Vector4,w=new A.Vector3,S=new A.Vector3,Q=new A.Vector4,E=new A.Matrix4,N=new A.PerspectiveCamera,k=new A.WebGLRenderTarget(n,i),O={name:"MirrorShader",uniforms:A.UniformsUtils.merge([A.UniformsLib.fog,A.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new A.Matrix4},sunColor:{value:new A.Color(8355711)},sunDirection:{value:new A.Vector3(.70707,.70707,0)},eye:{value:new A.Vector3},waterColor:{value:new A.Color(5592405)}}]),vertexShader:`
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`,fragmentShader:`
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <colorspace_fragment>
					#include <fog_fragment>	
				}`},P=new A.ShaderMaterial({name:O.name,uniforms:A.UniformsUtils.clone(O.uniforms),vertexShader:O.vertexShader,fragmentShader:O.fragmentShader,lights:!0,side:g,fog:m});P.uniforms.mirrorSampler.value=k.texture,P.uniforms.textureMatrix.value=E,P.uniforms.alpha.value=o,P.uniforms.time.value=c,P.uniforms.normalSampler.value=l,P.uniforms.sunColor.value=u,P.uniforms.waterColor.value=d,P.uniforms.sunDirection.value=h,P.uniforms.distortionScale.value=p,P.uniforms.eye.value=f,s.material=P,s.onBeforeRender=function(M,j,q){if(y.setFromMatrixPosition(s.matrixWorld),B.setFromMatrixPosition(q.matrixWorld),v.extractRotation(s.matrixWorld),C.set(I.x,I.z,I.y),C.applyMatrix4(v),w.subVectors(y,B),w.dot(C)>0)return;w.reflect(C).negate(),w.add(y),v.extractRotation(q.matrixWorld),_.set(-C.x,-C.y,-C.z),_.applyMatrix4(v),_.add(B),S.subVectors(y,_),S.reflect(C).negate(),S.add(y),N.position.copy(w),N.up.set(I.x,I.y,I.z),N.up.applyMatrix4(v),N.up.reflect(C),N.lookAt(S),N.far=q.far,N.updateMatrixWorld(),N.projectionMatrix.copy(q.projectionMatrix),E.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),E.multiply(N.projectionMatrix),E.multiply(N.matrixWorldInverse),b.setFromNormalAndCoplanarPoint(C,y),b.applyMatrix4(N.matrixWorldInverse),x.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const z=N.projectionMatrix;Q.x=(Math.sign(x.x)+z.elements[8])/z.elements[0],Q.y=(Math.sign(x.y)+z.elements[9])/z.elements[5],Q.z=-1,Q.w=(1+z.elements[10])/z.elements[14],x.multiplyScalar(2/x.dot(Q)),z.elements[2]=x.x,z.elements[6]=x.y,z.elements[10]=x.z+1-r,z.elements[14]=x.w,f.setFromMatrixPosition(q.matrixWorld);const Z=M.getRenderTarget(),X=M.xr.enabled,$=M.shadowMap.autoUpdate;s.visible=!1,M.xr.enabled=!1,M.shadowMap.autoUpdate=!1,M.setRenderTarget(k),M.state.buffers.depth.setMask(!0),M.autoClear===!1&&M.clear(),M.render(j,N),s.visible=!0,M.xr.enabled=X,M.shadowMap.autoUpdate=$,M.setRenderTarget(Z);const de=q.viewport;de!==void 0&&M.state.viewport(de)}}}function Uh(a,e){const{geometries:t}=a,s=Wa(t.polygonFeatures);return e.flowDirection=new A.Vector2(1,1),e.up=new A.Vector3(0,1,0),new Ph(s,e)}function Nh(a,e){const t=a.coordinates,s=[],n=[];let i=s.length,r=n.length,o=0;for(let l=0;l<t.length-1;l++){let h=1,u=t[l],d=t[l+1];const f=Math.sqrt((u[0]-d[0])*(u[0]-d[0])+(u[1]-d[1])*(u[1]-d[1]))/e,p=o,g=o+f;s[i++]=u[0],s[i++]=u[1],s[i++]=u[2]+0,n[r++]=p,n[r++]=0,s[i++]=d[0],s[i++]=d[1],s[i++]=d[2]+0,n[r++]=g,n[r++]=0,s[i++]=u[0],s[i++]=u[1],s[i++]=u[2]+e,n[r++]=p,n[r++]=h,s[i++]=u[0],s[i++]=u[1],s[i++]=u[2]+e,n[r++]=p,n[r++]=h,s[i++]=d[0],s[i++]=d[1],s[i++]=d[2]+0,n[r++]=g,n[r++]=0,s[i++]=d[0],s[i++]=d[1],s[i++]=d[2]+e,n[r++]=g,n[r++]=h,o+=f}const c=new A.BufferGeometry;return c.setAttribute("position",new A.Float32BufferAttribute(s,3)),c.setAttribute("uv",new A.Float32BufferAttribute(n,2)),c}function Oh(a,e){const t=[];return a.forEach(n=>{const i=n.__source.object,r=bt(e,i),o=Nh(n.geometry,r);t.push(o)}),Rt(t)}function $n(a,{name:e,vertexShader:t,fragmentShader:s}){const n=new A.Color(a.color!==void 0?a.color:16776960),i=a.opacity!==void 0?a.opacity:.8,r=a.num!==void 0?a.num:5,o=a.speed!==void 0?a.speed:1,c={name:e,side:A.DoubleSide,transparent:!0,depthWrite:!1,depthTest:!0,blending:A.AdditiveBlending,vertexShader:t,fragmentShader:s,uniforms:{time:{value:0},color:{value:n},opacity:{value:i},num:{value:r},speed:{value:o}}};return new A.ShaderMaterial(c)}function Rh(a){return new A.Color(a.color!==void 0?a.color:16776960),$n(a,{name:"RippleShader",vertexShader:`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `,fragmentShader:`
        uniform float time;
        uniform float opacity;
        uniform vec3 color;
        uniform float num;
        uniform float speed;
        varying vec2 vUv;
        #define PI 3.14159265
        void main() {
            vec4 fragColor = vec4(0.);
            float sin = sin((vUv.y - time * speed / num) * PI * 2.0 * num);
            float high = 0.92;
            float medium = 0.4;
            if (sin > high) {
                fragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);
            } else if(sin > medium) {
                fragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));
            } else {
                fragColor = vec4(color, 0.);
            }
            vec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);
            fragColor = mix(fragColor, vec4(fade, 1.), 0.85);
            gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));
        }
        `})}function Vh(a){return $n(a,{name:"WaveShader",vertexShader:`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `,fragmentShader:`
        uniform float time;
        uniform float opacity;
        uniform vec3 color;
        uniform float num;
        uniform float speed;
        varying vec2 vUv;
                
        void main() {                
            float amplitude = 1.;
            float x = vUv.x;
            float y = sin(x * num) ;
            float t = 0.01*(-time*130.0*speed);
            y += sin(x*num*2.1 + t)*4.5;
            y += sin(x*num*1.72 + t*1.121)*4.0;
            y += sin(x*num*2.221 + t*0.437)*5.0;
            y += sin(x*num*3.1122+ t*4.269)*2.5;
            y *= amplitude*0.06;
            y /= 3.;
            y += 0.55;
            float ap = step(vUv.y,y) * (y-vUv.y)/y;
            gl_FragColor = vec4(color,ap*opacity);
        }
        `})}function Ya(a){return $n(a,{name:"fadeShader",vertexShader:`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `,fragmentShader:`
        uniform float time;
        uniform float opacity;
        uniform vec3 color;
        uniform float num;
        uniform float speed;
        varying vec2 vUv;
        #define PI 3.14159265
                
        void main() {
            float timeDelta = (time * speed * 0.5 - floor(time * speed * 0.5));
            float alpha = 1.0 - vUv.y / (1.0 - timeDelta);   
            alpha = clamp( alpha, 0.0, 1.0); 
            gl_FragColor = vec4(color, alpha * opacity);
        }
        `})}class zh extends A.Mesh{constructor(e,t={}){super(e);let s;t.material instanceof A.Material?s=t.material:t.material==="ripple"?s=Rh(t):t.material==="wave"?s=Vh(t):(t.material,s=Ya(t)),this.material=s,this._startTime=0}updateSceneTime(e,t,s){this._startTime===0&&(this._startTime=e);const n=e-this._startTime;this.material instanceof A.ShaderMaterial&&(this.material.uniforms.time.value=n/1e3)}}function jh(a,e){const{geometries:t}=a,{getElevation:s,height:n}=e,i=t.lineFeatures.length>0?t.lineFeatures:t.polygonOutlineFeatures.length>0?t.polygonOutlineFeatures:[],r=Oh(i,s===void 0?n:s);return new zh(r,e)}function qh(a,e,t){const s=a.coordinates,n=new A.CircleGeometry(e,t);return n.translate(s[0],s[1],s.length>2?s[2]:0),n}function Wh(a,e,t){const s=[];return a.forEach(i=>{const r=i.__source.object,o=bt(e,r),c=qh(i.geometry,o,t);s.push(c)}),Rt(s)}function Kh(a){const e=new A.Color(a.color!==void 0?a.color:16711680),t=a.opacity!==void 0?a.opacity:.8,s=a.radius!==void 0?a.radius:1,n=a.followWidth!==void 0?a.followWidth:.2,i=a.speed!==void 0?a.speed:1,r={transparent:!0,blending:A.AdditiveBlending,depthWrite:!1,side:A.DoubleSide,depthTest:!0,vertexShader:`
        varying vec2 vUv;
        void main() {
            vUv.x = (uv.x - 0.5) * 2.0;
            vUv.y = (uv.y - 0.5) * 2.0;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,fragmentShader:`
        uniform float radius;     
        uniform float time;            
        uniform float speed; 
        uniform float followWidth; 
        varying vec2 vUv;
        uniform vec3 color;
        uniform float opacity;
        float calcAngle(vec2 oFrag){
            float fragAngle;
            const vec2 ox = vec2(1,0);
            float dianji = oFrag.x * ox.x + oFrag.y*ox.y;
            float oFrag_length = length(oFrag); // length
            float ox_length = length(ox); // length
            float yuxian = dianji / (oFrag_length * ox_length);
            fragAngle = acos(yuxian);
            fragAngle = degrees(fragAngle);
            if(oFrag.y > 0.0) {
                fragAngle = -fragAngle + 360.0;
            }
            float scanAngle = (time * speed * 0.25 - floor(time * speed * 0.25)) * 360.0;
            float angle = scanAngle - fragAngle;
            if(angle < 0.0){
                angle = angle + 360.0;
            }
            return angle;
        }
        void main() {
            if(length(vUv) == 0.0 || length(vUv) > 1.0){
                gl_FragColor = vec4( color, 0.0 );
            } else {
                float angle = calcAngle(vUv);
                if(angle < followWidth * 360.0){
                    // 
                    float ap =  1.0 - angle / (followWidth * 360.0); 
                    gl_FragColor = vec4( color, ap * opacity );  
                } else {
                    // 
                    gl_FragColor = vec4( color, 0.0 ); 
                }
            }
        }
    `,uniforms:{speed:{value:i},radius:{value:s},time:{value:0},followWidth:{value:n},color:{value:new A.Color(e)},opacity:{value:t}}};return new A.ShaderMaterial(r)}function Xa(a){const e=new A.Color(a.color!==void 0?a.color:16711680),t=a.opacity!==void 0?a.opacity:.8,s=a.radius!==void 0?a.radius:1,n=a.num!==void 0?a.num:8,i=a.speed!==void 0?a.speed:1,r={transparent:!0,blending:A.AdditiveBlending,depthWrite:!1,side:A.DoubleSide,depthTest:!0,vertexShader:`
        varying vec2 vUv;
        varying float uvLength;
        void main() {
            vUv.x = (uv.x - 0.5) * 2.0;
            vUv.y = (uv.y - 0.5) * 2.0;
            uvLength = length(vUv);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,fragmentShader:`
        uniform float radius;     
        uniform float time;            
        uniform float speed; 
        uniform float num; 
        varying vec2 vUv;
        varying float uvLength;
        uniform vec3 color;
        uniform float opacity;
        #define PI 3.14159265
        void main() {
            vec4 fragColor = vec4(color, 0.0);
            float sin = sin((uvLength - time * speed / num) * PI * 2.0 * num);
            float high = 0.999;
            float medium = 0.95;
            
            if (sin > high) {
                fragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);
            } else if(sin > medium) {
                fragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));
            } else {
                fragColor = vec4(color, 0.);
            }
            gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - uvLength));
        }
    `,uniforms:{speed:{value:i},radius:{value:s},time:{value:0},num:{value:n},color:{value:new A.Color(e)},opacity:{value:t}}};return new A.ShaderMaterial(r)}function Jh(a){const e=new A.Color(a.color!==void 0?a.color:16711680),t=a.opacity!==void 0?a.opacity:.8,s=a.radius!==void 0?a.radius:1,n=a.speed!==void 0?a.speed:1,i={transparent:!0,blending:A.AdditiveBlending,depthWrite:!1,side:A.DoubleSide,depthTest:!0,vertexShader:`
        varying vec2 vUv;
        varying float uvLength;
        void main() {
            vUv.x = (uv.x - 0.5) * 2.0;
            vUv.y = (uv.y - 0.5) * 2.0;
            uvLength = length(vUv);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,fragmentShader:`
        uniform float radius;     
        uniform float time;            
        uniform float speed; 
        varying vec2 vUv;
        varying float uvLength;
        uniform vec3 color;
        uniform float opacity;
        #define PI 3.14159265
        void main() {
            vec4 fragColor = vec4(color, 0.0);
            float timeDelta = (time * speed - floor(time * speed));
            const float innerLength = 0.2;
            const float outerLength = 0.05;
            float midLength = timeDelta * (1.0 - innerLength - outerLength) + innerLength;
            float maxLength = clamp(midLength + outerLength, 0.0, 1.0);

            
            float alpha1 = 0.0;
            float alpha2 = sin((timeDelta + 0.7) * PI * 0.5);
            if (uvLength > maxLength) {
                alpha1 = 0.0;
            } else if (uvLength > midLength) {
                alpha1 = (maxLength - uvLength) / ( maxLength - midLength);
            } else {
                alpha1 = uvLength / midLength;
            }
            float alpha = alpha1 * alpha2;
            fragColor = vec4(color, alpha);
            gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity);
        }
    `,uniforms:{speed:{value:n},radius:{value:s},time:{value:0},color:{value:new A.Color(e)},opacity:{value:t}}};return new A.ShaderMaterial(i)}class Yh extends A.Mesh{constructor(e,t={}){super(e);let s;t.material instanceof A.Material?s=t.material:t.material==="ripple"?s=Xa(t):t.material==="radar"?s=Kh(t):t.material==="spread"?s=Jh(t):s=Xa(t),this.material=s,this._startTime=0}updateSceneTime(e,t,s){this._startTime===0&&(this._startTime=e);const n=e-this._startTime;this.material instanceof A.ShaderMaterial&&(this.material.uniforms.time.value=n/1e3)}}function Xh(a,e){const{geometries:t}=a,{getCircleRadius:s,radius:n,segments:i=32}=e,r=t.pointFeatures,o=Wh(r,s===void 0?n:s,i);return new Yh(o,e)}function Zh(a,e,t,s){const n=a.coordinates,i=[];n.forEach(c=>{const l=new A.Vector3(c[0],c[1],c.length>2?c[2]:0);i.push(l)});const r=new A.CatmullRomCurve3(i);return new A.TubeGeometry(r,e,t,s)}function $h(a,e){const{tubeRadius:t,tubularSegments:s,radialSegments:n,getTubeRadius:i}=e,r=[];return a.forEach(c=>{const l=c.__source.object,h=bt(i,l)|t,u=Zh(c.geometry,s,h,n);r.push(u)}),Rt(r)}class Hh extends A.Mesh{constructor(e,t={}){super(e),this.material=t instanceof A.Material?t:new A.MeshBasicMaterial(t),this._startTime=0}updateSceneTime(e,t,s){if(this.material instanceof A.MeshBasicMaterial&&this.material.map&&this.speed){this._startTime===0&&(this._startTime=e);const n=e-this._startTime;this.material.map.offset.x=n/1e3*this.speed}}}function eu(a,e){const{geometries:t}=a,{material:s,speed:n}=e,i=t.lineFeatures.length>0?t.lineFeatures:t.polygonOutlineFeatures.length>0?t.polygonOutlineFeatures:[],r=$h(i,e),o=new Hh(r,s);return o.speed=n,o}const Hn={water:Uh,line:Gh,polygon:ph,building:Lh,fence:jh,circle:Xh,tube:eu};class tu{static supportMeshLayer(e){return Hn.hasOwnProperty(e)}static create(e,t){const{id:s,data:n,type:i,callback:r,...o}=t;if(!Hn.hasOwnProperty(i))return console.warn(`Mesh type ${i} is not supported`),null;const c=Hn[i];return c?c(e,o):null}}class su extends Xe{constructor(e){super(),this._options=e,this._featrueData=void 0,this._meshObject=void 0}updateSceneTransform(){if(this._featrueData==null)return;const e=[this._featrueData.centroid[0],this._featrueData.centroid[1]],t=this._scene.toScenePosition(e);this.position.set(t.x,t.y,t.z),this.updateMatrixWorld(!0)}updateSceneTime(e,t){this._meshObject&&this._meshObject.updateSceneTime&&this._meshObject.updateSceneTime(e,t,this._scene)}addToScene(e){return Nl(this._options.data).then(t=>{this._featrueData=t;const s=[this._featrueData.centroid[0],this._featrueData.centroid[1]];Ol(this._featrueData,s),this._scene=e,this.updateSceneTransform();const n=tu.create(this._featrueData,this._options);n&&(this._meshObject=n,this.add(n),this._options.callback&&this._options.callback(n,this._featrueData))}),super.addToScene(e)}removeFromScene(){return this._meshObject&&(this.remove(this._meshObject),this._meshObject=void 0),super.removeFromScene()}}class nu extends Xe{constructor(e,t){super(),this._label=null,this._object=e,this._options=t,this._parentObjectName="ObjectLabelGroup"}updateSceneTransform(){const e=this._options,t=this._object,s=e&&e.anchor||"center",n=new A.Box3().setFromObject(t),i=this._getAnchor(s,n);this._label.position.copy(i)}addToScene(e){const t=this._options;let s=t instanceof HTMLElement?t:t.element,n=new A.Vector2().fromArray(t&&t.offset||[0,0]);return this._label=new ai(s),this._label.center=n,this.add(this._label),super.addToScene(e)}removeFromScene(){return this._label&&this.remove(this._label),super.removeFromScene()}_getAnchor(e,t){const s=t.getCenter(new A.Vector3);switch(e){case"center":return s;case"top":return new A.Vector3(s.x,s.y,t.max.z);case"bottom":return new A.Vector3(s.x,s.y,t.min.z);case"left":return new A.Vector3(t.min.x,s.y,s.z);case"right":return new A.Vector3(t.max.x,s.y,s.z);case"front":return new A.Vector3(s.x,t.min.y,s.z);case"back":return new A.Vector3(s.x,t.max.y,s.z);default:return s}}}class iu extends Xe{constructor(e,t){super(),this._object=e,this._options=t,this._parentObjectName="ObjectPathGroup",this._time=0}updateSceneTransform(){this._options.path&&(this._options.points=this._options.path.map(e=>this._scene.toScenePosition(e)),this._path=new A.CatmullRomCurve3(this._options.points,!1)),this.updateMatrixWorld(!0)}updateSceneTime(e,t){this._time+=t;const s=this._time%this._options.duration/this._options.duration;let n=this._path.getPointAt(s),i=this._path.getTangentAt(s).normalize(),r=n.clone().add(i);if(this._object.parent){const c=this._object.parent.matrixWorld.clone().invert();n=n.applyMatrix4(c),r=r.applyMatrix4(c)}const o=new A.Matrix4;o.lookAt(r,n,new A.Vector3(0,0,1)),this._object.position.copy(n),this._object.quaternion.setFromRotationMatrix(o)}}class ru extends Xe{constructor(e){super(),this._options=e,this._parentObjectName="ObjectMarkerGroup",this._markers=[]}updateSceneTransform(){this._markers.length==this._options.data.length&&(this._options.data.forEach((e,t)=>{e.position&&(e.point=this._scene.toScenePosition(e.position)),this._markers[t].position.copy(e.point)}),this.updateMatrixWorld(!0))}addToScene(e){return this.name=this._options.id+"-root",this._markers=[],this._options.data.forEach(t=>{const s=new ai(t.element);this.add(s),this._markers.push(s)}),super.addToScene(e)}removeFromScene(){return this.clear(),this._markers=[],super.removeFromScene()}}var It={defaultRadius:40,defaultRenderer:"canvas2d",defaultGradient:{.25:"rgb(0,0,255)",.55:"rgb(0,255,0)",.85:"yellow",1:"rgb(255,0,0)"},defaultMaxOpacity:1,defaultMinOpacity:0,defaultBlur:.85,defaultXField:"x",defaultYField:"y",defaultValueField:"value",plugins:{}},au=function(){var e=function(n){this._coordinator={},this._data=[],this._radi=[],this._min=10,this._max=1,this._xField=n.xField||n.defaultXField,this._yField=n.yField||n.defaultYField,this._valueField=n.valueField||n.defaultValueField,n.radius&&(this._cfgRadius=n.radius)},t=It.defaultRadius;return e.prototype={_organiseData:function(s,n){var i=s[this._xField],r=s[this._yField],o=this._radi,c=this._data,l=this._max,h=this._min,u=s[this._valueField]||1,d=s.radius||this._cfgRadius||t;c[i]||(c[i]=[],o[i]=[]),c[i][r]?c[i][r]+=u:(c[i][r]=u,o[i][r]=d);var f=c[i][r];return f>l?(n?this.setDataMax(f):this._max=f,!1):f<h?(n?this.setDataMin(f):this._min=f,!1):{x:i,y:r,value:u,radius:d,min:h,max:l}},_unOrganizeData:function(){var s=[],n=this._data,i=this._radi;for(var r in n)for(var o in n[r])s.push({x:r,y:o,radius:i[r][o],value:n[r][o]});return{min:this._min,max:this._max,data:s}},_onExtremaChange:function(){this._coordinator.emit("extremachange",{min:this._min,max:this._max})},addData:function(){if(arguments[0].length>0)for(var s=arguments[0],n=s.length;n--;)this.addData.call(this,s[n]);else{var i=this._organiseData(arguments[0],!0);i&&(this._data.length===0&&(this._min=this._max=i.value),this._coordinator.emit("renderpartial",{min:this._min,max:this._max,data:[i]}))}return this},setData:function(s){var n=s.data,i=n.length;this._data=[],this._radi=[];for(var r=0;r<i;r++)this._organiseData(n[r],!1);return this._max=s.max,this._min=s.min||0,this._onExtremaChange(),this._coordinator.emit("renderall",this._getInternalData()),this},removeData:function(){},setDataMax:function(s){return this._max=s,this._onExtremaChange(),this._coordinator.emit("renderall",this._getInternalData()),this},setDataMin:function(s){return this._min=s,this._onExtremaChange(),this._coordinator.emit("renderall",this._getInternalData()),this},setCoordinator:function(s){this._coordinator=s},_getInternalData:function(){return{max:this._max,min:this._min,data:this._data,radi:this._radi}},getData:function(){return this._unOrganizeData()}},e}(),ou=function(){var e=function(i){var r=i.gradient||i.defaultGradient,o=document.createElement("canvas"),c=o.getContext("2d");o.width=256,o.height=1;var l=c.createLinearGradient(0,0,256,1);for(var h in r)l.addColorStop(h,r[h]);return c.fillStyle=l,c.fillRect(0,0,256,1),c.getImageData(0,0,256,1).data},t=function(i,r){var o=document.createElement("canvas"),c=o.getContext("2d"),l=i,h=i;if(o.width=o.height=i*2,r==1)c.beginPath(),c.arc(l,h,i,0,2*Math.PI,!1),c.fillStyle="rgba(0,0,0,1)",c.fill();else{var u=c.createRadialGradient(l,h,i*r,l,h,i);u.addColorStop(0,"rgba(0,0,0,1)"),u.addColorStop(1,"rgba(0,0,0,0)"),c.fillStyle=u,c.fillRect(0,0,2*i,2*i)}return o},s=function(h){for(var r=[],o=h.min,c=h.max,l=h.radi,h=h.data,u=Object.keys(h),d=u.length;d--;)for(var f=u[d],p=Object.keys(h[f]),g=p.length;g--;){var m=p[g],I=h[f][m],b=l[f][m];r.push({x:f,y:m,value:I,radius:b})}return{min:o,max:c,data:r}};function n(i){var r=i.container,o=this.shadowCanvas=document.createElement("canvas"),c=this.canvas=i.canvas||document.createElement("canvas");this._renderBoundaries=[1e4,1e4,0,0];var l=getComputedStyle(i.container)||{};c.className="heatmap-canvas",this._width=c.width=o.width=i.width||+l.width.replace(/px/,""),this._height=c.height=o.height=i.height||+l.height.replace(/px/,""),this.shadowCtx=o.getContext("2d"),this.ctx=c.getContext("2d"),c.style.cssText=o.style.cssText="position:absolute;left:0;top:0;",r.style.position="relative",r.appendChild(c),this._palette=e(i),this._templates={},this._setStyles(i)}return n.prototype={renderPartial:function(i){i.data.length>0&&(this._drawAlpha(i),this._colorize())},renderAll:function(i){this._clear(),i.data.length>0&&(this._drawAlpha(s(i)),this._colorize())},_updateGradient:function(i){this._palette=e(i)},updateConfig:function(i){i.gradient&&this._updateGradient(i),this._setStyles(i)},setDimensions:function(i,r){this._width=i,this._height=r,this.canvas.width=this.shadowCanvas.width=i,this.canvas.height=this.shadowCanvas.height=r},_clear:function(){this.shadowCtx.clearRect(0,0,this._width,this._height),this.ctx.clearRect(0,0,this._width,this._height)},_setStyles:function(i){this._blur=i.blur==0?0:i.blur||i.defaultBlur,i.backgroundColor&&(this.canvas.style.backgroundColor=i.backgroundColor),this._width=this.canvas.width=this.shadowCanvas.width=i.width||this._width,this._height=this.canvas.height=this.shadowCanvas.height=i.height||this._height,this._opacity=(i.opacity||0)*255,this._maxOpacity=(i.maxOpacity||i.defaultMaxOpacity)*255,this._minOpacity=(i.minOpacity||i.defaultMinOpacity)*255,this._useGradientOpacity=!!i.useGradientOpacity},_drawAlpha:function(c){for(var r=this._min=c.min,o=this._max=c.max,c=c.data||[],l=c.length,h=1-this._blur;l--;){var u=c[l],d=u.x,f=u.y,p=u.radius,g=Math.min(u.value,o),m=d-p,I=f-p,b=this.shadowCtx,C;this._templates[p]?C=this._templates[p]:this._templates[p]=C=t(p,h);var y=(g-r)/(o-r);b.globalAlpha=y<.01?.01:y,b.drawImage(C,m,I),m<this._renderBoundaries[0]&&(this._renderBoundaries[0]=m),I<this._renderBoundaries[1]&&(this._renderBoundaries[1]=I),m+2*p>this._renderBoundaries[2]&&(this._renderBoundaries[2]=m+2*p),I+2*p>this._renderBoundaries[3]&&(this._renderBoundaries[3]=I+2*p)}},_colorize:function(){var i=this._renderBoundaries[0],r=this._renderBoundaries[1],o=this._renderBoundaries[2]-i,c=this._renderBoundaries[3]-r,l=this._width,h=this._height,u=this._opacity,d=this._maxOpacity,f=this._minOpacity,p=this._useGradientOpacity;i<0&&(i=0),r<0&&(r=0),i+o>l&&(o=l-i),r+c>h&&(c=h-r);for(var g=this.shadowCtx.getImageData(i,r,o,c),m=g.data,I=m.length,b=this._palette,C=3;C<I;C+=4){var y=m[C],B=y*4;if(B){var v;u>0?v=u:y<d?y<f?v=f:v=y:v=d,m[C-3]=b[B],m[C-2]=b[B+1],m[C-1]=b[B+2],m[C]=p?b[B+3]:v}}this.ctx.putImageData(g,i,r),this._renderBoundaries=[1e3,1e3,0,0]},getValueAt:function(i){var r,o=this.shadowCtx,c=o.getImageData(i.x,i.y,1,1),l=c.data[3],h=this._max,u=this._min;return r=Math.abs(h-u)*(l/255)>>0,r},getDataURL:function(){return this.canvas.toDataURL()}},n}(),cu=function(){var e=!1;return It.defaultRenderer==="canvas2d"&&(e=ou),e}(),Za={merge:function(){for(var a={},e=arguments.length,t=0;t<e;t++){var s=arguments[t];for(var n in s)a[n]=s[n]}return a}},Au=function(){var e=function(){function i(){this.cStore={}}return i.prototype={on:function(r,o,c){var l=this.cStore;l[r]||(l[r]=[]),l[r].push(function(h){return o.call(c,h)})},emit:function(r,o){var c=this.cStore;if(c[r])for(var l=c[r].length,h=0;h<l;h++){var u=c[r][h];u(o)}}},i}(),t=function(n){var i=n._renderer,r=n._coordinator,o=n._store;r.on("renderpartial",i.renderPartial,i),r.on("renderall",i.renderAll,i),r.on("extremachange",function(c){n._config.onExtremaChange&&n._config.onExtremaChange({min:c.min,max:c.max,gradient:n._config.gradient||n._config.defaultGradient})}),o.setCoordinator(r)};function s(){var n=this._config=Za.merge(It,arguments[0]||{});if(this._coordinator=new e,n.plugin){var i=n.plugin;if(It.plugins[i]){var r=It.plugins[i];this._renderer=new r.renderer(n),this._store=new r.store(n)}else throw new Error("Plugin '"+i+"' not found. Maybe it was not registered.")}else this._renderer=new cu(n),this._store=new au(n);t(this)}return s.prototype={addData:function(){return this._store.addData.apply(this._store,arguments),this},removeData:function(){return this._store.removeData&&this._store.removeData.apply(this._store,arguments),this},setData:function(){return this._store.setData.apply(this._store,arguments),this},setDataMax:function(){return this._store.setDataMax.apply(this._store,arguments),this},setDataMin:function(){return this._store.setDataMin.apply(this._store,arguments),this},configure:function(n){return this._config=Za.merge(this._config,n),this._renderer.updateConfig(this._config),this._coordinator.emit("renderall",this._store._getInternalData()),this},repaint:function(){return this._coordinator.emit("renderall",this._store._getInternalData()),this},getData:function(){return this._store.getData()},getDataURL:function(){return this._renderer.getDataURL()},getValueAt:function(n){return this._store.getValueAt?this._store.getValueAt(n):this._renderer.getValueAt?this._renderer.getValueAt(n):null}},s}();class lu{static create(e){return new Au(e)}static register(e,t){It.plugins[e]=t}}class ei extends A.BufferGeometry{constructor(e=new A.Vector3(-1,1,0),t=new A.Vector3(-1,-1,0),s=new A.Vector3(1,-1,0),n=new A.Vector3(1,1,0),i=1,r=1){super(),this.type="HeatmapGeometry",this.parameters={v1:e,v2:t,v3:s,v4:n,widthSegments:i,heightSegments:r};const o=Math.floor(i),c=Math.floor(r),l=o+1,h=c+1,u=[],d=[],f=[],p=[];for(let g=0;g<h;g++){const m=g/c,I=new A.Vector3().lerpVectors(e,t,m),b=new A.Vector3().lerpVectors(n,s,m);for(let C=0;C<l;C++){const y=C/o,B=new A.Vector3().lerpVectors(I,b,y);d.push(B.x,B.y,B.z),f.push(0,0,1),p.push(y),p.push(1-m)}}for(let g=0;g<c;g++)for(let m=0;m<o;m++){const I=m+l*g,b=m+l*(g+1),C=m+1+l*(g+1),y=m+1+l*g;u.push(I,b,y),u.push(b,C,y)}this.setIndex(u),this.setAttribute("position",new A.Float32BufferAttribute(d,3)),this.setAttribute("normal",new A.Float32BufferAttribute(f,3)),this.setAttribute("uv",new A.Float32BufferAttribute(p,2))}getUV(e){const{v1:t,v2:s,v3:n,v4:i}=this.parameters,r=(t.y-e.y)/(t.y-s.y),o=(i.y-e.y)/(i.y-n.y),c=(r+o)/2,l=new A.Vector3().lerpVectors(t,s,c),h=new A.Vector3().lerpVectors(i,n,c),u=(l.x-e.x)/(l.x-h.x);return new A.Vector2(u,c)}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ei(e.v1,e.v2,e.v3,e.v4,e.widthSegments,e.heightSegments)}}function hu(a=new A.Vector3(-1,1,0),e=new A.Vector3(-1,-1,0),t=new A.Vector3(1,-1,0),s=new A.Vector3(1,1,0)){const n=(new A.Vector3().subVectors(t,e).length()+new A.Vector3().subVectors(s,a).length())/2,i=(new A.Vector3().subVectors(a,e).length()+new A.Vector3().subVectors(s,t).length())/2;return[n,i]}class uu extends Xe{constructor(e){super(),this._options=e,this._meshObject=void 0,this._heatmap=void 0,this._heatmapCanvas=void 0}updateSceneTransform(){let{coordinates:e,data:t}=this._options;if(e==null||e.length!=4){const[[s,n,i],[r,o,c]]=Ul({type:"MultiPoint",coordinates:t});e=[[s,o,i],[s,n,i],[r,n,i],[r,o,i]]}this._boundVertices=[],e.forEach(s=>{const n=this._scene.toScenePosition(s);this._boundVertices.push(n)}),this._dataVertices=[],t.forEach(s=>{const n=this._scene.toScenePosition([s[0],s[1]]);this._dataVertices.push(new A.Vector3(n.x,n.y,s[2]))}),this.buildHeatmap(),this.updateMatrixWorld(!0)}buildHeatmap(){const e=hu(this._boundVertices[0],this._boundVertices[1],this._boundVertices[2],this._boundVertices[3]),t=this._options.width||e[0],s=this._options.height||(t?t/e[0]*e[1]:e[1]),n=this._options.blur||.8,i=this._options.radius||10,r=this._options.gradient||{},o=document.createElement("heatmap-canvas");o.style.width=t.toString(),o.style.height=s.toString(),o.style.position="absolute",o.style.top="0",o.style.left="0",this._heatmapCanvas=o,this._heatmap=lu.create({container:o,width:t,height:s,blur:n,radius:i,gradient:r});const c=this._options.widthSegments||128,l=this._options.heightSegments||c/e[0]*e[1],h=new ei(this._boundVertices[0],this._boundVertices[1],this._boundVertices[2],this._boundVertices[3],c,l);let u=[],d=1/0,f=-1/0;this._dataVertices.forEach(C=>{const y=h.getUV(C),B=Math.round(t*y.x),v=Math.round(s*y.y),_=C.z;u.push({x:B,y:v,value:_}),_>f&&(f=_),_<d&&(d=_)}),this._heatmap.setData({data:u,max:f*.9,min:d});const p=this._options.heightRatio||1,g=this._options.depthTest||!1,m=new A.CanvasTexture(this._heatmap._renderer.canvas);m.needsUpdate=!0;const I={transparent:!0,depthTest:g,side:A.DoubleSide,vertexShader:`
        uniform sampler2D heightMap;
        uniform float heightRatio;
        varying vec2 vUv;
        varying float hValue;
        varying vec3 cl;
        void main() {
            vUv = uv;
            vec3 pos = position;
            vec4 c = texture2D(heightMap, vUv);
            cl = c.rgb;
            hValue = c.a;
            pos.z += hValue * heightRatio;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
        }
      `,fragmentShader:`
        varying float hValue;
        varying vec3 cl;
        void main() {
            float v = abs(hValue - 1.);
            gl_FragColor = vec4(cl, .8 - v * v*1.1) ; 
        }
      `,uniforms:{heightMap:{value:m},heightRatio:{value:p}}},b=new A.ShaderMaterial(I);b.uniforms.heightMap.value=m,this._meshObject=new A.Mesh(h,b),this.add(this._meshObject)}updateSceneTime(e,t){this._meshObject&&this._meshObject.updateSceneTime&&this._meshObject.updateSceneTime(e,t,this._scene)}addToScene(e){return this._scene=e,super.addToScene(e)}removeFromScene(){return this._meshObject&&(this.remove(this._meshObject),this._meshObject=void 0),this._heatmap&&(this._heatmap=void 0),this._heatmapCanvas&&(this._heatmapCanvas.remove(),this._heatmapCanvas=void 0),super.removeFromScene()}}class du{constructor(e,t,s){this.runVelocity=5,this.walkVelocity=2,this.upVelocity=.01,this.rotateVeclocity=.02,this.scaleVeclocity=1,this.fadeDuration=.2,this.modelRotateOffset=!0,this.modelRotateAxis=new A.Vector3(0,1,0),this.toggleRun=!1,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.moveUp=!1,this.moveDown=!1,this.model=e,this.mixer=t,this.camera=s}toggleVisible(){this.model.visible=!this.model.visible}_getAnimation(e){switch(e){case"idle":return this.idleAnimationAction;case"walk":return this.walkAnimationAction||this.runAnimationAction||this.idleAnimationAction;case"run":return this.runAnimationAction||this.walkAnimationAction||this.idleAnimationAction}}toggleAction(e){if(this.currentAction!=e){const t=this._getAnimation(e),s=this._getAnimation(this.currentAction);t!==s?(s==null||s.fadeOut(this.fadeDuration),t==null||t.reset().fadeIn(this.fadeDuration).play()):t==null||t.play(),this.currentAction=e}}update(e){var i,r,o;if(this.moveUp||this.moveDown){const c=this.upVelocity*this.scaleVeclocity*(this.moveUp?1:-1);this.moveWorldPosition(0,0,c)}var t=!1;if(this.moveBackward||this.moveForward||this.moveLeft||this.moveRight){t=!0;const c=new A.Vector3(0,0,1);(i=this.camera)==null||i.getWorldPosition(c);const l=new A.Vector3;this.model.getWorldPosition(l);var s=Math.atan2(c.x-l.x,-(c.y-l.y)),n=this.directionOffset();const h=new A.Quaternion;h.setFromAxisAngle(this.modelRotateAxis,s+(this.modelRotateOffset?n:0)),this.model.quaternion.rotateTowards(h,this.rotateVeclocity);const u=new A.Vector3(0,0,1),d=new A.Vector3(0,1,0);(r=this.camera)==null||r.getWorldDirection(d),d.z=0,d.normalize(),d.applyAxisAngle(u,n);const p=(this.toggleRun?this.runVelocity:this.walkVelocity)*.01*this.scaleVeclocity,g=d.x*p,m=d.y*p;this.moveWorldPosition(g,m,0)}t?this.toggleAction(this.toggleRun?"run":"walk"):this.toggleAction("idle"),(o=this.mixer)==null||o.update(e)}moveWorldPosition(e,t,s){const n=new A.Vector3;if(this.model.getWorldPosition(n),n.x+=e,n.y+=t,n.z+=s,this.model.parent){const i=new A.Matrix4().copy(this.model.parent.matrixWorld).invert(),r=n.clone().applyMatrix4(i);this.model.position.copy(r)}else this.model.position.copy(n)}directionOffset(){var e=0;return this.moveForward?this.moveLeft?e=Math.PI/4:this.moveRight&&(e=-Math.PI/4):this.moveBackward?this.moveLeft?e=Math.PI/4+Math.PI/2:this.moveRight?e=-Math.PI/4-Math.PI/2:e=Math.PI:this.moveLeft?e=Math.PI/2:this.moveRight&&(e=-Math.PI/2),e}}function Ls(a,...e){for(const t of e)for(const s in t)a[s]=t[s];return a}function ti(a,e){a.forEach(t=>{e[t]&&(e[t]=e[t].bind(e))})}class fu{constructor(e){this.character=e,ti(["keydown","keyup"],this)}keydown(e){const t=this.character;switch(e.key.toLowerCase()){case"shift":t.toggleRun=!0;break;case"=":case"+":t.scaleVeclocity*=1.05,t.scaleVeclocity>100&&(t.scaleVeclocity=100);break;case"-":case"_":t.scaleVeclocity*=.95,t.scaleVeclocity<.01&&(t.scaleVeclocity=.01);break;case"v":t.toggleVisible();break;case"w":t.moveForward=!0;break;case"s":t.moveBackward=!0;break;case"a":t.moveLeft=!0;break;case"d":t.moveRight=!0;break;case"q":t.moveUp=!0;break;case"e":t.moveDown=!0;break}}keyup(e){const t=this.character;switch(e.key.toLowerCase()){case"shift":t.toggleRun=!1;break;case"w":t.moveForward=!1;break;case"s":t.moveBackward=!1;break;case"a":t.moveLeft=!1;break;case"d":t.moveRight=!1;break;case"q":t.moveUp=!1;break;case"e":t.moveDown=!1;break}}enable(){window.addEventListener("keyup",this.keyup),window.addEventListener("keydown",this.keydown)}disable(){window.removeEventListener("keyup",this.keyup),window.removeEventListener("keydown",this.keydown)}update(e){}}class si{constructor(){this.object=null,this.objectPosition=new A.Vector3(0,0,0),this.objectHeight=1,this.cameraPitch=0,this.cameraBearing=0,this.cameraDistance=10,this.cameraMaxDistance=1e4,this.cameraMinDistance=1,this.cameraMaxPitch=85,this.cameraMinPitch=0,this.cameraMaxBearing=0,this.cameraMinBearing=0,this._cameraPosition=new A.Vector3,this._targetPosition=new A.Vector3}_limitCamera(){this.cameraMinBearing<this.cameraMaxBearing&&(this.cameraBearing=A.MathUtils.clamp(this.cameraBearing,this.cameraMinBearing,this.cameraMaxBearing)),this.cameraMinPitch<this.cameraMaxPitch&&(this.cameraPitch=A.MathUtils.clamp(this.cameraPitch,this.cameraMinPitch,this.cameraMaxPitch)),this.cameraMinDistance<this.cameraMaxDistance&&(this.cameraDistance=A.MathUtils.clamp(this.cameraDistance,this.cameraMinDistance,this.cameraMaxDistance))}_calcCameraPosition(){var l;(l=this.object)==null||l.getWorldPosition(this.objectPosition),this.objectPosition.z+=this.objectHeight,this.objectPosition.z<.01&&(this.objectPosition.z=.01);const e=A.MathUtils.degToRad(this.cameraPitch),t=A.MathUtils.degToRad(this.cameraBearing),s=Math.sin(e),n=-s*Math.sin(t),i=-s*Math.cos(t),r=Math.cos(e),o=new A.Vector3(n,i,r);let c=this.objectPosition.z/r;this._targetPosition.copy(this.objectPosition).addScaledVector(o,-c),this._cameraPosition.copy(this.objectPosition).addScaledVector(o,this.cameraDistance)}update(e){this._limitCamera(),this._calcCameraPosition()}getCameraPosition(){return this._cameraPosition}getTargetPosition(){return this._targetPosition}}class pu{constructor(e){this.zoomSpeed=1,this.rotateXSpeed=1,this.rotateYSpeed=1,this._moveLook=!1,this._pointerX=0,this._pointerY=0,this._pointerXLast=0,this._pointerYLast=0,this.followCamera=e,ti(["mousedown","mousemove","mouseup","mousewheel","contextmenu"],this)}mousewheel(e){const t=this.followCamera,s=this;let n=e.deltaMode===WheelEvent.DOM_DELTA_LINE?e.deltaY*40:e.deltaY;const i=s.zoomSpeed,r=Math.abs(n*.01),o=Math.pow(.95,i*r);n<0?t.cameraDistance*=o:t.cameraDistance/=o}mousedown(e){switch(this._pointerX=e.pageX,this._pointerY=e.pageY,this._pointerXLast=this._pointerX,this._pointerYLast=this._pointerY,e.button){case 2:this._moveLook=!0;break}}mouseup(e){switch(e.button){case 2:this._moveLook=!1;break}}mousemove(e){if(this._pointerX=e.pageX,this._pointerY=e.pageY,this._moveLook){const t=this.rotateXSpeed,s=this.rotateYSpeed,n=.5*t,i=(this._pointerX-this._pointerXLast)*n,r=-.3*s,o=(this._pointerY-this._pointerYLast)*r;this.followCamera.cameraBearing+=i,this.followCamera.cameraPitch+=o}this._pointerXLast=this._pointerX,this._pointerYLast=this._pointerY}contextmenu(e){e.preventDefault()}enable(){window.addEventListener("wheel",this.mousewheel),window.addEventListener("pointerdown",this.mousedown),window.addEventListener("pointerup",this.mouseup),window.addEventListener("pointermove",this.mousemove),window.addEventListener("contextmenu",this.contextmenu)}disable(){window.removeEventListener("wheel",this.mousewheel),window.removeEventListener("pointerdown",this.mousedown),window.removeEventListener("pointerup",this.mouseup),window.removeEventListener("pointermove",this.mousemove),window.removeEventListener("contextmenu",this.contextmenu)}update(e){}}class ni{constructor(e){this.enabled=!1,this.dragPan=void 0,this.dragRotate=void 0,this.scrollZoom=void 0,this.keyboard=void 0,this.scene=e}enable(){this.enabled=!0,this.scene.addEventListener(ht,this.onSceneUpdate.bind(this));const e=this.scene.getMap();this.dragPan=e.dragPan.isEnabled(),this.dragRotate=e.dragRotate.isEnabled(),this.scrollZoom=e.scrollZoom.isEnabled(),this.keyboard=e.keyboard.isEnabled(),e.dragPan.disable(),e.dragRotate.disable(),e.scrollZoom.disable(),e.keyboard.disable()}disable(){const e=this.scene.getMap();this.dragPan?e.dragPan.enable():e.dragPan.disable(),this.dragRotate?e.dragRotate.enable():e.dragRotate.disable(),this.scrollZoom?e.scrollZoom.enable():e.scrollZoom.disable(),this.keyboard?e.keyboard.enable():e.keyboard.disable(),this.dragPan=void 0,this.dragRotate=void 0,this.scrollZoom=void 0,this.keyboard=void 0,this.scene.removeEventListener(ht,this.onSceneUpdate.bind(this)),this.enabled=!1}onSceneUpdate(e){this.update(e.delta/1e3)}update(e){}}function ii(a,e){const t=a.getMap(),s=e.getTargetPosition(),n=e.getCameraPosition(),i=e.cameraBearing,r=e.cameraPitch,o=new A.Vector3().subVectors(n,s).length(),c=a.toMapPosition(s),l=t.transform.pixelsPerMeter/t.transform.worldSize*o,h=t.transform._zoomFromMercatorZ(l);return{center:c,bearing:i,pitch:r,zoom:h}}const gu={model:void 0,mixer:void 0,idleAnimationAction:void 0,walkAnimationAction:void 0,runAnimationAction:void 0,runVelocity:5,walkVelocity:2,upVelocity:.01,rotateVeclocity:.02,scaleVeclocity:1,fadeDuration:.2,modelRotateOffset:!0,modelRotateAxis:new A.Vector3(0,1,0),objectHeight:1,cameraPitch:0,cameraBearing:0,cameraDistance:10,cameraMaxDistance:100,cameraMinDistance:1,cameraMaxPitch:85,cameraMinPitch:0,cameraMaxBearing:0,cameraMinBearing:0};class mu extends ni{constructor(e,t){super(e),this.mapCameraPosition={},t=Ls({},gu,t);const s=e.getCamera(),n=t.model,i=t.mixer;this.character=new du(n,i,s),this.character.idleAnimationAction=t.idleAnimationAction,this.character.walkAnimationAction=t.walkAnimationAction,this.character.runAnimationAction=t.runAnimationAction,this.character.runVelocity=t.runVelocity,this.character.walkVelocity=t.walkVelocity,this.character.upVelocity=t.upVelocity,this.character.rotateVeclocity=t.rotateVeclocity,this.character.scaleVeclocity=t.scaleVeclocity,this.character.fadeDuration=t.fadeDuration,this.character.modelRotateOffset=t.modelRotateOffset,this.character.modelRotateAxis=t.modelRotateAxis,this.followCamera=new si,this.followCamera.object=n,this.followCamera.objectHeight=t.objectHeight,this.followCamera.cameraPitch=t.cameraPitch,this.followCamera.cameraBearing=t.cameraBearing,this.followCamera.cameraDistance=t.cameraDistance,this.followCamera.cameraMaxDistance=t.cameraMaxDistance,this.followCamera.cameraMinDistance=t.cameraMinDistance,this.followCamera.cameraMaxPitch=t.cameraMaxPitch,this.followCamera.cameraMinPitch=t.cameraMinPitch,this.followCamera.cameraMaxBearing=t.cameraMaxBearing,this.followCamera.cameraMinBearing=t.cameraMinBearing,this.characterHandle=new fu(this.character),this.followCameraHandle=new pu(this.followCamera)}update(e){if(!this.enabled)return;this.characterHandle.update(e),this.followCameraHandle.update(e),this.UpdateMapCameraPosition(e),this.scene.getMap().jumpTo(this.mapCameraPosition)}UpdateMapCameraPosition(e=0){return this.character.update(e),this.followCamera.update(e),this.mapCameraPosition=ii(this.scene,this.followCamera),this.mapCameraPosition}enable(){super.enable(),this.characterHandle.enable(),this.followCameraHandle.enable()}disable(){this.characterHandle.disable(),this.followCameraHandle.disable(),super.disable()}}const bu={path:[],points:[],pathClose:!1,duration:10,cameraPitch:45,cameraBearing:0,cameraDistance:10};class Cu extends ni{constructor(e,t){super(e),this.mapCameraPosition={},this.options=Ls({},bu,t),this.followCamera=new si,this.updatePath()}updatePath(){this.options.path&&(this.options.points=this.options.path.map(e=>this.scene.toScenePosition(e))),this.options.points&&(this._time=0,this._path=new A.CatmullRomCurve3(this.options.points,this.options.pathClose))}update(e){if(!this.enabled)return;this.UpdateMapCameraPosition(e),this.scene.getMap().jumpTo(this.mapCameraPosition)}UpdateMapCameraPosition(e=0){if(this._path===void 0)return;this._time+=e;const t=this._time%this.options.duration/this.options.duration;let s=this._path.getPointAt(t),n=this._path.getTangentAt(t).normalize();return n.projectOnPlane(new A.Vector3(0,0,1)).normalize(),this.followCamera.cameraPitch=this.options.cameraPitch,this.followCamera.cameraDistance=this.options.cameraDistance,this.followCamera.cameraBearing=this.options.cameraBearing+A.MathUtils.radToDeg(Math.atan2(n.x,n.y)),this.followCamera.objectPosition.copy(s),this.followCamera.update(e),this.mapCameraPosition=ii(this.scene,this.followCamera),this.mapCameraPosition}}const Iu={position:void 0,point:void 0,duration:10,isClockwise:!0,cameraBearing:0,cameraPitch:45,cameraDistance:10};class yu extends ni{constructor(e,t){super(e),this.mapCameraPosition={},this.options=Ls({},Iu,t),this.followCamera=new si,this.updatePosition()}updatePosition(){this.options.position&&(this.options.point=this.scene.toScenePosition(this.options.position)),this.options.point&&(this._time=0)}update(e){if(!this.enabled)return;this.UpdateMapCameraPosition(e),this.scene.getMap().jumpTo(this.mapCameraPosition)}UpdateMapCameraPosition(e=0){if(this.options.point===void 0)return;this._time+=e;let t=this._time%this.options.duration/this.options.duration;return this.options.isClockwise&&(t=1-t),this.followCamera.cameraPitch=this.options.cameraPitch,this.followCamera.cameraDistance=this.options.cameraDistance,this.followCamera.cameraBearing=this.options.cameraBearing+t*360,this.followCamera.objectPosition.copy(this.options.point),this.followCamera.update(e),this.mapCameraPosition=ii(this.scene,this.followCamera),this.mapCameraPosition}}class Bu{constructor(e){this._scene=e,this._controls=void 0}setControls(e){let t=null;switch(e.type){case"firstPerson":t=new mu(this._scene,e);break;case"alongPath":t=new Cu(this._scene,e);break;case"aroundPoint":t=new yu(this._scene,e);break}return this._setControls(t),t}getControls(){return this._controls}_setControls(e){this._controls!==e&&(this._controls&&this._controls.disable(),this._controls=e,this._controls&&this._controls.enable())}}class ri{constructor(e){this.type="custom",this.renderingMode="3d",this.onAdd=(t,s)=>{var o;this._map=t,this._map.transform.setOrthographicProjectionAtLowPitch(!1),this._scene=this._helper.createScene(this._options.createLight||!0),this._sceneRoot=this._helper.createGroup(this._scene,"scene-root"),this._camera=this._helper.createCamera(this._sceneRoot,"camera-for-render"),this._renderer=new ro(t,s);const n=this._options.refCenter||((o=this._map)==null?void 0:o.getCenter());this.setRefCenter(n);const i=this._options.envTexture;this.setEnvTexture(i);const r=this._options.envIntensity||1;this.setEnvIntensity(r),this._sceneControls=new Bu(this)},this.onRemove=(t,s)=>{this._camera=void 0,this._sceneRoot=void 0,this._scene=void 0,this._renderer=void 0,this._map=void 0},this.render=(t,s)=>{!this._map||!this._renderer||!this._scene||!this._camera||(this._helper.updateCameraForRender(this._camera,this._map,s,this._worldMatrix,this._worldMatrixInv),this.update(),this._renderer.render(this._scene,this._camera),this._map.triggerRepaint())},this.id=e.id,this.slot=e.slot,this._helper=new oo,this._options={...ri._GetDefaultOptions(),...e}}static _GetDefaultOptions(){return{id:"threejs-scene-layer"}}_update(){var e;(e=this._map)==null||e.triggerRepaint()}addEventListener(e,t){var s;(s=this._scene)==null||s.addEventListener(e,t)}removeEventListener(e,t){var s;(s=this._scene)==null||s.removeEventListener(e,t)}dispatchEvent(e){var t;(t=this._scene)==null||t.dispatchEvent(e)}update(){if(!this._map||!this._renderer||!this._scene||!this._camera)return;const e=Date.now();this._startTime===void 0&&(this._startTime=e,this._lastTime=e);const t=e-this._lastTime,s=e-this._startTime;this._lastTime=e;const n={type:ht,time:s,delta:t};this.dispatchEvent(n)}getSceneRoot(){return this._sceneRoot}getRenderer(){return this._renderer}getWebGLRenderer(){return this._renderer.getRenderer()}getCamera(){return this._camera}getScene(){return this._scene}getMap(){return this._map}getRefCenter(){return this._refCenter}setRefCenter(e){if(this._refCenter!==e&&this._map){this._refCenter=e,this._worldMatrix=_e.updateWorldMatrix(this._map,e),this._worldMatrixInv=this._worldMatrix.clone().invert(),this._update();const t={type:Kt};this.dispatchEvent(t)}}toScenePosition(e,t){return Array.isArray(e)&&e.length>2&&t===void 0&&(t=e[2]),_e.toScenePosition(this._worldMatrixInv,e,t)}toMapPosition(e){return _e.toMapPosition(this._worldMatrix,e)}toMercatorCoordinate(e){return _e.toMapPositionMercator(this._worldMatrix,e)}setEnvTexture(e){this._helper.createEnvTexture(e,this._scene)}setEnvIntensity(e){this._scene&&(this._scene.environmentIntensity=e,this._update())}compileAsync(e){return new Promise(t=>{var s;(s=this._renderer.getRenderer())==null||s.compileAsync(e,this._camera,this._scene).then(()=>{t(e)})})}findObjectByName(e,t){return t?t.getObjectByName(e):this.findObjectByName(e,this._sceneRoot)}intersectObjects(e,t){t||(t=this._sceneRoot.children),t instanceof A.Object3D&&(t=[t]);let s=new A.Vector2;s.x=e.x/this._map.transform.width*2-1,s.y=1-e.y/this._map.transform.height*2;const n=new A.Raycaster;return n.layers.set(0),n.setFromCamera(s,this._camera),n.intersectObjects(t,!0)}setControls(e){return this._sceneControls.setControls(e)}addTileset(e){return new ya(e).addToScene(this)}addModel(e){return new Qa(e).addToScene(this)}addMesh(e){return new su(e).addToScene(this)}addLabel(e,t){return new nu(e,t).addToScene(this)}addPath(e,t){return new iu(e,t).addToScene(this)}addMarker(e){return new ru(e).addToScene(this)}addHeatmap(e){return new uu(e).addToScene(this)}}ae.AutoReleaseWorkerPool=Gt,ae.Model=Qa,ae.SceneObject=Xe,ae.SceneRecenterEventType=Kt,ae.SceneUpdateEventType=ht,ae.ThreejsSceneLayer=ri,ae.Tileset=ya,ae.WorkerPool=Wr,ae.bindAll=ti,ae.extend=Ls,Object.defineProperty(ae,Symbol.toStringTag,{value:"Module"})});
